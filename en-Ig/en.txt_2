@@image: 'figures/file-roller_main_window.png'; md5=1ffe6686c623c5a279a1ad13fb8eb488
@@image: 'figures/file-roller_leftarrow.png'; md5=1878b2a4132b673aa79df7660398caa0
@@image: 'figures/file-roller_rightarrow.png'; md5=45a0479ca13140680220976ccb653bda
@@image: 'figures/file-roller_uparrow.png'; md5=097f01471c5575ceeb527ea8d50061bd
@@image: 'figures/file-roller_home.png'; md5=1cede2c4f8d21c357d0eb9979f39f18d
Archive Manager Manual
Archive Manager, also known as File Roller, allows you to create, view, modify, or unpack an archive.
2009
Paul Cutler
2006
2008
Paolo Bacchilega
2003
2004
Sun Microsystems
2002
Alexander Kirillov
GNOME Documentation Project
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License (GFDL), Version 1.1 or any later version published by the Free Software Foundation with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You can find a copy of the GFDL at this link or in the file COPYING-DOCS distributed with this manual.
This manual is part of a collection of GNOME manuals distributed under the GFDL. If you want to distribute this manual separately from the collection, you can do so by adding a copy of the license to the manual, as described in section 6 of the license.
Many of the names used by companies to distinguish their products and services are claimed as trademarks. Where those names appear in any GNOME documentation, and the members of the GNOME Documentation Project are made aware of those trademarks, then the names are in capital letters or initial capital letters.
DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS FREE OF DEFECTS MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT OR MODIFIED VERSION PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER; AND
UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY DISTRIBUTOR OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO USE OF THE DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.
DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE FURTHER UNDERSTANDING THAT:
Sun
GNOME Documentation Team
Paolo
Bacchilega
Alexander
Kirillov
kirillov@math.sunysb.edu
Paul
Cutler
pcutler@foresightlinux.org
Archive Manager Manual V2.26.0
March 2009
Archive Manager Manual V2.24.0
July 2008
Archive Manager Manual V2.6
April 2006
File Roller Manual V2.5
March 2004
Sun GNOME Documentation Team
File Roller Manual V2.4
February 2004
File Roller Manual V2.3
August 2003
File Roller Manual V2.2
June 2003
File Roller Manual V2.1
January 2003
File Roller Manual V2.0
June 2002
This manual describes version 2.26.0 of Archive Manager.
Feedback
To report a bug or make a suggestion regarding the Archive Manager application or this manual, follow the directions in the GNOME Feedback Page.
File Roller
file-roller
Archiving
Archives
Adding files to
Deleting files from
Opening
Viewing
Extracting
Creating
Introduction
You can use the Archive Manager application to create, view, modify, or unpack an archive. An archive is a file that acts as a container for other files. An archive can contain many files, folders, and subfolders, usually in compressed form.
Archive Manager provides only a graphical interface, and relies on command-line utilities such as tar, gzip, and bzip2 for archive operations.
If you have the appropriate command-line tools installed on your system, Archive Manager supports the archive formats listed in the following table.
Format
Filename Extension
7-Zip archive
.7z
WinAce archive
.ace
ALZip archive
.alz
AIX small indexed archive
.ar
ARJ archive
.arj
Cabinet file
.cab
UNIX CPIO archive
.cpio
Debian Linux package
.deb
ISO-9660 CD disc image
.iso
Java archive
.jar
Java enterprise archive
.ear
Java web archive
.war
LHA archive
.lha, .lzh
WinRAR compressed archive
.rar
RAR Archived Comic Book
.cbr
RPM Linux package
.rpm
Uncompressed tar archive
.tar
Tar archive compressed with bzip
.tar.bz or .tbz
Tar archive compressed with bzip2
.tar.bz2 or .tbz2
Tar archive compressed with gzip
.tar.gz or .tgz
Tar archive compressed with lzip
.tar.lz or .tlz
Tar archive compressed with lzop
.tar.lzo or .tzo
Tar archive compressed with compress
.tar.Z or .taz
Tar archive compressed with 7zip
.tar.7z
Stuffit archives
.bin or .sit
PKZIP or WinZip archive
.zip
ZIP Archived Comic Book
.cbz
Zoo archive
.zoo
The most common archive format on UNIX and Linux systems is the tar archive compressed with gzip or bzip2.
The most common archive format on Microsoft Windows systems is the archive created with PKZIP or WinZip.
Compressed Non-Archive Files
A compressed non-archive file is a file that is created when you use bzip2, gzip, lzip, lzop, compress or rzip to compress a non-archive file. For example, file.txt.gz is created when you use gzip to compress file.txt.
You can use Archive Manager to create, open and extract a compressed non-archive file.
Getting Started
This section provides information on how to start Archive Manager, and describes the Archive Manager user interface.
To Start Archive Manager
You can start Archive Manager in the following ways:
Applications menu
Choose AccessoriesArchive Manager.
Command line
Execute the following command: file-roller
When You Start Archive Manager
When you start Archive Manager, the following window is displayed:
Archive Manager Window
Shows File Roller main window.
The Archive Manager window contains the following elements:
Menubar
The menus on the menubar contain all of the commands that you need to work with archives in Archive Manager.
Toolbar
The toolbar contains a subset of the commands that you can access from the menubar. Archive Manager displays the toolbar by default. To hide the toolbar, choose ViewToolbar. To show the toolbar, choose ViewToolbar again.
Folderbar
The folderbar enables you to navigate among folders within an archive. Archive Manager displays the folderbar only in folder view. See for more information.
Display area
The display area displays the contents of the archive.
Statusbar
The statusbar displays information about current Archive Manager activity and contextual information about the archive contents. Archive Manager displays the statusbar by default. To hide the statusbar, choose ViewStatusbar. To show the statusbar, choose ViewStatusbar again.
When you right-click in the Archive Manager window, the application displays a popup menu. The popup menu contains the most common contextual archive commands.
Browsing the Filesystem
Several Archive Manager dialogs (New, Open, Extract,...) enable you to browse files and folders on your computer. Refer to the Desktop User Guide to learn more about using the file browsing dialogs.
You can also refer to the Bookmarks section of the Desktop User Guide to learn how you can use the Places pane to access your favorite locations.
Working With Archives
When you use Archive Manager to work with an archive, all changes are saved to disk immediately. For example, if you delete a file from an archive, Archive Manager deletes the file as soon as you click OK. This behavior is different to that of most applications, which save the changes to disk only when you quit the application or select Save in the menu.
If an archive is very large, or you have a slow system, some archive actions can take significant time. To abort the current action, press Esc. Alternatively, choose ViewStop, or click Stop in the toolbar.
UI Component
Action
Window
Drag an archive into the Archive Manager window from another application such as a file manager.
Choose ArchiveOpen.
If you have recently opened the archive, it will be listed directly in the Archive menu.
Click on the Open toolbar button.
If you have recently opened the archive, click on the down arrow near the Open toolbar button.
Right-click popup menu
Right-click on the archive, then choose Open from the popup menu.
Shortcut keys
Press CtrlO.
In Archive Manager, you can perform the same action in several ways. For example, you can open an archive in the following ways:
This manual documents functionality from the menubar.
Filename Patterns
Archive Manager enables you to add, extract, or delete several files at once. To apply an action to all files that match a certain pattern, enter the pattern in the text box. The pattern can include standard wildcard symbols such as * to match any string, and ? to match any single symbol. You can enter several patterns separated by semicolons. Archive Manager applies the action to all files that match at least one of the patterns. The examples in the following table show how to use filename patterns to select files.
Pattern
Files Matched
*
All files
*.tar*
All files with extension tar, including those in which the tar extension is followed by any sequence of symbols, such as filename.tar.gz
*.jpg; *.jpeg
All files with extension jpg and all files with extension jpeg
file?.gz
All files with extension gz that have the name "file" followed by any single character, e.g. file2.gz, filex.gz.
To Open an Archive
Choose ArchiveOpen to display the Open dialog. Alternatively press CtrlO, or click Open in the toolbar.
Select the archive that you want to open.
Click Open.
To open an archive, perform the following steps:
The archive name in the window titlebar
The archive contents in the display area
The number files and folders (objects) in the current location, and their size when uncompressed, in the statusbar
Archive Manager automatically determines the archive type, and displays:
To open another archive, choose ArchiveOpen again. Archive Manager opens each archive in a new window. You can't open another archive in the same window.
If you try to open an archive that was created in a format that Archive Manager does not recognize, the application displays an error message. See for a list of supported formats.
To Select Files in an Archive
To select all files in an archive, choose EditSelect All or press CtrlA.
To deselect all files in an archive, choose EditDeselect All or press ShiftCtrlA.
To Extract Files From an Archive
Select the files that you want to extract. To select more files, press-and-hold Ctrl and click on the files you want to select.
Choose ArchiveExtract to display the Extract dialog. Alternatively click Extract in the toolbar.
Select the folder where Archive Manager extracts the files.
Select the required extract options. For more information about the extract options, see .
Click Extract.
If all of the files in the archive are protected by a password, and you have not specified it, Archive Manager asks you to enter the password.
If some but not all of the files in the archive are protected by a password, and you have not specified the password, Archive Manager does not ask for a password. However, Archive Manager extracts only the unprotected files.
For more information about passwords, see .
To extract files from an open archive, perform the following steps:
Archive Manager also provides ways of extracting files from an archive in a file manager window, without opening a Archive Manager window. See for more information.
The Extract operation extracts a copy of the specified files from the archive. The extracted files have the same permissions and modification date as the original files that were added to the archive.
The Extract operation does not change the contents of the archive. For information on how to delete files from an archive, see .
To Close an Archive
To close the current archive and the current Archive Manager window, choose ArchiveClose, or press CtrlW.
There is no way to close the current archive but not the Archive Manager window.
Creating Archives
In addition to opening existing archives, you can also create new archives with Archive Manager.
To Create an Archive
Choose ArchiveNew to display the New dialog. Alternatively press CtrlN, or click New in the toolbar.
Specify the folder where Archive Manager places the new archive clicking on the entry in the Save in folder drop-down list. If the folder is not present in list, click on Browse for other folders, and select the folder. Alternatively, enter the path in the Name text box.
Enter the name of the new archive, including the file extension, in the Name text box. Alternatively you can specify the archive name without extension, and then select the archive type from the Archive type drop-down menu, this way the extension will be added automatically.
Select the required create options clicking on Other Options. For more information about the create options, see .
Click New. Archive Manager creates an empty archive, but does not yet write the archive to disk.
Archive Manager writes a new archive to disk only when the archive contains at least one file. If you create a new archive and quit Archive Manager before you add any files to the archive, Archive Manager deletes the archive.
Add files to the new archive as described in .
To create an archive, perform the following steps:
To Add Files to an Archive
Decide where in the archive you want to add the files, then open that location in the archive.
Choose EditAdd Files to display the Add Files dialog, or click Add Files in the toolbar.
Select the files that you want to add. To select more files press-and-hold Ctrl and click the files.
Click Add. Archive Manager adds the files to the current folder in the archive.
To add files to an archive, perform the following steps:
You cannot add folders to the archive with the Add Files dialog. To add a folder see .
The Add Files dialog provides the Add only if newer option, see for more information on this option.
You can also add files to an archive in a file manager window, without opening an Archive Manager window. See for more information.
The Add operation adds a copy of the specified files or folders to the archive. Archive Manager does not remove the original files, which remain unchanged in the file system. The copies that are added to the archive have the same permissions and modification date as the original files.
To Add a Folder to an Archive
Choose EditAdd a Folder to display the Add a Folder dialog.
Select the folder that you want to add.
Click Add. Archive Manager adds the folder to the current folder in the archive.
To add a folder to an archive, perform the following steps:
The Add a Folder dialog provides several advanced options. See for more information.
To Convert an Archive to Another Format
To convert an archive to another format and save as a new file, perform the following steps:
Open the archive that you want to convert.
Choose ArchiveSave As to display the Save dialog.
Enter the new archive name in the Name text box.
Select the new format from the Archive type drop-down list. Alternatively, enter the filename extension in the Name text box, and select Automatic from the Archive type drop-down list.
Click Save.
If some but not all of the files in the archive are protected by a password, and you have not specified the password, Archive Manager does not ask for a password. However, Archive Manager copies only the unprotected files to the new archive.
Modifying the Contents of an Archive
You can modify the contents of an archive in several ways.
To Encrypt Files in an Archive
For security, you might want to encrypt the files that you add to an archive.
If the archive format supports encryption, you can specify a password to encrypt the files that you add to the archive.
Currently, only 7-Zip, ZIP, RAR and ARJ archives support encryption.
To specify a password for file encryption, perform the following steps:
Choose EditPassword to display the Password dialog.
Enter the password in the Password text box.
Click OK.
Archive Manager uses the password to encrypt the files that you add to the current archive, and to decrypt the files that you extract from the current archive. Archive Manager deletes the password when you close the archive.
For information on how to check whether an archive contains encrypted files, see .
The encryption provided by archive utilities is weak and insecure. If security is important, use a strong encryption tool such as GNU Privacy Guard.
To Rename a File in an Archive
To rename a file in an archive, perform the following steps:
Select the file that you want to rename.
Choose EditRename, or press F2, to display the Rename dialog.
Enter the new filename in the New file name text box.
Click Rename.
To Copy Files in an Archive
To copy files in an archive, perform the following steps:
Select the files that you want to copy.
Choose EditCopy, or press CtrlC.
Open the location where you want to put the copied files.
Choose EditPaste, or press CtrlV.
To Move Files in an Archive
To move files in an archive, perform the following steps:
Select the files that you want to move.
Choose EditCut, or press CtrlX.
Open the location where you want to put the moved files.
To Delete Files From an Archive
To delete files from an archive, perform the following steps:
Select the files that you want to delete.
Choose EditDelete or press Delete to display the Delete dialog.
Select one of the following delete options:
Delete all files from the archive.
Selected files
Delete the selected files from the archive.
Files
Delete from the archive all files that match the specified pattern. See for more information about filename patterns.
To Modify a File in an Archive
Double-click the file that you want to open. Alternatively right-click the file and choose Open.
Edit the file opened in step 1, and then save your changes.
Archive Manager shows a confirmation dialog, asking confirmation to update the file in the archive with the changes you made.
Click on Update.
To modify a file in an archive perform the following steps:
Archive Manager uses the system-defined associations between file types and programs to determine the appropriate application to launch for a specific file. These assocations can be displayed and modified in the Open With tab of the file properties dialog. If Archive Manager cannot determine the appropriate application, Archive Manager displays the Open Files dialog to let you choose an application, as described in below.
To Modify a File in an Archive with a Custom Application
Right click the file.
Choose Open With....
You can use an application specified by you, rather than the default application, to modify a file. To use an external application to open a file:
Archive Manager displays the Open Files dialog, which lists all of the applications that can open files of the specified type. To select one of the applications, double-click the application name or click on the application name and then click Open. Alternatively, enter the application name in the Application text box and then click Open to launch the application of your choice.
Once the application starts follow the procedure from step 2 as described in .
Viewing Archives
Archive Manager enables you to view several aspects of an archive.
To View the Properties of an Archive
Name
The name of the archive.
Location
The position of the archive in the file system.
Modified on
The date and time at which the archive was last modified.
Archive size
The size of the archive contents when compressed.
Content size
The size of the archive contents when uncompressed. This information is also available in the statusbar.
Compression ratio
The compression ratio is a value used to describe the reduction in size of the data. For example a compression ratio of 5 means that the compressed archive is 1/5th the size of the original data.
Number of files
The number of files in the archive.
To view the properties of an archive, choose ArchiveProperties to display the Properties dialog. The Properties dialog displays the following information about the archive:
To View the Contents of an Archive
The name of a file or folder in the archive.
Size
The size of the file when the file is extracted from the archive. For a folder, the Size field is blank. For information on how to display the size of the compressed file, see .
Type
The type of the file. For a folder, the value in the Type field is Folder.
Date modified
The date on which the file was last modified. For a folder, the Date modified field is blank.
The path to the file within the archive. This column is visible only when the window is in file view, when in folder view the location of the files is displayed in the Location text box of the folderbar. For more information about view types see .
Archive Manager displays the archive contents in the main window as a file list with the following columns:
If another program has modified the archive since Archive Manager opened the archive, choose ViewReload to reload the archive contents from disk.
For information on how to customize the way that Archive Manager displays the archive contents, see .
For more advanced tasks, use an application installed on your system. For more information, see .
To View a File in an Archive
To view a file in an archive follow the steps described in . If you save the opened file, click Cancel when Archive Manager asks confirmation to update the file in the archive.
To Test the Integrity of an Archive
If the archive contains no errors, Archive Manager opens the Test Result dialog to list each file in the archive, and indicates that each file has status OK.
If the archive contains some error, Archive Manager opens the Test Result dialog displaying the part of the archive contains the error.
Sometimes an archive can be damaged for some reason, to check whether an archive is damaged, choose ArchiveTest Integrity:
A damaged archive can be impossible to extract, this can bring to a loss of data. For this reason you should test the archive integrity before deleting the original files.
If the archive contains encrypted files, Archive Manager asks the password of the archive before performing the test.
Not all the archive types support the integrity testing, the following is the list of archive types that can be tested for integrity: 7-Zip, RAR, ZIP, ACE, ARJ and Zoo.
Tip
To test the integrity of an archive that doesn't support the integrity testing, extract all the files from the archive and check that the operation is completed successfully.
Customizing the Archive Display
You can customize the way that Archive Manager displays the archive contents, as follows:
Switch between folder view and file view. For more information, see .
Specify the order in which to display files in the list. For more information, see .
Display additional details about the contents of the archive. For more information, see .
Archive Manager updates the display immediately, when you make any of the above customizations.
To Set the View Type
If the archive contains folders, you can show the archive contents in either folder view or file view.
Folder View
Archive Manager displays the archive contents in folder view by default. To explicitly select folder view, choose ViewView as a Folder.
In folder view, Archive Manager shows folders in the same way as a file manager shows folders. That is, Archive Manager indicates folders in the display area with a folder icon and the folder name. To view the contents of a folder, double-click on the folder name.
The folderbar, which Archive Manager displays only in folder view, contains the components described in the following table.
Component
Description
Shows icon to navigate backwards in location history list.
Click on this button to navigate backwards in the location history list.
Shows icon to navigate forwards in location history list.
Click on this button to navigate forwards in the location history list.
Shows icon to navigate up one level in folder tree.
Click on this button to navigate up one level in the folder tree.
Shows icon to open the top-level folder in the archive.
Click on this button to open the top-level folder in the archive.
This field shows the full pathname, within the archive, of the current folder.
To change to a different level in the folder tree, type the new location in the Location text box then press Return. Archive Manager displays the contents of the new location.
File View
To select file view, choose ViewView All Files.
In file view, Archive Manager displays all files in the archive, including files from subfolders, in a single list.
To Sort the File List
You can sort the file list by name, size, type, modification date, or location.
To specify a sort order, click on the heading of the corresponding column.
To reverse the sort order, click on the column heading again.
For example, to sort the file list by modification date, click on the Date modified heading. Archive Manager rearranges the file list to display the files by modification date, starting with the earliest. To display the latest files first, click on the Date modified heading again.
Archive Manager always performs a secondary sort based on the file name. In the above example, Archive Manager sorts by name any files that have the same modification date.
To Display Additional Details
If you tested the archive in the current Archive Manager session, the Last Output dialog displays the results of the last test.
If you did not test the archive in the current Archive Manager session, the Last Output dialog displays a list of all files in the archive, but does not indicate any status for the files. Instead, the Last Output dialog provides the compressed size of each file and the percentage of compression, and the date and time at which the file was last modified.
To open the Last Output dialog, choose ViewLast Output:
Using the File Manager to Work with an Archive
You can use the file manager to add files to an archive, or to extract files from an archive.
To Add Files to an Archive by Using the File Manager
Drag the files into a Archive Manager window from a file manager window.
Use the file manager popup menu to add the files to the archive.
You can use the file manager to add files to an archive, in the following ways:
To use the file manager popup menu to add files to an archive, perform the following steps:
Right-click on the files or folders in a file manager window.
Choose Create Archive from the file manager popup menu to display the Archive ManagerCreate Archive dialog.
Enter the archive name, without the file extension, in the Archive text box.
Choose the archive type from the drop-down list.
Choose the location where to save the archive file, from the Location drop-down list. If the location is not present in the list choose Other... to select it with the Location dialog.
Click Create to add the selected files to the root folder of the specified archive.
To select any of the advanced add options, you must invoke Archive Manager as described in .
To Extract Files From an Archive by Using the File Manager
Drag the files from a Archive Manager window into a file manager window.
Use the file manager popup menu to extract the files from the archive.
You can use the file manager to extract files from an archive, in the following ways:
To use the file manager popup menu to extract files from an archive, perform the following steps:
Right-click on the archive in a file manager window.
Choose Extract Here to extract all of the archive contents into the directory where the archive is located.
If the archive is encrypted, Archive Manager will ask to enter the password before extracting the files.
Create Options
When creating a new archive, or when converting an existing archive to another format, click on Other Options to specify the following advanced options:
Password
Type the password that will be used to encrypt the archive. If no password is specified the archive will not be encrypted.
Not all archive types support encryption. For more information about file encryption, see .
Encrypt the file list too
If this option is selected, the password will be requested even to view the list of files contained in the archive, otherwise it will be requested only to extract the files from the archive. This option is available only if a password is specified.
Split in volumes
Select this option to split the archive in more files of the specified dimension.
Only 7-Zip and RAR archives support this feature.
Add Options
The Add Files and Add a Folder dialogs provide the following option:
Add only if newer
Select this option to add the specified file to the archive only if the archive does not contain the specified file, or if the archive contains an older version of the specified file. Archive Manager uses the modification date to determine which file is the most recent. If the version of the file in the archive is the most recent, Archive Manager does not add the specified file to the archive.
If you do not select this option, Archive Manager adds the file to the archive and overwrites the previous archive contents.
Open the backup.tar.gz archive in Archive Manager.
Choose EditAdd to display the Add a Folder dialog.
Select your home folder.
Select the Add only if newer option.
Click Add.
If you use Archive Manager to create backups, the Add only if newer option is very useful. For example, the archive backup.tar.gz contains a week-old backup of your home folder. To update the archive to contain a current backup of your home folder, perform the following steps:
Archive Manager automatically adds to the archive all files that you created during the last week, and updates all files that you modified during the last week. However, Archive Manager does not remove from the archive the files that you deleted during the last week. The archive update operation is much faster than doing a full backup of your home folder.
Add to Folder Options
The following options are available in the Add a Folder dialog and allow to automatically select and add all files that satisfy certain criteria:
Include files
Type a filename pattern in this text box to include files with names that match the specified pattern. See for more information about filename patterns.
Exclude files
Type a filename pattern in this text box to exclude files with names that match the specified pattern. See for more information about filename patterns.
Exclude folders
Type a filename pattern in this text box to exclude folders with names that match the specified pattern. See for more information about filename patterns.
Include subfolders
Select this option to add all files that match the specified pattern, from the current folder and from subfolders.
The filename, not the subfolder name, must match the specified pattern.
If you do not select this option, Archive Manager adds the matching files from the current folder only.
Exclude folders that are symbolic links
Select this option to omit files from folders that are symbolic links. Symbolic links are pointers or shortcuts to other folders.
If you do not select this option, Archive Manager adds the matching files from folders that are symbolic links.
Save Options
Click on this button to save the current selection of advanced add options to a file. The Save Options dialog is displayed. Enter a descriptive filename in the Options Name text box, then click Save.
Load Options
Click on this button to load or delete a previously saved selection of advanced add options. The Load Options dialog is displayed.
To load a set of options, select the options file in the list box, then click Apply.
To delete a set of options, select the options file in the list box, then click Remove. Click Close to close the Load Options dialog.
Reset Options
Click on this button to reset the current selection of advanced add options to the default values.
Extract Options
The Extract dialog provides the following options, which are saved when you quit Archive Manager:
Extract
Select the files to be extracted:
Extract all files from the archive.
Extract the selected files from the archive.
Extract from the archive all files that match the specified pattern. See for more information about filename patterns.
Actions
Select the following extract options:
Re-create folders
Select this option to reconstruct the folder structure when extracting the specified files.
If you select the Re-create folders option, Archive Manager extracts the contents of the subfolder to /tmp/doc.
If you do not select the Re-create folders option, Archive Manager does not create any subfolders. Instead, Archive Manager extracts all files from the archive, including files from subfolders, to /tmp.
For example, you specify /tmp in the Filename text box and choose to extract all files. The archive contains a subfolder called doc.
Overwrite existing files
Select this option to overwrite any files in the destination folder that have the same name as the specified files.
If you do not select this option, Archive Manager does not extract the specified file if an existing file with the same name already exists in the destination folder.
Do not extract older files
This option is only effective while the Overwrite existing files option is selected.
Select the Do not extract older files option to extract the specified file only if the destination folder does not contain the specified file, or if the destination folder contains an older version of the specified file. Archive Manager uses the modification date to determine which file is the most recent. If the version of the file in the archive is older, Archive Manager does not extract the specified file to the destination folder.
If you do not select the Do not extract older files option while the Overwrite existing files option is selected, Archive Manager extracts the specified file from the archive and overwrites the previous contents of the destination folder.
translator-credits
File is not a valid .desktop file
Unrecognized desktop file Version '%s'
Starting %s
Application does not accept documents on command line
Unrecognized launch option: %d
Can't pass documents to this desktop element
Not a launchable item
Disable connection to session manager
Specify file containing saved configuration
FILE
Specify session management ID
ID
Session management options:
Show session management options
Archive Manager
Create and modify an archive
How to sort files
What criteria must be used to arrange files. Possible values: name, size, type, time, path.
Sort type
Whether to sort in ascending or descending direction. Possible values: ascending, descending.
List Mode
Use 'all-files' to view all the files in the archive in a single list, use 'as-folder' to navigate the archive as a folder.
Display type
Display the type column in the main window.
Display size
Display the size column in the main window.
Display time
Display the time column in the main window.
Display path
Display the path column in the main window.
Use mime icons
If true will display icons depending on the file type (slower), otherwise will use always the same icon for all files (faster).
Name column width
The default width of the name column the file list.
Max history length
Max number of items in the 'Open Recents' submenu.
View toolbar
Whether to display the toolbar.
View statusbar
Whether to display the statusbar.
View the folders pane
Whether to display the folders pane.
Editors
List of applications entered in the 'Open File' dialog and not associated with the file type.
Compression level
Compression level used when adding files to an archive. Possible values: very-fast, fast, normal, maximum.
Encrypt the archive header
Whether to encrypt the archive header. If the header is encrypted the password will be required to list the archive content as well.
Overwrite existing files
Do not overwrite newer files
Recreate the folders stored in the archive
Default volume size
The default size for volumes.
Load Options
Compress
_Filename:
_Location:
Location
_Password:
_Encrypt the file list too
Split into _volumes of
MB
_Other Options
C_reate
Password required
Delete
_Files:
example: *.txt; *.doc
_All files
_Selected files
Password
Note: the password will be used to encrypt files you add to the current archive, and to decrypt files you extract from the current archive. When the archive is closed the password will be deleted.
_Update
S_elect the files you want to update:
Extract Here
Extract the selected archive to the current position
Extract To...
Extract the selected archive
Compress...
Create a compressed archive with the selected objects
Could not create the archive
You have to specify an archive name.
You don't have permission to create an archive in this folder
Archive type not supported.
Could not delete the old archive.
Open
All archives
All files
Last Output
Copyright © 2001–2010 Free Software Foundation, Inc.
An archive manager for GNOME.
translator-credits
Could not add the files to the archive
You don't have the right permissions to read files from folder "%s"
Add Files
Add only if _newer
Add a Folder
_Include subfolders
Exclude folders that are symbolic lin_ks
example: *.o; *.bak
Include _files:
E_xclude files:
_Exclude folders:
_Load Options
Sa_ve Options
_Reset Options
Save Options
Options Name:
Enter the password for the archive '%s'.
The name "%s" is not valid because it cannot contain the characters: %s %s
Please use a different name.
You don't have the right permissions to create an archive in the destination folder.
Destination folder "%s" does not exist. Do you want to create it?
Create _Folder
Could not create the destination folder: %s.
Archive not created
The archive is already present. Do you want to overwrite it?
_Overwrite
Extraction not performed
You don't have the right permissions to extract archives in the folder "%s"
Extract
Actions
Re-crea_te folders
Over_write existing files
Do not e_xtract older files
New
Save
There was an internal error trying to search for applications:
There is no command installed for %s files. Do you want to search for a command to open this file?
Could not open this file type
_Search Command
Location:
Name:
%s Properties
Modified on:
Archive size:
Content size:
Compression ratio:
Number of files:
Update the file "%s" in the archive "%s"?
Update the files in the archive "%s"?
File _Format: %s
All Files
All Supported Files
By Extension
File Format
Extension(s)
The program was not able to find out the file format you want to use for `%s'. Please make sure to use a known extension for that file or manually choose a file format from the list below.
File format not recognized
File not found.
The file doesn't exist
You don't have the right permissions.
This archive type cannot be modified
You can't add an archive to itself.
Adding file:
Extracting file:
Removing file:
Could not find the volume: %s
Deleting files from archive
Recompressing archive
Decompressing archive
7-Zip (.7z)
Tar compressed with 7z (.tar.7z)
Ace (.ace)
Ar (.ar)
Arj (.arj)
Tar compressed with bzip2 (.tar.bz2)
Tar compressed with bzip (.tar.bz)
Cabinet (.cab)
Rar Archived Comic Book (.cbr)
Zip Archived Comic Book (.cbz)
Tar compressed with gzip (.tar.gz)
Ear (.ear)
Self-extracting zip (.exe)
Jar (.jar)
Lha (.lzh)
Lrzip (.lrz)
Tar compressed with lrzip (.tar.lrz)
Tar compressed with lzip (.tar.lz)
Tar compressed with lzma (.tar.lzma)
Tar compressed with lzop (.tar.lzo)
Windows Imaging Format (.wim)
Rar (.rar)
Tar uncompressed (.tar)
Tar compressed with compress (.tar.Z)
War (.war)
Xz (.xz)
Tar compressed with xz (.tar.xz)
Zoo (.zoo)
Zip (.zip)
_Add
_Extract
Folder
[read only]
Could not display the folder "%s"
Creating archive
Loading archive
Reading archive
Testing archive
Getting the file list
Copying the file list
Adding files to archive
Extracting files from archive
Saving archive
_Open the Archive
_Show the Files
Archive:
Extraction completed successfully
Archive created successfully
please wait...
Command exited abnormally.
An error occurred while extracting files.
Could not open "%s"
An error occurred while loading the archive.
An error occurred while deleting files from the archive.
An error occurred while adding files to the archive.
An error occurred while testing archive.
An error occurred while saving the archive.
An error occurred.
Command not found.
Test Result
Could not perform the operation
Do you want to add this file to the current archive or open it as a new archive?
Do you want to create a new archive with these files?
Create _Archive
Folders
Size
Type
Date Modified
Name
Find:
Close the folders pane
Open archive
Open a recently used archive
Could not save the archive "%s"
The new name is void.
The new name is equal to the old one.
A folder named "%s" already exists. %s
A file named "%s" already exists. %s
Rename
New folder name
New file name
_Rename
Could not rename the folder
Could not rename the file
Paste Selection
Destination folder
Add files to an archive
Extract archive
%d %B %Y, %H:%M
Command _Line Output
Could not display help
Add files to the specified archive and quit the program
ARCHIVE
Add files asking the name of the archive and quit the program
Extract archives to the specified folder and quit the program
FOLDER
Extract archives asking the destination folder and quit the program
Extract the contents of the archives in the archive folder and quit the program
Default folder to use for the '--add' and '--extract' commands
Create destination folder without asking confirmation
- Create and modify an archive
File Roller
_Archive
_Edit
_View
_Help
_Arrange Files
Open _Recent
Information about the program
_Add Files...
Add files to the archive
Add a _Folder...
Add a folder to the archive
Add Folder
Close the current archive
Contents
Display the File Roller Manual
Copy the selection
Cut the selection
Paste the clipboard
_Rename...
Rename the selection
Delete the selection from the archive
Dese_lect All
Deselect all files
_Extract...
Extract files from the archive
Find...
_Last Output
View the output produced by the last executed command
New...
Create a new archive
Open...
_Open With...
Open selected files with an application
Pass_word...
Specify a password for this archive
Show archive properties
Reload current archive
Save As...
Save the current archive with a different name
Select all files
Stop current operation
_Test Integrity
Test whether the archive contains errors
Open the selected file
Open the selected folder
Go to the previous visited location
Go to the next visited location
Go up one level
Go to the home location
_Toolbar
View the main toolbar
Stat_usbar
View the statusbar
_Reversed Order
Reverse the list order
_Folders
View All _Files
View as a F_older
by _Name
Sort file list by name
by _Size
Sort file list by file size
by T_ype
Sort file list by type
by _Date Modified
Sort file list by modification time
by _Location
Sort file list by location
Tomboy Applet Factory
Tomboy Notes
Simple and easy to use note-taking
Accessories
S_ynchronize Notes
_Preferences
_Help
_About
Take notes, link ideas, and stay organized
Note-taker
Enable spellchecking
If true, misspellings will be underlined in red, and correct spelling suggestions shown in the right-click menu.
Enable WikiWord highlighting
Enable this option to highlight words ThatLookLikeThis. Clicking the word will create a note with that name.
Enable automatic bulleted lists.
Enable this option if you want bulleted lists to be automatic when you place - or * at the beginning of a line.
Enable Middle-Click Paste On Icon.
Enable this option if you want to be able to middle-click the Tomboy icon to paste timestamped content into the Start Here note.
Enable custom font
If true, the font name set in custom_font_face will be used as the font when displaying notes. Otherwise the desktop default font will be used.
Custom Font Face
If enable_custom_font is true, the font name set here will be used as the font when displaying notes.
Enable global keybindings
If true, the desktop-global keybindings set in /apps/tomboy/global_keybindings will be enabled, allowing for useful Tomboy actions to be available from any application.
Enable the Delete Note confirmation dialog
If disabled, the "Delete Note" confirmation dialog will be suppressed.
Enable Tray Icon
If true, Tomboy's tray icon will be displayed in the notification area. Disabling this may be useful when another application is providing the functionality of the tray icon.
Start Here Note
The note URI of the note that should be considered the "Start Here" note, which is always placed at the bottom of the Tomboy note menu and also accessible by hotkey.
Minimum number of notes to show in menu
Integer determining the minimum number of notes to show in the Tomboy note menu.
List of pinned notes.
Whitespace-separated list of note URIs for notes that should always appear in the Tomboy note menu.
Maximum note title length to show in tray menu.
Maximum characters of note title to show in the Tomboy tray or panel applet note menu.
Enable startup notes
If enabled, all notes that were open when Tomboy quit will automatically be reopened at startup.
Show applet menu
The global keybinding for showing the Tomboy applet's menu. The format looks like "lt;Controlgt;a" or "lt;Shiftgt;lt;Altgt;F1". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as "lt;Ctlgt;" and "lt;Ctrlgt;". If you set the option to the special string "disabled", then there will be no keybinding for this action.
Open Start Here
The global keybinding for opening the "Start Here" note. The format looks like "lt;Controlgt;a" or "lt;Shiftgt;lt;Altgt;F1". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as "lt;Ctlgt;" and "lt;Ctrlgt;". If you set the option to the special string "disabled", then there will be no keybinding for this action.
Create a new Note
The global keybinding for creating and displaying a new Note. The format looks like "lt;Controlgt;a" or "lt;Shiftgt;lt;Altgt;F1". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as "lt;Ctlgt;" and "lt;Ctrlgt;". If you set the option to the special string "disabled", then there will be no keybinding for this action.
Open Search Dialog
The global keybinding for opening the Note Search dialog. The format looks like "lt;Controlgt;a" or "lt;Shiftgt;lt;Altgt;F1". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as "lt;Ctlgt;" and "lt;Ctrlgt;". If you set the option to the special string "disabled", then there will be no keybinding for this action.
Open Recent Changes
The global keybinding for opening the Recent Changes dialog. The format looks like "lt;Controlgt;a" or "lt;Shiftgt;lt;Altgt;F1". The parser is fairly liberal and allows lower or upper case, and also abbreviations such as "lt;Ctlgt;" and "lt;Ctrlgt;". If you set the option to the special string "disabled", then there will be no keybinding for this action.
Saved height of "Search All Notes" window
Determines pixel height of "Search All Notes" window; stored on Tomboy exit.
Saved width of "Search All Notes" window
Determines pixel width of "Search All Notes" window; stored on Tomboy exit.
Saved horizontal position of "Search All Notes" window
Determines X coordinate of "Search All Notes" window; stored on Tomboy exit.
Saved vertical position of "Search All Notes" window
Determines Y coordinate of "Search All Notes" window; stored on Tomboy exit.
Last Directory used in HTML Export
The last directory a note was exported to using the Export To HTML plugin.
HTML Export Linked Notes
The last setting for the 'Export linked notes' checkbox in the Export to HTML plugin.
HTML Export All Linked Notes
The last setting for the 'Include all other linked notes' checkbox in the Export to HTML plugin. This setting is used in conjunction with the 'HTML Export Linked Notes' setting and is used to specify whether all notes (found recursively) should be included during an export to HTML.
Sticky Note Importer First Run
Indicates that the Sticky Note Importer plugin has not been run, so it should run automatically the next time Tomboy starts.
Synchronization Client ID
Unique identifier for this Tomboy client, used when communicating with a sychronization server.
Synchronization Local Server Path
Path to the synchronization server when using the filesystem synchronization service addin.
Selected Synchronization Service Addin
Unique identifier for the currently configured note synchronization service addin.
FUSE Mounting Timeout (ms)
Time (in milliseconds) Tomboy should wait for a response when using FUSE to mount a sync share.
SSHFS Remote Synchronization Folder
Path on SSH server to Tomboy synchronization directory (optional).
SSHFS Synchronization Server URL
URL of SSH server containing Tomboy synchronization directory.
SSHFS Remote Synchronization User Name
User name to use when connecting to the synchronization server via SSH.
SSHFS Synchronization Server Port
The port to use when connecting to the synchronization server via SSH. Set to -1 or less if default SSH port settings should be used instead.
Accept SSL Certificates
Use wdfs option "-ac" to accept SSL certificates without prompting the user.
Note Synchronization Conflict Saved Behavior
Integer value indicating if there is a preference to always perform a specific behavior when a conflict is detected, instead of prompting the user. The values map to an internal enumeration. 0 indicates that the user wishes to be prompted when a conflict occurs, so that they may handle each conflict situation on a case-by-case basis.
Automatic Background Synchronization Timeout
Integer value indicating how frequently to perform a background sync of your notes (when sync is configured). Any value less than 1 indicates that autosync is disabled. The lowest acceptable positive value is 5. Value is in minutes.
Link Updating Behavior on Note Rename
Integer value indicating if there is a preference to always perform a specific link updating behavior when a note is renamed, instead of prompting the user. The values map to an internal enumeration. 0 indicates that the user wishes to be prompted when renaming a note may impact links that exist in other notes. 1 indicates that links should automatically be removed. 2 indicates that link text should be updated to the new note name so that it will continue linking to the renamed note.
Timestamp format
The date format that is used for the timestamp.
Enable closing notes with escape.
If enabled, an opened note can be closed by hitting the escape key.
The handler for "note://" URLs
Set to TRUE to activate
_File
_New
Create a new note
_Open...
Open the selected note
_Delete
Delete the selected note
_Close
Close this window
_Quit
Quit Tomboy
_Edit
Tomboy Preferences
_Contents
Tomboy Help
About Tomboy
TrayIcon
Create _New Note
_Search All Notes
Open the Search All Notes window
Start synchronizing notes
Advanced
Minimum number of notes to show in Recent list (maximum 18)
What links here?
(none)
You can use any bugzilla just by dragging links into notes. If you want a special icon for certain hosts, add them here.
Host Name
Icon
Select an icon...
_Host name:
No host name specified
You must specify the Bugzilla host name to use with this icon.
Error saving icon
Could not save the icon file.
Really remove this icon?
If you remove an icon it is permanently lost.
Cannot open email
HTML
Destination for HTML Export
Export linked notes
Include all other linked notes
Export to HTML
Your note was exported to "{0}".
Note exported successfully
Access denied.
Folder does not exist.
Could not save the file "{0}"
_Folder Path:
Select Synchronization Folder...
Folder path field is empty.
Specified folder path does not exist, and Tomboy was unable to create it.
Local Folder
Fixed Wid_th
Cannot contact '{0}'
Error running gaim-remote: {0}
Insert Timestamp
dddd, MMMM d, h:mm tt
Choose one of the predefined formats or use your own.
Use _Selected Format
_Use Custom Format
Today: Template
Today:
dddd, MMMM d yyyy
Tasks
Appointments
Change the Today: Template note to customize the text that new Today notes have.
_Open Today: Template
Print
Error printing note
Page {0} of {1}
dddd MM/dd/yyyy, hh:mm:ss tt
Remove broken links
_Tools
_Remove broken links
Add a sketch
Se_rver:
User_name:
_Folder Path (optional):
SSH synchronization requires an existing SSH key for this server and user, added to a running SSH daemon.
Server or username field is empty.
SSH
Timeout connecting to server. Please ensure that your SSH key has been added to a running SSH daemon.
Import from Sticky Notes
No Sticky Notes found
No suitable Sticky Notes file was found at "{0}".
Sticky Notes import completed
Untitled
Sticky Note:
Tasque
All
--- Tasque is not running ---
_Underline
_URL:
_Password:
URL, username, or password field is empty.
WebDAV
There was an error connecting to the server. This may be caused by using an incorrect user name and/or password.
Saving configuration to the GNOME keyring failed with the following message:
Connect to Server
Connected
Server not responding. Try again later.
Authorization Failed, Try Again
Tomboy Web Authorization Successful
Please return to the Tomboy Preferences window and press Save to start synchronizing.
Connected. Press Save to start synchronizing
Authorizing in browser (Press to reset connection)
Set the default browser and try again
Tomboy Web
Export All Notes to {0}
Start exporting notes to {0}
Export selected notebook to {0}
Start exporting notebook to {0}
Export
Export your notes.
Export All Notes To {0}
Export Selected Notebook To {0}
Could not export, access denied.
Could not export, folder does not exist.
Could not export, error with the path. (No ending "?)
Could not export: {0}
All Notes {0} Export
Unknown error.
Unfiled Notes
Your notes were exported to "{0}".
Notes exported successfully
Could not save the files in "{0}"
Create destination folder for {0} export
Search All Notes
Create New Note
{0} (new)
Recent Notes
_Window
Preferences...
Create a new notebook
Type the name of the notebook you'd like to create.
N_otebook name:
Name already taken
C_reate
Note_books
Create a new note in a notebook
New Note_book...
_New Note
Create a new note in this notebook
_Open Template Note
Open this notebook's template note
Delete Note_book
Delete the selected notebook
Notebooks
{0} Notebook Template
New Note
All Notes
Really delete this notebook?
The notes that belong to this notebook will not be deleted, but they will no longer be associated with this notebook. This action cannot be undone.
No notebook
New "{0}" Note
Place this note into a notebook
Notebook
_New notebook...
New Note {0}
Really delete "{0}"?
If you delete a note it is permanently lost.
An error occurred while saving your notes. Please check that you have sufficient disk space, and that you have appropriate rights on {0}. Error details can be found in {1}.
Error saving note data.
New Note Template
Your Notes Have Moved!
In the latest version of Tomboy, your note files have moved. You have probably never cared where your notes are stored, and if you still don't care, please go ahead and delete this note. :-) Your old note directory is still safe and sound at {0} . If you go back to an older version of Tomboy, it will look for notes there. But we've copied your notes and configuration info into new directories, which will be used from now on: Notes can now be found at {1} Configuration is at {2} You can install add-ins at {3} Log files can be found at {4} Ciao!
Start Here Welcome to Tomboy! Use this "Start Here" note to begin organizing your ideas and thoughts. You can create new notes to hold your ideas by selecting the "Create New Note" item from the Tomboy Notes menu in your GNOME Panel. Your note will be saved automatically. Then organize the notes you create by linking related notes and ideas together! We've created a note called Using Links in Tomboy. Notice how each time we type Using Links in Tomboy it automatically gets underlined? Click on the link to open the note.
Using Links in Tomboy Notes in Tomboy can be linked together by highlighting text in the current note and clicking the Link button above in the toolbar. Doing so will create a new note and also underline the note's title in the current note. Changing the title of a note will update links present in other notes. This prevents broken links from occurring when a note is renamed. Also, if you type the name of another note in your current note, it will automatically be linked for you.
Start Here
Using Links in Tomboy
Describe your new note here.
Rename Note Links?
_Rename Links
_Don't Rename Links
Rename links in other notes from "{0}" to "{1}"? If you do not rename the links, they will no longer link to anything.
Rename Links
Note Title
Select All
Select None
Ad_vanced
Always show this _window
Never rename _links
Alwa_ys rename links
Find in This Note
_Link to New Note
Te_xt
_Find in This Note
Clos_e All Notes
Search
Search your notes
Link
Link selected text to a new note
_Text
Set properties of text
T_ools
Use tools on this note
Delete this note
Synchronize Notes
This note is a template note. It determines the default content of regular notes, and will not show up in the note menu or search window.
Convert to regular note
Save Si_ze
Save Se_lection
Save _Title
_Find...
Find _Next
Find _Previous
Cannot create note
_Find:
_Previous
_Next
{0} of {1}
_Bold
_Italic
_Strikeout
_Highlight
Font Size
_Normal
Hu_ge
_Large
S_mall
Increase Font Size
Decrease Font Size
Bullets
Editing
Hotkeys
Synchronization
Add-ins
_Spell check while typing
Misspellings will be underlined in red, with correct spelling suggestions shown in the context menu.
Highlight _WikiWords
Enable this option to highlight words ThatLookLikeThis. Clicking the word will create a note with that name.
Enable auto-_bulleted lists
Use custom _font
When renaming a linked note:
Ask me what to do
Never rename links
Always rename links
Use the new note template to specify the text that should be used when creating a new note.
Open New Note Template
Listen for _Hotkeys
Hotkeys allow you to quickly access your notes from anywhere with a keypress. Example Hotkeys: lt;Controlgt;lt;Shiftgt;F11, lt;Altgt;N
Show notes _menu
Open "_Start Here"
Create _new note
Open "Search _All Notes"
Ser_vice:
Not configurable
Automaticall_y Sync in Background Every
Minutes
_Advanced...
The following add-ins are installed
Get More Add-Ins...
_Enable
_Disable
Not Implemented
{0} Preferences
Choose Note Font
Other Synchronization Options
When a conflict is detected between a local note and a note on the configured synchronization server:
Always ask me what to do.
Rename my local note.
Replace my local note with the server's update.
Are you sure?
Clearing your synchronization settings is not recommended. You may be forced to synchronize all of your notes again when you save new settings.
Resetting Synchronization Settings
You have disabled the configured synchronization service. Your synchronization settings will now be cleared. You may be forced to synchronize all of your notes again when you save new settings.
Connection successful
Tomboy is ready to synchronize your notes. Would you like to synchronize them now?
Please check your information and try again. The log file {0} may contain more information about the error.
Error connecting
Version:
Author:
Copyright:
Add-in Dependencies:
_Search:
Note
Last Changed
Matches
Title match
No results found in the selected notebook. Click here to search across all notes.
Click here to search across all notebooks
Notes
This synchronization addin is not supported on your computer. Please make sure you have FUSE and {0} correctly installed and configured
Could not read testfile.
Write test failed.
Timeout connecting to server.
Error connecting to server.
FUSE could not be enabled.
An error ocurred while connecting to the specified server:
Details
Status
Acquiring sync lock...
Committing changes...
Synchronizing Notes
Synchronizing your notes...
This may take a while, kick back and enjoy!
Connecting to the server...
Deleting notes off of the server...
Downloading new/updated notes...
Server Locked
Server is locked
One of your other computers is currently synchronizing. Please wait 2 minutes and try again.
Preparing to download updates from server...
Preparing to upload updates to server...
Uploading notes to server...
Synchronization Failed
Failed to synchronize
Could not synchronize notes. Check the details below and try again.
Synchronization Complete
Synchronization is complete
Your notes are now up to date.
Synchronization Canceled
Synchronization was canceled
You canceled the synchronization. You may close the window now.
Synchronization Not Configured
Synchronization is not configured
Please configure synchronization in the preferences dialog.
Synchronization Service Error
Service error
Error connecting to the synchronization service. Please try again.
Deleted locally
Deleted from server
Updated
Added
Uploaded changes to server
Uploaded new note to server
Note Conflict
(old)
Rename local note:
Update links in referencing notes
Overwrite local note
Always perform this action
Note conflict detected
The server version of "{0}" conflicts with your local note. What do you want to do with your local note?
Could not enable FUSE
The FUSE module could not be loaded. Please check that it is installed properly and try again.
Enable FUSE?
The synchronization you've chosen requires the FUSE module to be loaded. To avoid getting this prompt in the future, you should load FUSE at startup. Add "modprobe fuse" to /etc/init.d/boot.local or "fuse" to /etc/modules.
Cannot create new note
Primary Development:
Contributors:
translator-credits
Copyright © 2004-2007 Alex Graveley Copyright © 2004-2011 Others
A simple and easy to use desktop note-taking application.
Homepage
Tomboy: A simple, easy to use desktop note-taking application. Copyright © 2004-2007 Alex Graveley <alex\@beatniksoftware\.com> Copyright © 2004-2011 Others
Usage: --version\t\t\tPrint version information. --help\t\t\tPrint this usage message. --note-path [path]\t\tLoad/store note data in this directory. --search [text]\t\tOpen the search all notes window with the search text.
--new-note\t\t\tCreate and display a new note. --new-note [title]\t\tCreate and display a new note, with a title. --open-note [title/url]\tDisplay the existing note matching title. --start-here\t\t\tDisplay the 'Start Here' note. --highlight-search [text]\tSearch and highlight text in the opened note.
--addin:html-export-all [path]\tExports all notes to HTML in the given location. --addin:html-export-all-quit [path]\tExports all notes to HTML in the given location and then quits.
Version {0}
(new)
_About Tomboy
The "Tomboy Notes Manual" could not be found. Please verify that your installation has been completed successfully.
Help not found
Cannot open location
Today, {0}
Today
Yesterday, {0}
Yesterday
Tomorrow, {0}
Tomorrow
MMMM d, h:mm tt
MMMM d
No Date
MMMM d yyyy, h:mm tt
MMMM d yyyy
(Untitled {0})
A note with the title {0} already exists. Please choose another name for this note before continuing.
Note title taken
_Copy Link Address
_Open Link
System events
Log in
Log out
Informational message
Warning message
Error message
Question dialog
Miscellaneous message
Default Background
User interface events
Click on command button
Choose menu item
Select check box
Cannot find a terminal, using xterm, even if it may not work
GNOME GConf Support
Unable to find the GNOME_FILE_DOMAIN_APP_HELP domain
Unable to find the GNOME_FILE_DOMAIN_HELP domain.
Unable to show help as %s is not a directory. Please check your installation.
Unable to find help paths %s or %s. Please check your installation
Unable to find the help files in either %s or %s. Please check your installation
Unable to find doc_id %s in the help path
Help document %s/%s not found
Bonobo Support
Bonobo activation Support
Could not create per-user gnome configuration directory `%s': %s
Could not stat private per-user gnome configuration directory `%s': %s
Could not set mode 0700 on private per-user gnome configuration directory `%s': %s
Could not create gnome accelerators directory `%s': %s
GNOME Virtual Filesystem
Disable sound server usage
Enable sound server usage
Host:port on which the sound server to use is running
HOSTNAME:PORT
GNOME Library
Show GNOME options
Popt Table
The table of options for popt
Popt Flags
The flags to use for popt
Popt Context
The popt context pointer that GnomeProgram is using
GOption Context
The goption context pointer that GnomeProgram is using
Human readable name
Human readable name of this application
GNOME path
Path in which to look for installed files
App ID
ID string to use for this application
App version
Version of this application
GNOME Prefix
Prefix where GNOME was installed
GNOME Libdir
Library prefix where GNOME was installed
GNOME Datadir
Data prefix where GNOME was installed
GNOME Sysconfdir
Configuration prefix where GNOME was installed
GNOME App Prefix
Prefix where this application was installed
GNOME App Libdir
Library prefix where this application was installed
GNOME App Datadir
Data prefix where this application was installed
GNOME App Sysconfdir
Configuration prefix where this application was installed
Create Directories
Create standard GNOME directories on startup
Enable Sound
Enable sound on startup
Espeaker
How to connect to esd
Help options
Application options
Dynamic modules to load
MODULE1,MODULE2,...
%s Run '%s --help' to see a full list of available command line options.
Unknown internal error while displaying this location.
The specified location is invalid.
There was an error parsing the default action command associated with this location.
There was an error launching the default action command associated with this location.
There is no default action associated with this location.
The default action does not support this protocol.
The request was cancelled.
The host "%s" could not be found.
The host could not be found.
The location or file could not be found.
The login has failed.
Error showing url: %s
Extra Moniker factory
GConf moniker
config indirect moniker
Unknown type
Key %s not found in configuration
minimum interval in milliseconds
Ignore multiple presses of the _same_ key within @delay milliseconds.
Pixels per seconds
How many pixels per second to move at the maximum speed.
How long to accelerate in milliseconds
How many milliseconds it takes to go from 0 to maximum speed.
Initial delay in milliseconds
How many milliseconds to wait before mouse movement keys start to operate.
Minimum interval in milliseconds
Do not accept a key as being pressed unless held for @delay milliseconds.
Disable if two keys are pressed at the same time.
Beep when a modifier is pressed.
Startup Assistive Technology Applications
List of assistive technology applications to start when logging into the GNOME desktop.
Preferred Mobility assistive technology application
Preferred Mobility assistive technology application to be used for login, menu, or command line.
Start preferred Mobility assistive technology application
GNOME to start preferred Mobility assistive technology application during login.
Preferred Visual assistive technology application
Preferred Visual assistive technology application be used for login, menu, or command line.
Start preferred Visual assistive technology application
GNOME to start preferred Visual assistive technology application during login.
Default browser
Default browser for all URLs.
Browser needs terminal
Whether the default browser needs a terminal to run.
Browser understands remote
Whether the default browser understands netscape remote.
Default calendar
Default calendar application
Calendar needs terminal
Whether the default calendar application needs a terminal to run
Default tasks
Default tasks application
Tasks needs terminal
Whether the default tasks application needs a terminal to run
Terminal application
Terminal program to use when starting applications that require one.
Exec Arguments
Argument used to execute programs in the terminal defined by the 'exec' key.
Fallback window manager (deprecated)
Fallback window manager if user window manager can't be found. This key has been deprecated since GNOME 2.12.
User window manager (deprecated)
Window manager to try first. This key has been deprecated since GNOME 2.12.
The number of workspaces (deprecated)
The number of workspaces the window manager should use This key has been deprecated since GNOME 2.12.
Names of the workspaces (deprecated)
A list with names of the first window manager workspaces. This key has been deprecated since GNOME 2.12.
Draw Desktop Background
Have GNOME draw the desktop background.
Picture Options
Determines how the image set by wallpaper_filename is rendered. Possible values are "none", "wallpaper", "centered", "scaled", "stretched", "zoom", "spanned".
Picture Filename
File to use for the background image.
Picture Opacity
Opacity with which to draw the background picture.
Primary Color
Left or Top color when drawing gradients, or the solid color.
Secondary Color
Right or Bottom color when drawing gradients, not used for solid color.
Color Shading Type
How to shade the background color. Possible values are "horizontal-gradient", "vertical-gradient", and "solid".
File Icon Theme
Theme used for displaying file icons.
Enable Accessibility
Whether Applications should have accessibility support.
Enable Animations
Whether animations should be displayed. Note: This is a global key, it changes the behaviour of the window manager, the panel etc.
Menus Have Tearoff
Whether menus should have a tearoff.
Can Change Accels
Whether the user can dynamically type a new accelerator when positioned over an active menuitem.
Toolbar Style
Toolbar Style. Valid values are "both", "both-horiz", "icons", and "text".
Menus Have Icons
Whether menus may display an icon next to a menu entry.
Buttons Have Icons
Whether buttons may display an icon in addition to the button text.
Menubar Detachable
Whether the user can detach menubars and move them around.
Toolbar Detachable
Whether the user can detach toolbars and move them around.
Toolbar Icon Size
Size of icons in toolbars, either "small-toolbar" or "large-toolbar".
Cursor Blink
Whether the cursor should blink.
Cursor Blink Time
Length of the cursor blink cycle, in milliseconds.
Icon Theme
Icon theme to use for the panel, nautilus etc.
Gtk+ Theme
Basename of the default theme used by gtk+.
Default font
Name of the default font used by gtk+.
GTK IM Preedit Style
Name of the GTK+ input method Preedit Style used by gtk+.
GTK IM Status Style
Name of the GTK+ input method Status Style used by gtk+.
GTK IM Module
Name of the input method module used by GTK+.
Document font
Name of the default font used for reading documents.
Monospace font
Name of a monospaced (fixed-width) font for use in locations like terminals.
Use Custom Font
Whether to use a custom font in gtk+ applications.
Status Bar on Right
Whether to display a status bar meter on the right.
Module for GtkFileChooser
Module to use as the filesystem model for the GtkFileChooser widget. Possible values are "gio", "gnome-vfs" and "gtk+".
Menubar accelerator
Keyboard shortcut to open the menu bars.
Show the 'Input Methods' menu
Whether the context menus of entries and text views should offer to change the input method.
Show the 'Unicode Control Character' menu
Whether the context menus of entries and text views should offer to insert control characters.
Disable command line
Prevent the user from accessing the terminal or specifying a command line to be executed. For example, this would disable access to the panel's "Run Application" dialog.
Disable saving files to disk
Prevent the user from saving files to disk. For example, this would disable access to all applications' "Save as" dialogs.
Disable printing
Prevent the user from printing. For example, this would disable access to all applications' "Print" dialogs.
Disable print setup
Prevent the user from modifying print settings. For example, this would disable access to all applications' "Print Setup" dialogs.
Disable user switching
Prevent the user from switching to another account while his session is active.
Disable lock screen
Prevent the user to lock his screen.
Disable URL and MIME type handlers
Prevent running any URL or MIME type handler applications.
possible values are "on", "off", and "custom".
Keyboard Bell Custom Filename
File name of the bell sound to be played.
Remember NumLock state
When set to true, GNOME will remember the state of the NumLock LED between sessions.
Mouse button orientation
Swap left and right mouse buttons for left-handed mice.
Single Click
Single click to open icons.
Acceleration multiplier for mouse motion. A value of -1 is the system default.
Motion Threshold
Distance in pixels the pointer must move before accelerated mouse motion is activated. A value of -1 is the system default.
Drag Threshold
Distance before a drag is started.
Double Click Time
Length of a double click.
Locate Pointer
Highlights the current location of the pointer when the Control key is pressed and released.
Cursor font
Font name of the cursor. If unset, the default font is used. This value is only propagated to the X server start of each session, so changing it mid-session won't have an effect until the next time you log in.
Cursor theme
Cursor theme name. Used only by Xservers that support Xcursor, such as XFree86 4.3 and later.
Cursor size
Size of the cursor referenced by cursor_theme.
Default mixer device
The default mixer device used by the multimedia key bindings.
Default mixer tracks
The default mixer tracks used by the multimedia key bindings.
Enable ESD
Enable sound server startup.
Sounds for events
Whether to play sounds on user events.
Sound theme name
The XDG sound theme to use for event sounds.
Input feedback sounds
Whether to play sounds on input events.
Maximum age for thumbnails in the cache, in days. Set to -1 to disable cleaning.
Maximum size of the thumbnail cache, in megabytes. Set to -1 to disable cleaning.
Disable all external thumbnailers
Set to true to disable all external thumbnailer programs, independent on whether they are independently disabled/enabled.
Type time
Number of minutes of typing time before break mode starts.
Break time
Number of minutes that the typing break should last.
Allow postponing of breaks
Whether or not the typing break screen can be postponed.
Whether or not keyboard locking is enabled
Whether or not keyboard locking is enabled.
Prompt the user before completing a connection
If true, remote users accessing the desktop are not allowed access until the user on the host machine approves the connection. Recommended especially when access is not password protected.
Only allow remote users to view the desktop
If true, remote users accessing the desktop are only allowed to view the desktop. Remote users will not be able to use the mouse or keyboard.
Network interface for listening
If not set, the server will listen on all network interfaces. Set this if you want to accept connections only from some specific network interface. For example, eth0, wifi0, lo and so on.
Listen on an alternative port
If true, the server will listen on another port, instead of the default (5900). The port must be specified in the 'alternative-port' key.
Alternative port number
The port which the server will listen to if the 'use-alternative-port' key is set to true. Valid values are in the range of 5000 to 50000.
Require encryption
If true, remote users accessing the desktop are required to support encryption. It is highly recommended that you use a client which supports encryption unless the intervening network is trusted.
Allowed authentication methods
Lists the authentication methods with which remote users may access the desktop. There are two possible authentication methods; "vnc" causes the remote user to be prompted for a password (the password is specified by the vnc-password key) before connecting and "none" which allows any remote user to connect.
Password required for "vnc" authentication
The password which the remote user will be prompted for if the "vnc" authentication method is used. The password specified by the key is base64 encoded. The special value of 'keyring' (which is not valid base64) means that the password is stored in the GNOME keyring.
E-mail address to which the remote desktop URL should be sent
This key specifies the e-mail address to which the remote desktop URL should be sent if the user clicks on the URL in the Desktop Sharing preferences dialog.
Lock the screen when last user disconnect
If true, the screen will be locked after the last remote client disconnects.
When the status icon should be shown
This key controls the behavior of the status icon. There are three options: "always" - the icon will always be present; "client" - the icon will only be present when someone is connected (this is the default behavior); "never" - the icon will not be present.
Whether to disable the desktop background when a user is connected
When true, disable the desktop background and replace it with a single block of color when a user successfully connects.
Whether a UPnP router should be used to forward and open ports
If true, request that a UPnP-capable router should forward and open the port used by Vino.
Whether we should disable the XDamage extension of X.org
If true, do not use the XDamage extension of X.org. This extension does not work properly on some video drivers when using 3D effects. Disabling it will make Vino work in these environments, with slower rendering as a side effect.
Notify on connect
If true, show a notification when a user connects to the system.
File is not a valid .desktop file
Unrecognized desktop file Version '%s'
Starting %s
Application does not accept documents on command line
Unrecognized launch option: %d
Can't pass document URIs to a 'Type=Link' desktop entry
Not a launchable item
Disable connection to session manager
Specify file containing saved configuration
FILE
Specify session management ID
ID
Session management options:
Show session management options
Your XServer does not support the XTest extension - remote desktop access will be view-only
Start in tube mode, for the ‘Share my Desktop’ feature
- VNC Server for GNOME
Run 'vino-server --help' to see a full list of available command line options
GNOME Desktop Sharing
vino-mdns:showusername
%s's remote desktop on %s
Received signal %d, exiting.
Screen
The screen on which to display the prompt
Error initializing libnotify
A user on the computer '%s' is trying to remotely view or control your desktop.
Another user is trying to view your desktop.
Refuse
Accept
Failed to open connection to bus: %s
Desktop Sharing
GNOME Desktop Sharing Server
vnc;share;remote;
Desktop sharing is enabled
Error displaying preferences
Error displaying help
Licensed under the GNU General Public License Version 2 Vino is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. Vino is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
translator-credits
Share your desktop with other users
Are you sure you want to disconnect '%s'?
The remote user from '%s' will be disconnected. Are you sure?
Are you sure you want to disconnect all clients?
All remote users will be disconnected. Are you sure?
Disconnect
_Preferences
Disconnect all
Disconnect %s
_Help
_About
Another user is viewing your desktop
A user on the computer '%s' is remotely viewing your desktop.
Another user is controlling your desktop
A user on the computer '%s' is remotely controlling your desktop.
Error while displaying notification bubble: %s
The remote user '%s' will be disconnected. Are you sure?
Share my desktop information
'%s' rejected the desktop sharing invitation.
'%s' disconnected
'%s' is remotely controlling your desktop.
Waiting for '%s' to connect to the screen.
_Allow
_Refuse
An error has occurred:
There was an error showing the URL "%s"
There was an error displaying help: %s
Checking the connectivity of this machine...
Your desktop is only reachable over the local network.
or
Others can access your computer using the address %s.
Nobody can access your desktop.
Choose how other users can remotely view your desktop
Desktop Sharing Preferences
Sharing
Some of these preferences are locked down
Allow other users to _view your desktop
Your desktop will be shared
_Allow other users to control your desktop
Remote users are able to control your mouse and keyboard
Security
_You must confirm each access to this machine
_Require the user to enter this password:
Automatically _configure UPnP router to open and forward ports
The router must have the UPnP feature enabled
Show Notification Area Icon
Al_ways
_Only when someone is connected
_Never
Enable remote access to the desktop
If true, allows remote access to the desktop via the RFB protocol. Users on remote machines may then connect to the desktop using a VNC viewer.
Remote desktop sharing password
Cancelled
Changing Vino password.
Enter new Vino password:
Retype new Vino password:
vino-passwd: password updated successfully.
Sorry, passwords do not match.
vino-passwd: password unchanged.
Show Vino version
- Updates Vino password
Run 'vino-passwd --help' to see a full list of available command line options
VINO Version %s
ERROR: You do not have enough permissions to change Vino password.
A user on another computer is trying to remotely view or control your desktop.
Do you want to allow them to do so?
GParted is a free partition editor for graphically managing your disk partitions.
With GParted you can resize, copy, label, and move partitions without data loss. These actions enable you to grow or shrink your C: drive, create space for new operating systems, or attempt data rescue from lost partitions.
GParted works with many file systems including: btrfs, ext2, ext3, ext4, fat16, fat32, hfs, hfs+, linux-swap, lvm2 pv, nilfs2, ntfs, reiserfs, reiser4, ufs, and xfs.
GParted
Partition Editor
GParted Partition Editor
Create, reorganize, and delete partitions
(New UUID - will be randomly generated)
(Half new UUID - will be randomly generated)
%1 of %2 copied (%3 remaining)
%1 of %2 copied
copy %1 using a block size of %2
Operation Canceled
Error while writing block at sector %1
Error while reading block at sector %1
Free space preceding (MiB):
New size (MiB):
Free space following (MiB):
Align to:
Cylinder
MiB
None
Resize
Resize/Move
Minimum size: %1 MiB
Maximum size: %1 MiB
Create partition table on %1
WARNING: This will ERASE ALL DATA on the ENTIRE DISK %1
Select new partition table type:
Paste %1
Information about %1
Warning:
File System
File system:
Label:
UUID:
Status:
Busy (At least one logical partition is mounted)
Active
Mounted on %1
Not busy (There are no mounted logical partitions)
Not active
Not active (Not a member of any volume group)
Not active and exported
Not mounted
Volume Group:
Members:
Used:
Unused:
Unallocated:
Size:
Partition
Path:
Flags:
First sector:
Last sector:
Total sectors:
Set partition label on %1
Create new Partition
Create as:
Primary Partition
Logical Partition
Extended Partition
New Partition #%1
Resize/Move %1
Resize %1
Applying pending operations
Depending on the number and type of operations this might take a long time.
Completed Operations:
Details
%1 of %2 operations completed
_Save Details
Operation cancelled
All operations successfully completed
An error occurred while applying the operations
See the details for more information.
IMPORTANT
If you want support, you need to provide the saved details!
See %1 for more information.
Force Cancel (%1)
Force Cancel
Are you sure you want to cancel the current operation?
Canceling an operation might cause SEVERE file system damage.
Continue Operation
Cancel Operation
Save Details
GParted Details
Libparted
EXECUTING
SUCCESS
ERROR
INFO
N/A
File System Support
Create
Grow
Shrink
Move
Copy
Check
Label
UUID
Required Software
This chart shows the actions supported on file systems.
Not all actions are available on all file systems, in part due to the nature of file systems and limitations in the required software.
Available offline and online
Available offline only
Not Available
Legend
Rescan For Supported Actions
Manage flags on %1
Search disk for file systems
File systems found on %1
Data found
Data found with inconsistencies
WARNING!: The file systems marked with (!) are inconsistent.
You might encounter errors trying to view these file systems.
The 'View' buttons create read-only views of each file system.
All mounted views will be unmounted when you close this dialog.
File systems
#%1: %2 (%3 MiB)
View
An error occurred while creating a temporary directory for use as a mount point.
Error
Failed creating temporary directory
An error occurred while creating the read-only view.
Either the file system can not be mounted (like swap), or there are inconsistencies or errors in the file system.
Failed creating read-only view
Error:
The file system is mounted on:
Unable to open the default file manager
Warning: The detected file system area overlaps with at least one existing partition
It is recommended that you do not use any overlapping file systems to avoid disturbing existing data.
Do you want to try to deactivate the following mount points?
create missing %1 entries
delete affected %1 entries
delete %1 entry
update %1 entry
_Mount
_Unmount
Created directory %1
Removed directory %1
Scanning %1
Confirming %1
Ignoring device %1 with logical sector size of %2 bytes.
GParted requires libparted version 2.2 or higher to support devices with sector sizes larger than 512 bytes.
Searching %1 partitions
unrecognized
A partition cannot have a length of %1 sectors
A partition with used sectors (%1) greater than its length (%2) is not valid
libparted messages
Linux Unified Key Setup encryption is not yet supported.
Unable to detect file system! Possible reasons are:
The file system is damaged
The file system is unknown to GParted
There is no file system available (unformatted)
The device entry %1 is missing
Unable to find mount point
Unable to read the contents of this file system!
Because of this some operations may be unavailable.
The cause might be a missing software package.
The following list of software packages is required for %1 file system support: %2.
%1 of unallocated space within the partition.
To grow the file system to fill the partition, select the partition and choose the menu item:
Partition --> Check.
create empty partition
path: %1
start: %1
end: %1
size: %1 (%2)
create new %1 file system
delete partition
delete %1 file system
Clear partition label on %1
Set partition label to "%1" on %2
Set half of the UUID on %1 to a new, random value
Set UUID on %1 to a new, random value
moving requires old and new length to be the same
rollback last change to the partition table
move file system to the left
move file system to the right
move file system
new and old file system have the same position. Hence skipping this operation
using libparted
resizing requires old and new start to be the same
resize/move partition
move partition to the right
move partition to the left
grow partition from %1 to %2
shrink partition from %1 to %2
move partition to the right and grow it from %1 to %2
move partition to the right and shrink it from %1 to %2
move partition to the left and grow it from %1 to %2
move partition to the left and shrink it from %1 to %2
new and old partition have the same size and position. Hence skipping this operation
old start: %1
old end: %1
old size: %1 (%2)
new start: %1
new end: %1
new size: %1 (%2)
requested start: %1
requested end: %1
requested size: %1 (%2)
shrink file system
grow file system
resize file system
new and old file system have the same size. Hence skipping this operation
grow file system to fill the partition
growing is not available for this file system
growing the file system is currently disallowed
the destination is smaller than the source partition
copy file system of %1 to %2
using internal algorithm
copy %1
finding optimal block size
%1 seconds
optimal block size is %1
%1 (%2 B) copied
roll back last transaction
check file system on %1 for errors and (if possible) fix them
checking is not available for this file system
set partition type on %1
new partition type: %1
new partition flag: %1
calibrate %1
calculate new size and position of %1
clear old file system signatures in %1
flush operating system cache of %1
update boot sector of %1 file system on %2
Error trying to write to boot sector in %1
Error trying to seek to position 0x1c in %1
Error trying to open %1
Failed to set the number of hidden sectors to %1 in the NTFS boot record.
You might try the following command to correct the problem:
Libparted Warning
Libparted Information
Libparted Error
Libparted Bug Found!
Fix
Yes
Ok
Retry
No
Cancel
Ignore
_Undo Last Operation
_Clear All Operations
_Apply All Operations
One or more Physical Volumes belonging to the Volume Group is missing.
An error occurred reading LVM2 configuration!
Some or all of the details might be missing or incorrect.
You should NOT modify any LVM2 PV partitions.
Set half the UUID to a new random value on %1 file system on %2
Set a new random UUID on %1 file system on %2
copy of %1
Copy %1 to %2 (start at %3)
Copy %1 to %2
Check and repair file system (%1) on %2
Create %1 #%2 (%3, %4) on %5
Delete %1 (%2, %3) from %4
Format %1 as %2
Clear Partition Label on %1
Set Partition Label "%1" on %2
resize/move %1
new and old partition have the same size and position. Hence continuing anyway
Move %1 to the right
Move %1 to the left
Grow %1 from %2 to %3
Shrink %1 from %2 to %3
Move %1 to the right and grow it from %2 to %3
Move %1 to the right and shrink it from %2 to %3
Move %1 to the left and grow it from %2 to %3
Move %1 to the left and shrink it from %2 to %3
Mount Point
Size
Used
Unused
Flags
unallocated
unknown
unformatted
cleared
used
unused
%1 B
%1 KiB
%1 MiB
%1 GiB
%1 TiB
_Refresh Devices
_Devices
_GParted
_Edit
Device _Information
Pending _Operations
_View
_File System Support
_Create Partition Table
_Attempt Data Rescue
_Device
_Partition
_Contents
_Help
New
Create a new partition in the selected unallocated space
Delete the selected partition
Resize/Move the selected partition
Copy the selected partition to the clipboard
Paste the partition from the clipboard
Undo Last Operation
Apply All Operations
_New
_Resize/Move
_Format to
_Mount on
M_anage Flags
C_heck
_Label
New UU_ID
Device Information
Model:
Partition table:
Heads:
Sectors/track:
Cylinders:
Sector size:
Could not add this operation to the list
Quit GParted?
%1 - GParted
Scanning all devices...
No devices detected
No partition table found on device %1
A partition table is required before partitions can be added.
To create a new partition table choose the menu item:
Device --> Create Partition Table.
Unable to open GParted Manual help file
Documentation is not available
This build of gparted is configured without documentation.
Documentation is available at the project web site.
GNOME Partition Editor
translator-credits
If you want more partitions you should first create an extended partition. Such a partition can contain other partitions. Because an extended partition is also a primary partition it might be necessary to remove a primary partition first.
Moving a partition might cause your operating system to fail to boot
You have queued an operation to move the start sector of partition %1.
Failure to boot is most likely to occur if you move the GNU/Linux partition containing /boot, or if you move the Windows system partition C:.
You can learn how to repair the boot configuration in the GParted FAQ.
Moving a partition might take a very long time to apply.
You have pasted into an existing partition
The data in %1 will be lost if you apply this operation.
Unable to delete %1!
Please unmount any logical partitions having a number higher than %1
Are you sure you want to delete %1?
After deletion this partition is no longer available for copying.
Delete %1 (%2, %3)
Cannot format this file system to %1
A %1 file system requires a partition of at least %2.
A partition with a %1 file system has a maximum size of %2.
The partition could not be unmounted from the following mount points:
Most likely other partitions are also mounted on these mount points. You are advised to unmount them manually.
The swapon action cannot be performed if an operation is pending for the partition.
Use the Edit menu to undo, clear, or apply operations before using swapon with this partition.
The activate Volume Group action cannot be performed if an operation is pending for the partition.
Use the Edit menu to undo, clear, or apply operations before using activate Volume Group with this partition.
Deactivating swap on %1
Activating swap on %1
Could not deactivate swap
Could not activate swap
Deactivating Volume Group %1
Activating Volume Group %1
Could not deactivate Volume Group
Could not activate Volume Group
Unmounting %1
Could not unmount %1
The mount action cannot be performed if an operation is pending for the partition.
Use the Edit menu to undo, clear, or apply operations before using mount with this partition.
mounting %1 on %2
Could not mount %1 on %2
A new partition table cannot be created when there are active partitions.
Active partitions are those that are in use, such as a mounted file system, or enabled swap space.
Use Partition menu options, such as unmount or swapoff, to deactivate all partitions on this device before creating a new partition table.
A new partition table cannot be created when there are pending operations.
Use the Edit menu to either clear or apply all operations before creating a new partition table.
Error while creating partition table
Command gpart was not found
This feature uses gpart. Please install gpart and try again.
A full disk scan is needed to find file systems.
The scan might take a very long time.
After the scan you can mount any discovered file systems and copy the data to other media.
Do you want to continue?
Search for file systems on %1
Searching for file systems on %1
No file systems found on %1
The disk scan by gpart did not find any recognizable file systems on this disk.
Are you sure you want to apply the pending operations?
Editing partitions has the potential to cause LOSS of DATA.
You are advised to backup your data before proceeding.
Apply operations to device
You are deleting non-empty LVM2 Physical Volume %1
You are formatting over non-empty LVM2 Physical Volume %1
You are pasting over non-empty LVM2 Physical Volume %1
Deleting or overwriting the Physical Volume is irrecoverable and will destroy or damage the Volume Group.
To avoid destroying or damaging the Volume Group, you are advised to cancel and use external LVM commands to free the Physical Volume before attempting this operation.
Do you want to continue to forcibly delete the Physical Volume?
Failed to find devid for path %1
Changing the UUID might invalidate the Windows Product Activation (WPA) key
On FAT and NTFS file systems, the Volume Serial Number is used as the UUID. Changing the Volume Serial Number on the Windows system partition, normally C:, might invalidate the WPA key. An invalid WPA key will prevent login until you reactivate Windows.
Changing the UUID on external storage media and non-system partitions is usually safe, but guarantees cannot be given.
_Swapon
_Swapoff
Partition move action skipped because %1 file system does not contain data
Partition copy action skipped because %1 file system does not contain data
Ac_tivate
Deac_tivate
The LVM2 Physical Volume can not currently be resized because it is a member of an exported Volume Group.
Root privileges are required for running GParted
Since GParted is a powerful tool capable of destroying partition tables and vast amounts of data, only root may run it.
In an attempt to avoid invalidating the WPA key, on NTFS file systems only half of the UUID is set to a new random value.
run simulation
real resize
Default is to create an MS-DOS partition table.
Advanced
%1 active
%1 not active
%1 of %2 read (%3 remaining)
%1 of %2 read
read %1 using a block size of %2
Available
read %1
%1 (%2 B) read
wrote %1 of zeros at byte offset %2
clear primary signatures
clear secondary signatures
perform read-only test
perform real move
# Temporary file created by gparted. It may be deleted.
Label operation failed: Unable to write to temporary file %1.
Label operation failed: Unable to create temporary file %1.
@@image: 'figures/gparted_window.png'; md5=0c6eb27cd7d5d614b4ea752846ccb50b
GParted Manual
GParted Project
GParted is the Gnome Partition Editor for creating, reorganizing, and deleting disk partitions. GParted enables you to change the partition organization while preserving the partition contents.
2008, 2009, 2010, 2011, 2012, 2013, 2014
Curtis Gedak
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You can find a copy of the GFDL at this link or at or in the file COPYING-DOCS distributed with this manual.
Curtis
Gedak
gedakc@users.sf.net
GParted Manual V1.7
February 2014
Describes version 0.18.0 of GParted
GParted Manual V1.6
December 2013
Describes version 0.17.0 of GParted
GParted Manual V1.5
September 2013
Describes version 0.16.2 of GParted
GParted Manual V1.4
February 2012
Describes version 0.12.0 of GParted
GParted Manual V1.3
January 2011
Describes version 0.8.0 of GParted
GParted Manual V1.2
June 2010
Describes version 0.6.0 of GParted
GParted Manual V1.1
July 2009
Describes version 0.4.6 of GParted
GParted Manual V1.0
January 2009
Describes version 0.4.2 of GParted
GParted Manual V0.3.9
September 2008
Describes version 0.3.9 of GParted
This manual describes version 0.18.0 of GParted
Feedback
To report a bug or make a suggestion regarding the gparted application or this manual, follow the directions at .
Introduction
The gparted application is the GNOME partition editor for creating, reorganizing, and deleting disk partitions.
A disk device can be subdivided into one or more partitions. The gparted application enables you to change the partition organization on a disk device while preserving the contents of the partition.
Create a partition table on a disk device.
Enable and disable partition flags such as boot and hidden.
Perform actions with partitions such as create, delete, resize, move, check, label, copy, and paste.
With gparted you can accomplish the following tasks:
Editing partitions has the potential to cause LOSS of DATA.
The gparted application is designed to enable you to edit partitions while reducing the risk of data loss. The application is carefully tested and is used by the GParted project team. However, loss of data might occur due to software bugs, hardware problems, or power failure.
You can help to reduce the risk of data loss by not mounting or unmounting partitions outside of the gparted application while gparted is running.
You are advised to BACKUP your DATA before using the gparted application.
Getting Started
Starting gparted
You can start gparted in the following ways:
Applications menu
Choose System ToolsGParted Partition Editor.
Command line
Execute the following command: gparted
On startup, gparted will scan your computer for disk devices.
The gparted Window
When you start gparted, the following window is displayed:
gparted Window
Shows gparted main window.
The gparted window contains the following elements:
Menubar
The menus on the menubar contain all of the commands you need to work with disk devices and partitions in gparted.
Toolbar
The toolbar contains a subset of the commands that you can access from the menubar.
Graphic Display Area
The graphic display area contains the visual representation of the partitions on the selected disk device.
Text Display Area
The text display area contains the text list of the partitions on the selected disk device.
Statusbar
The statusbar displays information about current gparted activity or the number of operations pending.
Device Information Pane
The device information pane displays details about the selected disk device.
By default the device information pane is not shown. To show the device information pane, choose ViewDevice Information.
Pending Operations Pane
The pending operations pane displays the current list of partition operations in the queue.
By default the pending operations pane is not shown when there are 0 pending operations. To show the pending operations pane, choose ViewPending Operations.
When you left-click in either display area, you select a partition to use for partition editing actions.
When you right-click in either display area, the application displays a popup menu. The popup menu contains the most common partition editing actions.
Like other GNOME applications, actions in gparted can be performed in several ways: with the menu, with the toolbar, or with shortcut keys.
Running gparted from a Command Line
You can run gparted from a command line and specify one or more disk devices.
To work with multiple disk devices from a command line, type the following command, then press Enter:
$
/path-to-your-device1 /path-to-your-device2
gparted
Viewing File System Support
To view the actions supported on file systems, choose: ViewFile System Support. The application displays the File System Support dialog.
If you have installed software while gparted is running, click Rescan For Supported Actions to refresh the chart. The application refreshes the display of the chart.
To close the File System Support dialog, click Close.
Working with Devices
Selecting a Device
To select a disk device, choose: GPartedDevices and select a device from the list. The application displays the device partition layout in the gparted window.
Viewing Device Information
Select a disk device. See .
Select: ViewDevice Information. The application opens a side pane in the gparted window and displays information about the device.
To view information about a disk device:
To close the Device Information side pane, deselect: ViewDevice Information.
Refreshing All Devices
To refresh all disk devices, choose: GPartedRefresh Devices. The application rescans all the disk devices and refreshes the device partition layout in the gparted window.
Creating a New Partition Table
Choose: DeviceCreate Partition Table. The application displays a Create partition table on /path-to-device dialog.
Optionally select a different partition table type from the list.
The default partition table type is msdos for disks smaller than 2 Tebibytes in size (assuming a 512 byte sector size) and gpt for disks 2 Tebibytes and larger.
See for msdos partition table limitations.
Click Apply to create the new partition table. The application writes the new partition table to the disk device. The application refreshes the device partition layout in the gparted window.
To create a new partition table on a disk device:
WARNING: This will ERASE ALL DATA on the ENTIRE DISK DEVICE.
If you accidentally overwrite your partition table, see .
Attempting Data Rescue
Choose: DeviceAttempt Data Rescue. The application displays a Search for file systems on /path-to-device dialog.
Click OK to start the full disk scan.
Large disk devices can take a very long time to scan. If you do not have the time to wait for a full disk scan then click Cancel.
A maximum of 4 partitions with file systems might be discovered. If you want to discover more than 4 partitions and restore the partition table, see .
/path-to-device
No file systems found on
If no file systems are found, you have other options to try to rescue your data. The photorec application is designed to help recover many different types of lost files. For more information about photorec, see .
Click OK to close the dialog box, and end this attempt to rescue data.
File systems found on
If file systems are found, each file system is displayed in a list along with a View button. The dialog will indicate if there are data inconsistencies. Inconsistencies in the data might prevent you from viewing the data.
When the full disk scan completes one of two possible dialogs is displayed:
Click View to mount and display the file system. Your default file manager is opened and displays a read-only view of the file system.
If the dialog Unable to open the default file manager is displayed, then you will need to open a file manager and navigate to the mount point for the file system.
The mount point is shown in the dialog, for example "/tmp/gparted-roview-XXXXXX".
Click OK to close the Unable to open the default file manager dialog.
Use the file manager to copy your data to other storage media.
When you are finished copying your data, close the file manager.
To rescue data, use the following steps for each file system:
When you are finished rescuing data, click Close to end this attempt to rescue data. The application umounts any file systems that were mounted for viewing. Then the application rescans all the disk devices and refreshes the device partition layout in the gparted window.
To attempt data rescue from a disk device:
Working with Partitions
Basic Partition Actions
These actions will not alter partitions on your disk device.
Selecting a Partition
Click on a partition in the graphic display area.
Click on a partition in the text display area.
To select a partition, use one of the following:
The application highlights the partition in both the graphic display area and the text display area in the gparted window.
Partition operations such as delete, move, copy, format, check, label, and often resize require the partition to be unmounted. See .
Selecting Unallocated Space
Click on unallocated in the graphic display area.
Click on unallocated in the text display area.
To select unallocated space, use one of the following:
The application highlights the unallocated space in both the graphic display area and the text display area in the gparted window.
If you do not have any disk devices with unallocated space, you might try the following:
Add a new disk device to your computer.
Shrink a partition that contains unused space. See .
Viewing Partition Information
Select a partition. See .
Choose: PartitionInformation. The application opens an Information about /path-to-partition dialog.
To view information about a partition:
To close the Information about /path-to-partition dialog, click Close.
Mounting a Partition
Select an unmounted partition. See .
Choose: PartitionMount and select a mount point from the list. The application mounts the partition on the mount point and refreshes the device partition layout in the gparted window.
To mount a partition:
If PartitionMount is not visible, then gparted does not know where the partition should be mounted.
Unmounting a Partition
Select a mounted partition. See .
Choose: PartitionUnmount. The application unmounts the partition from the mount point and refreshes the device partition layout in the gparted window.
To unmount a partition:
If PartitionUnmount does not succeed, then the partition is probably in use.
To have all partitions unmounted and available for partition editing actions, boot from a Live CD and use gparted. See
Intermediate Partition Actions
These actions will alter partitions on your disk device. These actions will not modify the start or end boundaries of your existing partitions.
Creating a New Partition
Select an unallocated space on the disk device. See .
Choose: PartitionNew. The application displays the Create new Partition dialog.
Specify the size and the location for the partition. See .
Specify the alignment for the partition. See .
Specify the type of partition. See .
Specify the type of file system for the partition. See .
Specify the label for the partition. See .
Click Add to add the create partition operation to the operation queue. The application displays the create partition operation in the Pending Operations pane in the gparted window.
To create a new partition:
Deleting a Partition
Choose: PartitionDelete. The application displays the delete partition operation in the Pending Operations pane.
To delete a partition:
If you delete a logical partition, then all existing logical partitions after the deleted logical partition will experience changes in device names.
For example, an extended partition contains four logical partitions A, B, C, and D. These logical partitions are accessed by the operating system as follows:
Partition A as /dev/sda5.
Partition B as /dev/sda6.
Partition C as /dev/sda7.
Partition D as /dev/sda8.
If partition B is deleted, then the remaining logical partitions will be accessed by the operating system as follows:
Partition C as /dev/sda6. Note the change in device name.
Partition D as /dev/sda7. Note the change in device name.
Changes in a device name can cause problems if a partition is mounted using a device name. You can avoid the problem by using the label or the Universally Unique Identifier (UUID) of the partition when mounting the partition.
/etc/fstab - Contains a list of file systems to mount.
/boot/grub/menu.lst - Contains operating system boot instructions for the grub boot loader.
Changes in a device name might adversely affect the following files:
Formatting a Partition
Choose: PartitionFormat to, and select a type of file system from the list. The application displays the format partition operation in the Operations Pending pane.
See for the meaning of the cleared file system type.
To format a partition:
Setting a Partition Label
Choose: PartitionLabel. The application opens a Set partition label on /path-to-partition dialog.
Type a label name in the Label text box.
Click OK. The application displays the set partition label operation in the Operations Pending pane.
To set a label or a volume name for a partition:
Changing a Partition UUID
Choose: PartitionNew UUID. The application displays the set a new random UUID operation in the Operations Pending pane.
Changing the UUID might invalidate the Windows Product Activation key (WPA).
On FAT and NTFS file systems, the Volume Serial Number is used as UUID. Changing the Volume Serial Number on the Windows system partition, normally C:, might invalidate the WPA key. An invalid WPA key will prevent login until you reactivate Windows.
In an attempt to avoid invalidating the WPA key, on NTFS file systems only half of the UUID is set to a new random value. On FAT file systems, such a precaution is not possible.
The WPA key should not be affected by changing the UUID of data partitions or removable media partitions. In rare cases, a partition that is present at boot time might be an exception to this rule.
Changing the UUID when there is no need to do so might cause a GNU/Linux system to fail to boot, or to fail to mount a file system.
Changing the UUID is only required after copying a partition. The UUID change is needed to prevent duplicate UUIDs when both the source and the copy of the partition are used on the same computer.
If boot or mount problems occur you might need to edit configuration files, such as /etc/fstab, and regenerate the grub menu to ensure that the correct UUID is specified.
To change the Universally Unique Identifier (UUID) of a partition:
Specifying Partition Details
Specifying partition details is useful when performing actions such as create, resize, and move.
Specifying Partition Size and Location
Click-and-hold the arrow at either end of the graphic area. Drag the arrow left or right within the display range.
Click-and-hold the middle of the partition in the graphic area. Drag the partition left or right within the display range.
Free Space Preceding
New Size
Free Space Following
Click the spin button arrows, or type numeric values to adjust the following fields:
To specify the size and the location of the partition, use one or a combination of the following:
The application refreshes both the graphic area and the numbers beside the three field labels.
Specifying Partition Alignment
To specify the alignment of the partition, click the Align to arrow button, and select from the list.
Use MiB alignment for modern operating systems. This setting aligns partitions to start and end on precise mebibyte (1,048,576 byte) boundaries. MiB alignment provides enhanced performance when used with RAID systems and with Solid State Drives, such as USB flash drives.
Use Cylinder alignment to maintain compatibility with operating systems released before the year 2000, such as DOS. This setting aligns partitions to start and end on disk cylinder boundaries.
The Cylinder/Head/Sector values reported by modern disk devices no longer have a direct physical relationship to the data stored on the disk device. Hence it is no longer valid to use this alignment setting to achieve enhanced performance.
Use None only if you have an in-depth knowledge of disk structure, partition tables, and boot records. This setting places partition boundaries relative to the end of any immediately preceding partition on the disk device. This setting is not guaranteed to reserve or respect space required for boot records.
Specifying Partition Type
To specify the partition type, click the Create as arrow button, and select from the list.
Maximum of 4 primary partitions.
Maximum of 3 primary partitions, and 1 extended partition.
The extended partition can contain multiple logical partitions. Some GNU/Linux distributions support accessing at most 15 partitions on a disk device.
Maximum size of a partition is 2 Tebibytes using a sector size of 512 bytes. The partition must also start within the first 2 Tebibytes of the disk device.
The msdos partition table limits partitions as follows:
Primary partitions provide better data recoverability because the partition boundaries are stored at known locations on the disk device.
Specifying Partition File System
To specify the type of file system for the partition, click the File System arrow button, and select from the list.
ext2, ext3 and ext4 file systems can be used for installing GNU/Linux, and for data.
linux-swap can be used with GNU/Linux to increase the virtual memory of your computer.
fat16 and fat32 file systems can be used to share data between free and commercial operating systems.
cleared can be used to clear any existing file system signatures and ensure that the partition is recognised as empty.
unformatted can be used to just create a partition without writing a file system.
Examples of uses for some file systems are as follows:
Specifying Partition Label
To specify the partition label, also known as a volume label, type a label name in the Label text box.
Labels can be used to help you remember what is stored in the partition.
Unique labels can be used to mount file systems with the GNU/Linux operating system.
Advanced Partition Actions
These actions will alter partitions on your disk device. These actions might modify the start or end boundaries of your existing partitions. These actions might cause operating systems to fail to boot.
Resizing a Partition
Resizing and moving a partition can be performed by a single gparted operation.
Unmounted or inactive partitions enable the most resize options.
Support is available for online resize of some mounted or otherwise active partitions. However this support is often limited to grow only.
Choose: PartitionResize/Move. The application displays the Resize/Move /path-to-partition dialog.
Adjust the size of the partition. See .
If you do not want the start of an existing partition to move, then do not change the free space preceding value. If the partition is mounted or otherwise active, then you will not be able to change the free space preceding value.
Specify the alignment of the partition. See .
Click Resize/Move. The application displays the resize/move partition operation in the Pending Operations pane.
Examine the operation that was added to the Pending Operations pane.
A move step might take a long time to complete.
If the partition is an operating system boot partition, then a move step might cause the operating system to fail to boot.
If the operation involves a move step, then consider the following:
If you are not prepared to wait or to fix potential operating system boot problems, then you might want to undo the operation. See .
To resize a partition:
To grow or move a partition, unallocated space must be available adjacent to the partition.
If you are growing a logical partition, then the unallocated space must be within the extended partition.
If you are growing a primary partition, then the unallocated space must not be within the extended partition.
You can move unallocated space to be inside or outside of the extended partition by resizing the extended partition boundaries.
Defragment the file system.
Booting into Safe Mode with the commercial operating system that uses NTFS can improve the ability to defragment the file system. To enter Safe Mode press F8 while your computer is booting the operating system.
Check the partition for errors with the following command: C:gt; chkdsk /f /r Remember to reboot back into the commercial operating system that uses NTFS to allow the chkdsk command to execute.
Temporarily disable the paging file. The paging file occupies a fixed location in the partition that the defragmentation process is unable to move.
Temporarily move large files to another partition or disk device. Large files are defined as greater than a few hundred Megabytes (MB).
Ensure a proper shut down of the commercial operating system that uses NTFS before you resize the NTFS partition
Leave at least 10 percent unused space in the NTFS partition. If you shrink the partition too much, then the commercial operating system might have difficulty functioning properly.
Reboot twice into the commercial operating system that uses NTFS after shrinking the NTFS partition.
To improve the ability to shrink NTFS partitions, you might consider one or more of the following:
Moving a Partition
Moving and resizing a partition can be performed by a single gparted operation.
Adjust the location of the partition. See .
To move a partition:
If the partition is an operating system boot partition, then the operating system might not boot after the move operation is applied.
If the operating system fails to boot, see .
Copying and Pasting a Partition
Choose: PartitionCopy. The application marks the partition as the source partition.
To copy a partition:
Select an unallocated space on a disk device. See .
Choose: PartitionPaste. The application displays the Paste /path-to-partition dialog.
If you want you can adjust the size and location of the partition. See .
If you want you can specify the alignment of partition. See .
Click Paste. The application displays the copy partition operation in the Pending Operations pane.
To Paste a partition:
The copy of the partition has the same label and the same Universally Unique Identifier (UUID) as the source partition. This can cause a problem when booting, or when mount actions use the partition label or the UUID to identify the partition.
The problem is that the operating system will randomly select to mount either the source, or the copy of the partition. For example, on the first mount action the source partition might be mounted. On the next mount action the copy of the partition might be mounted. Over time this random nature of partition mounting might make files seem to mysteriously appear or disappear depending upon which partition is mounted. Random mounting of the source or the copy of the partition might also cause severe data corruption or loss.
Change the UUID of either the source, or the copy of the partition. See .
If the partition label is not blank then change the label of either the source, or the copy of the partition. See .
After you have applied the copy operation:
After you have applied the copy operation, delete or reformat the source partition.
Use some other method to ensure that the source partition and the copy of the partition are not used on the same computer at the same time. For example, if the copy of the partition is on a separate drive then remove the drive from the computer.
To avoid the problem you are advised to do one of the following:
Managing Partition Flags
Choose: PartitionManage Flags. The application opens a Manage flags on /path-to-partition dialog.
To enable a flag, select the check box beside the flag. The application writes the enabled flag to the partition and refreshes the Manage flags on /path-to-partition dialog.
To disable a flag, deselect the check box beside the flag. The application writes the disabled flag to the partition and refreshes the Manage flags on /path-to-partition dialog.
To manage partition flags:
To close the Manage flags on /path-to-partition dialog, click Close.
Boot is used by some commercial operating system boot loaders. The boot flag indicates the partition is active or bootable. Only one partition on a disk device can be active.
Diag is used to indicate the partition is used for diagnostics / recovery.
Hidden is used by some commercial operating systems. The hidden flag makes the partition invisible to the operating system.
LBA is used by some commercial operating system boot loaders. The LBA flag indicates the partition should be accessed using Logical Block Addressing (LBA), instead of Cylinder-Head-Sector (CHS) addressing.
LVM is used to indicate the partition is used by a Logical Volume Manager (LVM).
Palo is used by the Precision Architecture - Reduced Instruction Set Computing (PA-RISC) boot loader, palo.
Prep is used to indicate the boot partition on Power Performance Computing (PowerPC) hardware.
RAID is used to indicate the partition is used in a Redundant Array of Inexpensive Disks (RAID).
A description of flags in an msdos partition table follows:
Atvrecv is used to indicate an Apple TV Recovery partition.
BIOS_GRUB indicates a BIOS boot partition often used by the GRUB 2 boot loader.
Diag indicates the partition is used for diagnostics or recovery.
HP-service is used to indicate a Hewlett Packard service partition.
Legacy_boot is used by some special purpose software to indicate the partition might be bootable.
LVM indicates the partition is used by a Logical Volume Manager (LVM).
Msftres is used to indicate a Microsoft Reserved partition.
RAID indicates the partition is used in a Redundant Array of Inexpensive Disks (RAID).
A description of flags in a gpt partition table follows:
Checking a Partition
Checking a partition will attempt to find and fix problems in the file system. Checking a partition will attempt to grow the file system to fill the partition.
Choose: PartitionCheck. The application displays the check partition operation in the Pending Operations pane.
To check a partition:
Working with the Operation Queue
Undoing Last Operation
To undo the last operation in the operation queue, choose: EditUndo Last Operation. The application removes the last operation from the queue displayed in the Pending Operations pane. If there are no operations remaining in the queue, the application closes the Pending Operations pane.
Clearing All Operations
To clear all operations in the operation queue, choose: EditClear All Operations. The application removes all operations from the queue and closes the Pending Operations pane.
Applying All Operations
Choose: EditApply All Operations. The application displays an Apply operations to device dialog.
Editing partitions has the potential to cause LOSS of DATA. You are advised to backup your data before applying your partition editing operations.
To view more information, click Details. The application displays more details about operations.
To view more information about the steps in each operation, click the arrow button beside each step.
To stop the operations while they are executing, click Cancel. The application displays a disabled Force Cancel (5) button and counts down for 5 seconds.
Cancel instructs the application to stop or roll back operations as necessary to ensure data integrity.
If operations have not halted after 5 seconds the application enables the Force Cancel button.
To force the operations to stop, click Force Cancel. The application displays a warning dialog.
Click Continue Operation to allow the roll back operations to complete, or click Cancel Operation to cancel the roll back operations.
Cancel Operation terminates the safe roll back of operations and might cause SEVERE file system damage and data loss. You are advised to click Continue Operation to allow the roll back to complete.
When the application finishes performing operations, the application displays the Save Details button and the Close button.
Click Apply. The application displays an Applying pending operations dialog. The application applies each pending operation in the order you created the operations. The application displays a status update when each operation is completed.
If you want to change the default file name, then type a file name in the Name text box.
If you want to save the file in a folder different than /root, Click Browse for other folders. The application displays a file system navigator.
Use the file system navigator to select a folder.
Click Save to save the file. The application saves the details file.
If you want to save the details from applying all operations, then click Save Details. The application displays a Save Details dialog.
If you use gparted from a Live CD, then the root file system exists in RAM memory. All files saved to the Live CD root file system will be lost when you shut down the computer.
If you saved the gparted details to the Live CD root file system, then you need to copy the file to more permanent storage. Examples of more permanent storage are a hard disk drive or a USB flash memory drive.
Click Close. The application closes the Applying pending operations dialog. The application rescans all the disk devices and refreshes the device partition layout in the gparted window.
To apply all operations:
Acquiring GParted on Live CD
A Live CD is a Compact Disc that contains a bootable operating system. A Live CD enables you to boot your computer from the CD.
You can edit all of your partitions because the partitions are not mounted.
You can edit partitions on computers that do not have a bootable operating system.
Using gparted from a Live CD has the following advantages:
The gparted application is available on many Live CD distributions.
GParted Live CD
System Rescue CD
You can download a Live CD image containing gparted from the following web sites:
To avoid wasting a blank CD when burning a CD image file, use the following tips:
Ensure the checksum of the downloaded file matches the checksum posted on the download page.
Be sure to burn the .iso file as an image to the blank CD. If you burn the .iso file as data to a blank CD then the CD will not boot in your computer.
Fixing Operating System Boot Problems
Delete a partition.
Move a partition.
Install another operating system and overwrite the Master Boot Record (MBR).
Your computer might fail to boot an operating system when you perform one of the following actions:
You are advised to consult documentation for your boot loader to learn how to fix the problem. You might consult the GParted FAQ, or the GParted forum. You might also use Internet search engines to learn how other people have solved similar problems.
Fixing GRUB boot problem
Move the partition containing the GRUB stage2 file.
Install a new operating system that overwrites the Master Boot Record (MBR).
The Grand Unified Boot loader (GRUB) might fail to boot an operating system if you do one of the following:
Start the grub application from the command line. $ grub
Find where grub stage1 is located by using one of the following:
If the /boot folder is stored in the / partition, use the command: grubgt; find /boot/grub/stage1 If the /boot folder is stored in a partition different than the / partition, use the command: grubgt; find /grub/stage1
The output from the find command might look like the following: (hd0,0) If more than one line is listed in the command output, you will need to decide which device you use for grub.
Set the grub root device by specifying the device returned by the find command. grubgt; root (hd0,0)
Reinstall grub by specifying the device returned by the find command. grubgt; setup (hd0,0)
Exit grub. grubgt; quit
Reboot your computer.
To fix these problems, you will need to reinstall the GRUB boot record using the following steps:
The grub application is included on each Live CD listed in
Recovering Partition Tables
If you accidentally overwrite your partition table, there is a chance that you might be able to recover it.
The testdisk application is designed to help recover lost partitions. For more information about testdisk, see .
The testdisk application is included on each Live CD listed in
translator-credits
Domain Component
User ID
Email Address
Date of Birth
Place of Birth
Gender
Country of Citizenship
Country of Residence
Common Name
Surname
Serial Number
Country
Locality
State
Street
Organization
Organizational Unit
Title
Telephone Number
Given Name
Initials
Generation Qualifier
DN Qualifier
Pseudonym
RSA
MD2 with RSA
MD5 with RSA
SHA1 with RSA
DSA
SHA1 with DSA
Server Authentication
Client Authentication
Code Signing
Email Protection
Time Stamping
Error loading PKCS#11 module: %s
Invalid PKCS#11 module: %s
Couldn't setup PKCS#11 module: %s
Couldn't initialize PKCS#11 module: %s
Couldn't initialize registered PKCS#11 modules: %s
The URI has invalid encoding.
The URI does not have the 'pkcs11' scheme.
The URI has bad syntax.
The URI has a bad version number.
The stream was closed
Name
Issued By
Expires
Certificate
A file already exists with this name. Do you want to replace it with a new file?
_Replace
The operation was cancelled.
Export certificate
Certificate files
PEM files
Other Name
XMPP Addr
DNS SRV
Email
DNS
X400 Address
Directory Name
EDI Party Name
URI
IP Address
Registered ID
Basic Constraints
Certificate Authority
Yes
No
Max Path Length
Unlimited
Extended Key Usage
Allowed Purposes
Subject Key Identifier
Key Identifier
Digital signature
Key encipherment
Data encipherment
Key agreement
Certificate signature
Revocation list signature
Key Usage
Usages
Subject Alternative Names
Extension
Identifier
Value
Couldn't export the certificate.
Identity
Verified by
Subject Name
Issuer Name
Issued Certificate
Version
Not Valid Before
Not Valid After
Certificate Fingerprints
Public Key Info
Signature
Key Algorithm
Key Parameters
Key Size
Key SHA1 Fingerprint
Public Key
Signature Algorithm
Signature Parameters
Critical
Unsupported key type for certificate request
The key cannot be used to sign the request
Certificate request
Attribute
Type
Challenge
_Details
Could not display '%s'
Could not display file
Reason
Cannot display a file of this type.
GnuPG Keyring
GnuPG Keyring: %s
PGP Key
Key ID
Gnupg process exited with code: %d
Gnupg process was terminated with signal: %d
The operation was cancelled
Elgamal
Encrypt
Sign
Certify
Authenticate
Disabled
Unknown
Invalid
Revoked
Expired
Undefined trust
Distrusted
Marginally trusted
Fully trusted
Ultimately trusted
The information in this key has not yet been verified
This key is invalid
This key has been disabled
This key has been revoked
This key has expired
This key is distrusted
This key is marginally trusted
This key is fully trusted
This key is ultimately trusted
Algorithm
Created
Expiry
Capabilities
Owner trust
Comment
User Attribute
Size
Signature of a binary document
Signature of a canonical text document
Standalone signature
Generic certification of key
Persona certification of key
Casual certification of key
Positive certification of key
Subkey binding signature
Primary key binding signature
Signature directly on key
Key revocation signature
Subkey revocation signature
Certification revocation signature
Timestamp signature
Third-party confirmation signature
Class
Local only
Exportable
Revocation Key
Fingerprint
Public Subkey
Secret Key
Secret Subkey
Initializing...
Import is in progress...
Imported to: %s
Import to: %s
Cannot import because there are no compatible importers
No data to import
Key
Private RSA Key
Private DSA Key
Private Key
Public DSA Key
Strength
Fingerprints
SHA1
SHA256
Certificate Request
Unrecognized or unsupported data.
Could not parse invalid or corrupted data.
The data is locked
Automatically chosen
The user cancelled the operation
In order to import, please enter the password.
Password:
Token:
Unlock
Label:
Import settings
Continue
Cancel
Confirm:
Passwords do not match.
Password cannot be blank
Access Prompt
Unlock access to passwords and other secrets
Unrecognized or unavailable attributes for key
Couldn't build public key
Another prompt is already in progress
Couldn't find a place to store the pinned certificate
Automatically unlock this keyring whenever I'm logged in
Lock this keyring when I log out
Lock this keyring after
Lock this keyring if idle for
minutes
Unlock: %s
Password
The contents of '%s' are locked. In order to view the contents, enter the correct password.
The contents are locked. In order to view the contents, enter the correct password.
GCR Certificate and Key Viewer
Show the application's version
[file...]
- View certificate and key files
Certificate Viewer
The password was incorrect
Imported
Import failed
Import
Label
An online account needs attention
Open Online Accounts...
Facebook
Expected status 200 when requesting guid, instead got status %d (%s)
Error parsing response as JSON:
Didn't find username member in JSON data
Didn't find name member in JSON data
Email Address
Use this account for
Chat
Google
Didn't find data member in JSON data
Didn't find email member in JSON data
Mail
Calendar
Contacts
Documents
Windows Live
Didn't find id member in JSON data
Didn't find account email member in JSON data
User Name
Expected status 200 when requesting access token, instead got status %d (%s)
Didn't find access_token in non-JSON data
Didn't find access_token in JSON data
Authorization response was "%s"
Paste authorization code obtained from the authorization page:
Dialog was dismissed
Error getting an Access Token:
Error getting identity:
There is already an account for the identity %s
Was asked to login as %s, but logged in as %s
Credentials not found in keyring (%s, %d):
Credentials do not contain access_token
Failed to refresh access token (%s, %d):
Error storing credentials in keyring (%s, %d):
Missing access_token or access_token_secret headers in response
Error getting a Request Token:
Expected status 200 for getting a Request Token, instead got status %d (%s)
Missing request_token or request_token_secret headers in response
Paste token obtained from the authorization page:
Credentials do not contain access_token or access_token_secret
ensure_credentials_sync is not implemented on type %s
GOA %s credentials for identity %s
Failed to store credentials in the keyring: %s
Failed to retrieve credentials from the keyring: %s
Error parsing result obtained from the keyring:
Twitter
Didn't find id_str member in JSON data
Didn't find screen_name member in JSON data
Yahoo
Didn't find guid member in JSON data
Didn't find value member in JSON data
Expected status 200 when requesting name, instead got status %d (%s)
Error parsing usercard response as JSON:
Didn't find profile member in JSON data
Didn't find nickname member in JSON data
Name
@@image: 'figures/gpm-unplugged.png'; md5=e9e38fa48737547a19b20af6a15d9e95
@@image: 'figures/gpm-charged.png'; md5=cc83716555d07b13a3659683f96c531c
@@image: 'figures/gpm-low.png'; md5=6cd86acf26f251d78060dd2ecb6b6506
@@image: 'figures/gpm-critical.png'; md5=77b0848ed3bd0510b65f89e0d07a2fed
@@image: 'figures/gpm-suspend-problem.png'; md5=4e4c1fafda61c5ace02f957717ea7ce6
@@image: 'figures/gpm-stats-graph.png'; md5=c7cfa37ad6e96041a1c312d85236e7f6
@@image: 'figures/gpm-prefs-ac.png'; md5=dc4409a63218146e52d3e670b26785bd
@@image: 'figures/gpm-prefs-battery.png'; md5=89fe431e4f38073f7d58f38425ad1ee7
@@image: 'figures/gpm-prefs-general.png'; md5=52b7d145bd085d8af6f3194ac632c547
@@image: 'figures/gs-prefs.png'; md5=e9ce36b6ef557681ca4e8e90b71a7f46
@@image: 'figures/applet-brightness.png'; md5=8ce34f6733215fb86009471f19850dcc
@@image: 'figures/applet-inhibit.png'; md5=7381a44dae4f17bfd47abaa54c0ca2a4
@@image: 'figures/gpm-cell-capacity.png'; md5=7635c3b846f39faf7b16a921a6ebb55c
GNOME Power Manager Manual
GNOME Power Manager is a session daemon for the GNOME Desktop that manages the power settings for your laptop or desktop computer.
2006-2009
Richard Hughes (richard@hughsie.com)
Richard Hughes
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License (GFDL), Version 1.1 or any later version published by the Free Software Foundation with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You can find a copy of the GFDL at this link or in the file COPYING-DOCS distributed with this manual.
This manual is part of a collection of GNOME manuals distributed under the GFDL. If you want to distribute this manual separately from the collection, you can do so by adding a copy of the license to the manual, as described in section 6 of the license.
Many of the names used by companies to distinguish their products and services are claimed as trademarks. Where those names appear in any GNOME documentation, and the members of the GNOME Documentation Project are made aware of those trademarks, then the names are in capital letters or initial capital letters.
DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS FREE OF DEFECTS MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT OR MODIFIED VERSION PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER; AND
UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY DISTRIBUTOR OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO USE OF THE DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.
DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE FURTHER UNDERSTANDING THAT:
Richard
Hughes
richard@hughsie.com
2.0
2006-08-30
Richard Hughes richard@hughsie.com
Feedback
To report a bug or make a suggestion regarding the GNOME Power Manager application or this manual, follow the directions in the GNOME Power Manager Contact Page.
GNOME Power Manager
gnome-power-manager
Introduction
Manual
The GNOME Power Manager session daemon is a power management daemon for the GNOME desktop
Usage
GNOME Power Manager is usually started in GNOME startup, but you can manually start GNOME Power Manager by doing:
Command line
Type gnome-power-manager --verbose --no-daemon, then press Return:
Notification Messages
When GNOME Power Manager has started, the following notifications may be displayed.
AC Adapter Unplugged
GNOME Power Manager Notification when AC adapter is removed
You can disable this notification by changing the GConf key /apps/gnome-power-manager/notify/discharging.
Fully Charged
GNOME Power Manager Notification when laptop primary battery is fully charged
You can disable this notification by changing the GConf key /apps/gnome-power-manager/notify/fully_charged.
You will only get a repeat notification if your battery percentage charge drops below 95% and then is again fully charged. This prevents some machines from showing unwanted repeat notifications if the battery is incorrectly reporting the charged status.
Power Low
When the battery is low, you will receive the following notification. You should consider switching to AC power really soon.
GNOME Power Manager Notification when battery power is low
You can disable this notification by changing the GConf key /apps/gnome-power-manager/notify/low_power.
Power Critical
When the computer has run out of power, it will show this notification explaining what action is required. You can change the critical low action using the preferences tool.
GNOME Power Manager Notification when the system power is critically low
Suspend Failure
When a suspend failure occurs you may get this following warning. The most common reason for this notification is that the current user does not have permission to suspend or hibernate the computer.
GNOME Power Manager Notification when suspend failure occurs
You can disable this notification by changing the GConf key /apps/gnome-power-manager/notify/sleep_failed.
Statistics
The statistics program allows you to visualize the power consumption of your laptop hardware.
This has been removed from the information window of previous versions of GNOME Power Manager as the data interface is now using DBUS rather than internal IPC. This allows other applications to query and display the data if required.
Power History going from battery power to AC
You may not see some options or graphs if your computer does not have the required hardware. You may also see other hardware not shown here (for example UPS devices) but these are treated the same way as other devices.
Charge History
This graph shows the percentage charge available for the composite primary battery, so if you have a main laptop battery and an auxiliary battery then only the averaged value will be shown. A legend is not shown with this graph.
Power History
This graph shows the power history charge used by the composite primary battery. This line represents the amount of power that is either being used to charge the batteries in the system, or the power being used by the system from the batteries. You should see the line go up when processor intensive tasks are performed, and down when the system is at idle, or when the screen is dimmed. A legend is shown with this graph when data events have been received.
You do will not receive rate data from your computer if it is not charging or discharging, or if the computer is suspended. This is due to hardware limitations where the rate is only sent from the battery management chip, rather than the power management chip on the motherboard.
Estimated Time History
This graph shows the estimated charge history for the composite primary battery. This line represents the amount of time required until charged, or the amount of time until discharge. This line should go proportionally up when the rate decreases and down when the rate increases. A legend is shown with this graph when data events have been received.
Preferences
The preferences window allows you to control:
The LCD brightness when on AC and battery power
The idle time for the screen power-down and suspend action
The actions to perform when the laptop lid is closed
The notification area icon policy
Some sliders or option boxes may be disabled if the GConf policy keys are not writable. This allows administrators to lock-down the actions that a user can select.
AC Preferences
GNOME Power Manager AC tab
Battery Preferences
GNOME Power Manager battery tab
This allows a powerful computer to reduce the power usage when idle, or when the full capabilities are not required.
General Preferences
GNOME Power Manager general tab
Session and system idle times
gnome-screensaver is a session daemon that monitors user input, and if the mouse has not been moved, or the keyboard been pressed then it starts a timeout. When the value of this timeout reaches the value set in gnome-screensaver-preferences, then the login is marked as 'session idle'. This is when GNOME Power Manager performs all the session idle actions such as enabling low-power mode and lowering the laptop panel brightness.
Changing the session idle timeout in gnome-screensaver-preferences
As soon as the session is marked at idle, GNOME Power Manager starts its own 'system' timer. When the timeout set in gnome-power-preferences is reached, and the CPU load is idle, then the idle action is performed, which is usually to turn off the screen, or to suspend or hibernate.
To make this clearer, the sliders in gnome-power-preferences are set to start at the value of the session-timeout + 1 minute, as we cannot logically trigger before the session is marked as idle. If you adjust the value of the 'session idle' timeout in gnome-screensaver-preferences then the start of the sliders in gnome-power-preferences will change accordingly.
Advanced Preferences
Screen Dim Brightness
You can change the idle laptop panel brightness by changing the GConf key /apps/gnome-power-manager/backlight/idle_brightness.
Screen Locking
By default, GNOME Power Manager supports a simple locking scheme. This means that the screen will lock if set to "Lock screen" in gnome-screensaver when the lid is closed, or the system performs a suspend or hibernate action.
There is a complex locking scheme available for power users that allows locking policy to change for the lid, suspend and hibernate actions. To enable this complex mode, you will have to disable the GConf key:
/apps/gnome-power-manager/lock/use_screensaver_settings
Then the policy keys can be set to force a gnome-screensaver lock and unlock when the action is performed:
/apps/gnome-power-manager/lock/blank_screen
/apps/gnome-power-manager/lock/suspend
/apps/gnome-power-manager/lock/hibernate
The lock policy for gnome-screensaver is ignored until the simple mode is re-enabled.
GNOME Power Applets
Brightness Applet
The brightness applet allows the user to change the brightness temporarily without changing the default policy. This may be useful if you have got a laptop without brightness buttons, as you can now change the brightness easily.
Brightness applet drop-down.
You will not get the slider if your hardware is not supported.
Inhibit Applet
The inhibit applet allows the user to prevent the computer auto-sleeping when inactive. This may be required with old or proprietary programs such as VMWare or Matlab. Just click the icon for the auto-suspend to be inhibited, and click it again for normal operation.
Inhibit applet in inhibited state.
Don't use this applet if you just use GNOME software, instead file a bug to make the application use the Inhibit() and UnInhibit() methods as this should 'just work'.
Frequently Asked Questions
These are questions the mailing list gets asked frequently.
What is battery capacity?
Capacity is how much charge your battery can store compared to its manufacturer's guidelines.
This graph shows the capacity of a typical lithium ion battery over a few hundred charge-discharge cycles.
What's the difference between suspend and hibernate?
The Suspend state is a power saving feature which is the lowest level of power consumption that preserves program data in the computer's memory. When your computer is in the Suspended state, computation will not be performed until normal activity is resumed. It will not resume until signaled by an external event such as a keyboard button press. It generally takes a few seconds to suspend and then resume your computer.
You still use a small amount of battery power while suspended, so is not recommended for the low power action. If you remove AC power on a desktop, or run out of battery power on a laptop then you will lose your work.
The Hibernation state saves the complete state of the computer to hard disk and turns off the power, so that the computer appears to be off. It will not resume until signaled by an external event such as a keyboard button press. This is the lowest power sleeping state available. If you remove AC power on a desktop, or run out of battery power on a laptop then work will not be lost. It can take up to a minute or more to hibernate and wake your computer.
My monitor is broken and treats DPMS standby and off states as 'no-signal' which leaves the monitor powered on.
You have to change the DPMS suspend mode GNOME Power Manager uses. Open gconf-editor, and then change the keys /apps/gnome-power-manager/backlight/dpms_method_ac and /apps/gnome-power-manager/backlight/dpms_method_battery to one of the modes that work, e.g. standby, suspend or off.
My time to discharge is always incorrect due to a faulty battery, what can I do?
You might be able to use the percentage charge for g-p-m to use as the policy data. Open gconf-editor, and then change the key /apps/gnome-power-manager/general/use_time_for_policy to false. You can do this easily by doing: gconftool-2 --set --type bool /apps/gnome-power-manager/general/use_time_for_policy false
This should get the policy actions working for you, but of course the time remaining will still be incorrect.
How do I make my application stop the computer auto-suspending?
If your application is doing a long operation, you might want to disable the ability to suspend for a little while. You should use gnome-session if you really don't want the user to be able to suspend, or for the computer to save power by hibernating or suspending.
I'm running ACPI. Why do events (such as removing the AC adapter) take so long to register?
One of two things might be the problem.
HAL might not be running the addon that captures the ACPI event.
You BIOS could be faulty, and might need a work-around. Please send a bug report.
For the first case, try to find the HAL processes that are running: ps -eaf | grep hal
And check for the process hald-addon-acpi. If it is not being run, then please make sure that HAL is being run with the --retain-privileges option in the haldaemon initscript. An alternative to this is to use acpid, rather than the kernel proc file.
About
GNOME Power Manager was written by Richard Hughes richard@hughsie.com. To find more information about GNOME Power Manager, please visit the GNOME Power Manager web page.
To report a bug or make a suggestion regarding this application or this manual, follow the directions at the GNOME Power Manager Bug Page.
This program is distributed under the terms of the GNU General Public license as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. A copy of this license can be found at this link, or in the file COPYING included with the source code of this program.
translator-credits
2006
I've set the computer inactive timeout to one minute and it still takes longer than that to suspend.
gnome-screensaver is a session daemon that monitors user input, and if the mouse has not been moved, or the keyboard been pressed then it starts a timeout. When the value of this timeout reaches the value set in gnome-screensaver-preferences, then the login is marked as 'session idle'. This is when GNOME Power Manager performs all the session idle actions such as enabling low-power mode and lowering the laptop panel brightness.
As soon as the session is marked at idle, GNOME Power Manager starts its own 'system' timer. When the timeout set in gnome-power-preferences is reached, and the CPU load is idle, then the idle action is performed, which is usually to turn off the screen, or to suspend or hibernate.
In GNOME Power Manager 2.14 the timeouts were not obviously linked to gnome-screensaver, but the timeouts are linked in reality. This is because the gnome-screensaver declares the session "idle" and then GNOME Power Manager starts. Therefore the real time to suspend is actually the GNOME Screensaver timeout PLUS the GNOME Power Manager time.
In GNOME Power Manager 2.16 and newer, the sliders in gnome-power-preferences are set to start at the value of the session-timeout + 1 minute, as we cannot logically trigger before the session is marked as idle. If you adjust the value of the 'session idle' timeout in gnome-screensaver-preferences then the start of the sliders in gnome-power-preferences will change accordingly. This makes it more obvious for new users.
Why does not my IBM laptop have the brightness sliders in Power Preferences?
You need to add to /etc/modprobe.conf the following text: options ibm_acpi experimental=1
This will enable the experimental features and make the LCD work.
You will have to use sudo or a root account to edit this file.
Why does my lid state get confused after suspending or hibernating? (and) My laptop suspended when I didn't expect it to when I removed the power cord!
When you suspend and then resume, ACPI does not seem to send the "lid open" event like it should, which I presume is because userspace is not in a position to handle the kernel event when we start to thaw userspace processes.
What we have to do it manually refresh the lid device using HAL when we resume, so that the new "lid open" value is propagated to GNOME Power Manager.
You need to update to a newer version of HAL, or use your updated distribution bug-fix packages.
Does GNOME Power Manager support APM?
It supports whatever backends HAL supports! At the moment this includes:
APM (Pre-2000 Intel computers)
ACPI (most modern Intel compatible computers)
PMU (Powerbook, and iBook PPC computers)
Why does GNOME Power Manager not let me suspend or hibernate?
Before showing items such as "Suspend" and "Hibernate" in the menu g-p-m checks two things:
If HAL can detect a sleep handler in the kernel. You can test this doing lshal | grep can_suspend. HAL works this out from looking at /sys/power/state, and also checking for the presence of suspend2.
If your administrator (or you!) has disabled the ability to do a certain action. You can test this using gconftool-2 -R /apps/gnome-power-manager | grep can and change the values to be something more suitable.
For instance, my PowerBook reports from HAL that it can suspend and hibernate, but because I know my hibernate does not work, I can disable it in gconf-editor removing the option from gnome-power-preferences and the drop-down menu.
If HAL does not list the options you want, then maybe you need to check your BIOS to check that it's running in the correct mode, and also that you have compiled your kernel with the correct options.
If there are no gconf keys returned by the second check above, you need to reinstall your gconf schema as per gnomebug:341256: (as root):
export GCONF_CONFIG_SOURCE=`gconftool-2 --get-default-source` gconftool-2 --makefile-install-rule data/gnome-power-manager.schemas killall -HUP gconfd-2
Why does my screen dim or screensaver start even when I'm clicking the mouse?
If you click the mouse, or scroll the scroll-wheel without moving the pointer, then gnome-screensaver will detect the session as being idle. This is a limitation of X.org, but is worked around in newer versions of gnome-screensaver.
Copying files in Nautilus
Doing a long kernel compile or Matlab simulation
During a SELinux relabel
Many others...
Then you can use the Inhibit() and UnInhibit() DBUS methods built into the newest versions of GNOME Power Manager. Here is a simple demonstration in python:
#!/usr/bin/python import dbus import time bus = dbus.Bus(dbus.Bus.TYPE_SESSION) devobj = bus.get_object('org.freedesktop.PowerManagement', '/org/freedesktop/PowerManagement/Inhibit') dev = dbus.Interface(devobj, "org.freedesktop.PowerManagement.Inhibit") cookie = dev.Inhibit('Nautilus', 'Copying files') time.sleep(100) dev.UnInhibit(cookie)
There is an example which shows developers how to add Inhibit and UnInhibit DBUS methods into existing programs.
Are GNOME Power Manager and GNOME Screensaver inhibit methods the same?
If you call the inhibit methods on gnome-screensaver, then gnome-screensaver will not mark your session as idle. This means that the screen will not dim, the screensaver will not start and the computer will not suspend automatically.
While playing a movie full-screen, totem should use the gnome-screensaver inhibit methods. The idea is that totem does not have to worry at all about power management. The only thing it wants to assert is that even though there are no key presses or mouse movements, the session is still being used.
The only applications that should use the GNOME Power Manager inhibit method are things that want to assert that the session can be marked as idle, but important things are still happening, so it should not power down. For example, when copying 4.5GB of files in Nautilus, you want the screensaver to display, and the LCD panel to dim, but you don't want the computer to think that it is idle and shutdown, suspend or hibernate.
GNOME Power Manager does not spin down my hard-drive!
After numerous debates, the consensus was that is was not a good idea to add this functionality to HAL. It was decided user-configurable power management was not really required when modern hard disks have really intelligent power management.
Here the power consumption data for a typical notebook hard disk (IDE/SATA):
Startup (peak, max.)\t\t5.5W \tNC Seek\t\t\t\t2.3W\t2.7W Read (avg.)\t\t\t2.0W\t2.3W Write (avg.)\t\t\t2.0W\t2.3W Active idle (avg.)\t\t1.1W\t1.2W Low power idle (avg.)\t\t0.85W\t0.9W Standby (avg.)\t\t\t0.2W\t0.25W Sleep\t\t\t\t0.1W\tNC
The conclusions you can take from this are:
A disk on low power idle mode needs less than 1 Watt. For a normal battery with 50Wh you could run the hard disk for over 50 hours.
If you do not read/write from/to the hard disk the disk regulates power, but never shuts down the device. The reason is easy: you lost more power with each startup than to leave the hard disk online somewhere between 'Active idle' and 'Low power idle' (depends on the model/manufacturer).
The other reason to leave this to the internal power management of the disk is: the time needed to reactivate the device. You lose more performance than you lose power between 'Active idle' and 'Low power idle'.
If you use a journaling file system you normally need to flush periodically. This could run in a race between shut down device and restart device by system to flush. This means more power consumption as you change nothing.
You can't set power management for external USB hard disks, because you can't send the needed commands over the USB link to the disk.
How do I query or do actions on GNOME Power Manager from my shell script?
You can use the dbus-send program. For example, you can set the DPMS mode by running the following:
dbus-send --session \\ \t --dest=org.freedesktop.PowerManagement \\ \t --type=method_call \\ \t --print-reply \\ \t --reply-timeout=2000 \\ \t /org/freedesktop/PowerManagement \\ \t org.freedesktop.PowerManagement.SetDpmsMode \\ \t string:suspend
You can put the system into hibernation using the following:
dbus-send --session \\ \t --dest=org.freedesktop.PowerManagement \\ \t --type=method_call \\ \t --print-reply \\ \t --reply-timeout=2000 \\ \t /org/freedesktop/PowerManagement \\ \t org.freedesktop.PowerManagement.Hibernate
See the developers guide file in CVS for the full list.
Nothing happens when I click suspend or hibernate!
HAL might not *yet* support your distro, or you might have found a bug in GNOME Power Manager. Refer to the reporting bugs section.
Why does not my video adaptor come back after a suspend? It just displays black!
You may need to add a s3 command to your kernel boot string so that the kernel can re-initialize your video card. See this document for more details, or to see if your system has been identified as needing any extra switches.
Using the new pm-utils should make all this stuff just work in the future using HAL fdi matching against machine DMI and video card vendor and product IDs.
Modern computers allow the speed of the processor to be reduced to save power. This allows a powerful computer to reduce the power usage when idle, or when the full capabilities are not required. This dramatically increases battery life as the processor is not running continuously at 100%.
All Pentium 4 - Ms
Pentium III Ms 600MHz to 1GHz
Pentium III Ms 700+ MHz
Not all processors support speed control, and you will not see the options to select a policy if your computer does not have a compatible processor installed. The following processors are known to support frequency scaling: Intel Mobile Celeron processors do not have the required functionality and the frequency cannot be controlled.
There are several ways to control the power consumption of the processor. You can have profiles, for example, to select maximum performance on AC power and maximum power saving on battery power. The easiest way to control the power saving is set the policy to "Automatic" as this will adjust the speed of the processor to the current state of the system automatically.
Maximum power saving: This sets the computer operating speed always to the lowest available setting to save battery power. (Linux kernel name: powersave.)
Always maximum speed: This governor sets the processor operating speed to the highest available. (Linux kernel name: performance.)
Automatic power saving: This option changes the frequency of the processor in relation to current processor load. If the processor is being used, then the frequency will increase, but if it is not then will slowly reduce. This provides a nice middle ground between power saving and application speed. This option will keep the processor at high frequency for a few seconds after recent processor activity. This governor may not work correctly on older notebook computers. (Linux kernel name: conservative.)
Based on processor load: This driver is a dynamic processor frequency policy. It will change the frequency of the processor in direct relation to processor load. Due to the number of frequency changes, this may not work reliably for older notebook computers. (Linux kernel name: ondemand.)
You may not have all the options listed below:
Some policies (ondemand and conservative) only increase the processor frequency from minimum when a process has a positive nice value even though a load greater than 1 occurs. This means user applications work well as the processor speed automatically increases. This can however result in a significant performance reduction for system daemons and some background session services. To rectify this, use another policy (e.g. Always maximum speed) or set the following GConf key: /apps/gnome-power-manager/cpufreq/consider_nice.
Whether we should show the history data points
Whether we should show the history data points in the statistics window.
Whether we should smooth the history data
Whether we should smooth the history data in the graph.
The default graph type to show for history
The default graph type to show in the history window.
The maximum time displayed for history
The maximum duration of time displayed on the x-axis of the history graph.
Whether we should show the stats data points
Whether we should show the stats data points in the statistics window.
Whether we should smooth the stats data
Whether we should smooth the stats data in the graph.
The default graph type to show for stats
The default graph type to show in the stats window.
The index of the page number to show by default
The index of the page number to show by default which is used to return focus to the correct page.
The ID of the last device selected
The identifier of the last device which is used to return focus to the correct device.
Power Statistics can show historical and current battery information and programs waking up that use power.
You probably only need to install this application if you are having problems with your laptop battery, or are trying to work out what programs are using significant amounts of power.
Power Statistics
Observe power management
battery;consumption;charge;
Details
Graph type:
Data length:
There is no data to display.
Use smoothed line
Show data points
History
Statistics
Processor wakeups per second:
Wakeups
%id
%id%02ih
%ih
%ih%02im
%2im
%2im%02i
%2is
%i%%
%.1fW
%.1fV
Rate
Charge
Time to full
Time to empty
10 minutes
2 hours
6 hours
1 day
1 week
Charge profile
Discharge profile
Charge accuracy
Discharge accuracy
Lithium Ion
Lithium Polymer
Lithium Iron Phosphate
Lead acid
Nickel Cadmium
Nickel metal hydride
Unknown technology
Charging
Discharging
Empty
Charged
Waiting to charge
Waiting to discharge
Unknown
Attribute
Value
Image
Description
Type
ID
Command
Yes
No
Device
Vendor
Model
Serial number
Supply
Refreshed
Present
Rechargeable
State
Energy
Energy when empty
Energy when full
Energy (design)
Voltage
Percentage
Capacity
Technology
Online
No data
Kernel module
Kernel core
Interprocessor interrupt
Interrupt
PS/2 keyboard/mouse/touchpad
ACPI
Serial ATA
ATA host controller
Intel wireless adaptor
Timer %s
Sleep %s
New task %s
Wait %s
Work queue %s
Network route flush %s
USB activity %s
Wakeup %s
Local interrupts
Rescheduling interrupts
Device Information
Device History
Device Profile
Processor Wakeups
Time elapsed
Power
Cell charge
Predicted time
Correction factor
Prediction accuracy
Show extra debugging information
Select this device at startup
Processor
Bug Buddy
Bug reporting tool
What _were you doing when the application crashed?
Your _email address:
Note: Sensitive information may be present in the crash details. Please review the crash details if you are concerned about transmitting passwords or other sensitive information.
_Review Crash Details
Send _other pending crash reports
_Send
Review Crash Details
C_opy
Bug Report Tool
Report a bug in GNOME-based applications
Bug reporter name
Real name of user reporting the bug.
Email Address
Email Address for submitting bug reports to GNOME Bugzilla. This address will be used for correspondence regarding the bug you are submitting. If you already have a GNOME Bugzilla account, please use it as your Email Address.
File to store unsent bug reports.
File where bug-buddy will save your bug report in case it can't be sent immediately to Bugzilla.
GTK+ module for crash collection support.
This key determines the GTK+ module to load for crash collection support.
GNOME Bug Buddy
Package containing the program
PACKAGE
File name of crashed program
FILE
PID of crashed program
PID
Text file to include in the report
Delete the included file after reporting
Copy _Link Address
Bug Buddy was unable to view the link "%s"
There was a network error while sending the report. Do you want to save this report and send it later?
Please ensure that your Internet connection is active and working correctly.
_Close
A bug report detailing your software crash has been sent to GNOME. This information will allow the developers to understand the cause of the crash and prepare a solution for it. You may be contacted by a GNOME developer if more details are required about the crash. You can view your bug report and follow its progress with this URL:
Bug Buddy encountered an error while submitting your report to the Bugzilla server. Details of the error are included below.
Bugzilla reported an error when trying to process your request, but was unable to parse the response.
The email address you provided is not valid.
The account associated with the email address provided has been disabled.
The product specified doesn't exist or has been renamed. Please upgrade to the latest version.
The component specified doesn't exist or has been renamed. Please upgrade to the latest version.
The summary is required in your bug report. This should not happen with the latest Bug Buddy.
The description is required in your bug report. This should not happen with the latest Bug Buddy.
The fault code returned by Bugzilla is not recognized. Please report the following information to bugzilla.gnome.org manually: %s
Server returned bad state. This is most likely a server issue and should be reported to bugmaster@gnome.org %s
Failed to parse the XML-RPC response. Response follows: %s
An unknown error occurred. This is most likely a problem with Bug Buddy. Please report this problem manually at bugzilla.gnome.org
Unable to create the bug report: %s
There was an error creating the bug report
Sending…
The description you provided for the crash is very short. Are you sure you want to send it?
A short description is probably not of much help to the developers investigating your report. If you provide a better one, for instance specifying a way to reproduce the crash, the issue can be more easily resolved.
_Review description
_Send anyway
Getting useful crash reports
The application %s crashed. The bug reporting tool was unable to collect enough information about the crash to be useful to the developers. In order to submit useful reports, please consider installing debug packages for your distribution. Click the link below to get information about how to install these packages:
Please write your report in English, if possible.
Information about the %s application crash has been successfully collected. Please provide some more details about what you were doing when the application crashed. A valid email address is required. This will allow the developers to contact you for more information if necessary.
WARNING:
Some sensitive data is likely present in the crash details. Please review and edit the information if you are concerned about transmitting passwords or other sensitive data.
Save File
-bugreport.txt
_Save Bug Report
The application %s has crashed. Information about the crash has been successfully collected. This application is not known to Bug Buddy, therefore the bug report cannot be sent to the GNOME Bugzilla. Please save the bug to a text file and report it to the appropriate bug tracker for this application.
There was an error displaying help: %s
Bug Buddy is a utility that helps report debugging information to the GNOME Bugzilla when a program crashes.
Bug Buddy could not load its user interface file. Please make sure Bug Buddy was installed correctly.
Collecting information from your system…
Either --appname or --package arguments are required.
Either --pid or --include arguments are required.
The --unlink-tempfile option needs an --include argument.
Bug Buddy was unable to retrieve information regarding the version of GNOME you are running. This is most likely due to a missing installation of gnome-desktop.
The %s application has crashed. We are collecting information about the crash to send to the developers in order to fix the problem.
Collecting information from the crash…
Bug Buddy encountered the following error when trying to retrieve debugging information: %s
Bug Buddy doesn't know how to send a suggestion for the application %s.
Thank you for helping us to improve our software. Please fill in your suggestions/error information for %s application. A valid email address is required. This will allow developers to contact you for more information if necessary.
Suggestion / Error description:
HTTP Response returned bad status code %d
Unable to parse XML-RPC response %s
Application does not track its bugs in the GNOME Bugzilla.
Product or component not specified.
Unable to create XML-RPC message.
gdb has already exited
Error on read; aborting.
GDB could not be found on your system. Debugging information will not be obtained.
Could not find the gdb-cmd file. Please try reinstalling Bug Buddy.
There was an error running gdb: %s
Rygel Preferences
column
Add a directory to the list of shared directories
Add shared directory
Remove a directory from the list of shared directories
Remove shared directory
_Share media through DLNA
Add a network interface Rygel should serve files on
Add network interface
Remove a network interface Rygel should no longer serve files on
Remove network interface
Networks:
Select folders
UPnP/DLNA Preferences
Rygel
UPnP/DLNA Services
mediaserver;mediarenderer;share;audio;video;pictures;
Module '%s' could not connect to D-Bus session bus. Ignoring…
External provider %s did not provide mandatory property "%s"
Unsupported type %s
Failed to roll back transaction: %s
'%s' harvested
Error fetching object '%s' from database: %s
Failed to query info of a file %s: %s
Error removing object from database: %s
Failed to harvest file %s: %s
Failed to query database: %s
Failed to enumerate folder "%s": %s
Failed to get children of container %s: %s
Failed to get child count of query container: %s
Failed to add item with ID %s: %s
Cannot create references to containers
Failed to query content type for '%s'
All
Failed to get child count: %s
Can't create items in %s
Can't add containers in %s
Can't remove containers in %s
Playlists
Can't remove items in %s
upnp:class not supported in %s
Will not monitor file changes
Failed to get file info for %s
Year
Artist
Album
Genre
Files & Folders
@REALNAME@'s media
Failed to remove entry: %s
Music
Pictures
Videos
Failed to remove file %s: %s
Could not find object %d in cache
MPRIS interface at %s is read-only. Ignoring.
GStreamer Player
Albums
Artists
Failed to create a Tracker connection: %s
Failed to construct URI for folder '%s': %s
Could not subscribe to Tracker signals: %s
Not supported
Failed to create Tracker connection: %s
Error getting all values for '%s': %s
Failed to start Tracker service: %s. Plugin disabled.
Failed to get Tracker connection: %s
Error getting item count under category '%s': %s
Titles
Not implemented
Failed to read standard output from %s: %s
Failed to read error output from %s: %s
No Such Test
Wrong Test Type
Invalid Test State '%s'
State '%s' Precludes Cancel
Invalid argument
Invalid connection reference
Failed to write modified description to %s
Failed to get log level from configuration: %s
No value available
No value set for '%s/enabled'
No value set for '%s/title'
No value available for '%s/%s'
[Plugin] group not found
Plugin module %s does not exist
New plugin '%s' available
A module named %s is already loaded
Failed to load module from path '%s': %s
Failed to find entry point function '%s' in '%s': %s
Error listing contents of folder '%s': %s
Could not load plugin: %s
Invalid InstanceID
Play speed not supported
Transition not available
Seek mode not supported
Illegal seek target
Resource not found
Failed to access resource at %s: %s
Illegal MIME-type
Invalid Name
Invalid Channel
Action Failed
Invalid Arguments
Cannot browse children on item
Failed to browse '%s': %s
Not Applicable
No such file transfer
No D-Bus thumbnailer service available
Invalid Range '%s'
Invalid Request
Not found
Invalid URI '%s'
Seeking not supported
Failed to generate playlist
Pushing data to non-empty item '%s' not allowed
No writable URI for %s available
Failed to move dotfile %s: %s
Requested item '%s' not found
Out Of Range Start '%ld'
Out Of Range Stop '%ld'
Failed to get original URI for '%s': %s
URI '%s' invalid for importing contents to
ContainerID missing
Successfully destroyed object '%s'
Failed to destroy object '%s': %s
No such object
Removal of object %s not allowed
Object removal from %s not allowed
Object id missing
Successfully updated object '%s'
Failed to update object '%s': %s
Bad current tag value.
Bad new tag value.
Tried to delete required tag.
Tried to change read-only property.
Parameter count mismatch.
Unknown error.
Metadata modification of object %s not allowed
Metadata modification of object %s being a child of restricted object %s not allowed
Unknown
No media engine found.
MediaEngine.init was not called. Cannot continue.
Bad URI: %s
Failed to probe protocol for URI %s. Assuming '%s'
Invalid number of arguments
ObjectID argument missing
Invalid range
Missing filter
No such container
upnp:createClass value not supported
'Elements' argument missing.
Comments not allowed in XML
Missing ContainerID argument
No objects in DIDL-Lite from client: '%s'
@id must be set to "" in CreateObject call
dc:title must not be empty in CreateObject call
Flags that must not be set were found in 'dlnaManaged'
Invalid upnp:class given in CreateObject
Cannot create restricted item
UPnP class '%s' not supported
Object creation in %s not allowed
Failed to create item under '%s': %s
DLNA profile '%s' not supported
Invalid date format: %s
Invalid date: %s
Cannot create object of class '%s': Not supported
Error from container '%s' on trying to find the newly added child object '%s' in it: %s
'ContainerID' agument missing.
'ObjectID' argument missing.
Failed to create object under '%s': %s
Invalid search criteria given
Failed to search in '%s': %s
No subtitle available
No thumbnailer available: %s
Thumbnailing not supported
No thumbnail available
No D-Bus thumbnailer available
No transcoder available for target format '%s'
Could not create GstElement for URI %s
Failed to create pipeline
Failed to link %s to %s
Failed to link pad %s to %s
Error from pipeline %s: %s
Warning from pipeline %s: %s
Failed to seek to offsets %lld:%lld
Failed to seek
Failed to create GStreamer data source for %s: %s
Could not create a transcoder configuration. Your GStreamer installation might be missing a plug-in
Required element %s missing
Time-based seek not supported
Network Interfaces
Disable transcoding
Disallow upload
Disallow deletion
Comma-separated list of domain:level pairs. See rygel(1) for details
Plugin Path
Engine Path
Disable plugin
Set plugin titles
Set plugin options
Disable UPnP (streaming-only)
Use configuration file instead of user configuration
Shutdown remote Rygel reference
Shutting down remote Rygel instance
Failed to shut-down other rygel instance: %s
Rygel is running in streaming-only mode.
Rygel v%s starting…
Failed to create root device factory: %s
Failed to create RootDevice for %s. Reason: %s
Failed to load user configuration: %s
Failed to load user configuration from file '%s': %s
No value available for '%s'
Value of '%s' out of range
Failed to create preferences dialog: %s
Failed to save configuration data to file '%s': %s
Failed to start Rygel service: %s
Failed to stop Rygel service: %s
Not Found
%%% Object creation in %s not allowed
Enable sharing of media, such as photos, videos and music, with DLNA
Select the network interface that DLNA media will be shared on, or share media on all interfaces
Any
XML node '%s' not found.
LibRygelRenderer
LibRygelServer
Programming with gtkmm 3
Murray
Cumming
Bernhard
Rieder
Chapter on "Timeouts".
Jonathon
Jongsma
Chapter on "Drawing with Cairo".
Chapter on "Working with gtkmm's Source Code".
Chapter on "Recent Files".
Ole
Laursen
Parts of chapter on "Internationalization".
Marko
Anastasov
Chapter on "Printing".
Daniel
Elstner
Section "Build Structure" of chapter on "Wrapping C Libraries with gmmproc".
Chris
Vine
Chapter on "Multi-threaded programs".
David
King
Section on Gtk::Grid.
Pedro
Ferreira
Chapter on Keyboard Events.
Kjell
Ahlstedt
Parts of the update from gtkmm 2 to gtkmm 3.
This book explains key concepts of the gtkmm C++ API for creating user interfaces. It also introduces the main user interface elements ("widgets").
2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
Murray Cumming
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You may obtain a copy of the GNU Free Documentation License from the Free Software Foundation by visiting their Web site or by writing to: Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
Introduction
This book
This book explains key concepts of the gtkmm C++ API for creating user interfaces. It also introduces the main user interface elements ("widgets"). Although it mentions classes, constructors, and methods, it does not go into great detail. Therefore, for full API information you should follow the links into the reference documentation.
This book assumes a good understanding of C++, and how to create C++ programs.
We would very much like to hear of any problems you have learning gtkmm with this document, and would appreciate input regarding improvements. Please see the Contributing section for further information.
gtkmm
gtkmm is a C++ wrapper for GTK+, a library used to create graphical user interfaces. It is licensed using the LGPL license, so you can develop open software, free software, or even commercial non-free software using gtkmm without purchasing licenses.
gtkmm was originally named gtk-- because GTK+ already has a + in the name. However, as -- is not easily indexed by search engines the package generally went by the name gtkmm, and that's what we stuck with.
Why use gtkmm instead of GTK+?
gtkmm allows you to write code using normal C++ techniques such as encapsulation, derivation, and polymorphism. As a C++ programmer you probably already realise that this leads to clearer and better organized code.
gtkmm is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration.
Inheritance can be used to derive new widgets. The derivation of new widgets in GTK+ C code is so complicated and error prone that almost no C coders do it. As a C++ developer you know that derivation is an essential Object Orientated technique.
Member instances can be used, simplifying memory management. All GTK+ C widgets are dealt with by use of pointers. As a C++ coder you know that pointers should be avoided where possible.
gtkmm involves less code compared to GTK+, which uses prefixed function names and lots of cast macros.
gtkmm compared to Qt
Trolltech's Qt is the closest competition to gtkmm, so it deserves discussion.
gtkmm developers tend to prefer gtkmm to Qt because gtkmm does things in a more C++ way. Qt originates from a time when C++ and the standard library were not standardised or well supported by compilers. It therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech modified the C++ language to provide signals, so that Qt classes cannot be used easily with non-Qt classes. gtkmm was able to use standard C++ to provide signals without changing the C++ language. See the FAQ for more detailed differences.
gtkmm is a wrapper
gtkmm is not a native C++ toolkit, but a C++ wrapper of a C toolkit. This separation of interface and implementation has advantages. The gtkmm developers spend most of their time talking about how gtkmm can present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK+ code base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK+ benefits from a broader user base than language-specific toolkits - there are more implementers, more developers, more testers, and more users.
Installation
Dependencies
Before attempting to install gtkmm 3.0, you might first need to install these other packages.
libsigc++ 2.0
GTK+ 3.0
glibmm
cairomm
pangomm
atkmm
These dependencies have their own dependencies, including the following applications and libraries:
pkg-config
glib
ATK
Pango
cairo
gdk-pixbuf
Unix and Linux
Prebuilt Packages
Recent versions of gtkmm are packaged by nearly every major Linux distribution these days. So, if you use Linux, you can probably get started with gtkmm by installing the package from the official repository for your distribution. Distributions that include gtkmm in their repositories include Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and many others.
The names of the gtkmm packages vary from distribution to distribution (e.g. libgtkmm-3.0-dev on Debian and Ubuntu or gtkmm30-devel on Red Hat Fedora), so check with your distribution's package management program for the correct package name and install it like you would any other package.
The package names will not change when new API/ABI-compatible versions of gtkmm are released. Otherwise they would not be API/ABI-compatible. So don't be surprised, for instance, to find gtkmm 3.8 supplied by Debian's libgtkmm-3.0-dev package.
Installing From Source
If your distribution does not provide a pre-built gtkmm package, or if you want to install a different version than the one provided by your distribution, you can also install gtkmm from source. The source code for gtkmm can be downloaded from .
After you've installed all of the dependencies, download the gtkmm source code, unpack it, and change to the newly created directory. gtkmm can be built and installed with the following sequence of commands:
# ./configure # make # make install
Remember that on a Unix or Linux operating system, you will probably need to be root to install software. The su or sudo command will allow you to enter the root password and have root status temporarily.
The configure script will check to make sure all of the required dependencies are already installed. If you are missing any dependencies, it will exit and display an error.
By default, gtkmm will be installed under the /usr/local directory. On some systems you may need to install to a different location. For instance, on Red Hat Linux systems you might use the --prefix option with configure, like so: # ./configure --prefix=/usr
You should be very careful when installing to standard system prefixes such as /usr. Linux distributions install software packages to /usr, so installing a source package to this prefix could corrupt or conflict with software installed using your distribution's package-management system. Ideally, you should use a separate prefix for all software you install from source.
If you want to help develop gtkmm or experiment with new features, you can also install gtkmm from git. Most users will never need to do this, but if you're interested in helping with gtkmm development, see the Working with gtkmm's Source Code appendix.
Microsoft Windows
GTK+ and gtkmm were designed to work well with Microsoft Windows, and the developers encourage its use on the win32 platform. However, Windows has no standard installation system for development libraries. Please see the Windows Installation page for Windows-specific installation instructions and notes.
Basics
This chapter will introduce some of the most important aspects of gtkmm coding. These will be demonstrated with simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information.
Your existing knowledge of C++ will help you with gtkmm as it would with any library. Unless we state otherwise, you can expect gtkmm classes to behave like any other C++ class, and you can expect to use your existing C++ techniques with gtkmm classes.
Simple Example
To begin our introduction to gtkmm, we'll start with the simplest program possible. This program will create an empty 200 x 200 pixel window.
Source Code
We will now explain each line of the example
#include &lt;gtkmm.hgt;
All gtkmm programs must include certain gtkmm headers; gtkmm.h includes the entire gtkmm kit. This is usually not a good idea, because it includes a megabyte or so of headers, but for simple programs, it suffices.
Glib::RefPtrlt;Gtk::Applicationgt; app = Gtk::Application::create(argc, argv, "org.gtkmm.examples.base");
The next statement: creates a Gtk::Application object, stored in a RefPtr smartpointer. This is needed in all gtkmm applications. The create() method for this object initializes gtkmm, and checks the arguments passed to your application on the command line, looking for standard options such as --display. It takes these from the argument list, leaving anything it does not recognize for your application to parse or ignore. This ensures that all gtkmm applications accept the same set of standard arguments.
The next two lines of code create a window and set its default (initial) size:
Gtk::Window window; window.set_default_size(200, 200);
The last line shows the window and enters the gtkmm main processing loop, which will finish when the window is closed. Your main() function will then return with an appropriate success or error code.
return app-gt;run(window);
g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`
After putting the source code in simple.cc you can compile the above program with gcc using: Note that you must surround the pkg-config invocation with backquotes. Backquotes cause the shell to execute the command inside them, and to use the command's output as part of the command line. Note also that simple.cc must come before the pkg-config invocation on the command line.
Headers and Linking
Although we have shown the compilation command for the simple example, you really should use the automake and autoconf tools, as described in "Autoconf, Automake, Libtool", by G. V. Vaughan et al. The examples used in this book are included in the gtkmm-documentation package, with appropriate build files, so we won't show the build commands in future. You'll just need to find the appropriate directory and type make.
To simplify compilation, we use pkg-config, which is present in all (properly installed) gtkmm installations. This program 'knows' what compiler switches are needed to compile programs that use gtkmm. The --cflags option causes pkg-config to output a list of include directories for the compiler to look in; the --libs option requests the list of libraries for the compiler to link with and the directories to find them in. Try running it from your shell-prompt to see the results on your system.
PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.8.0])
However, this is even simpler when using the PKG_CHECK_MODULES() macro in a standard configure.ac file with autoconf and automake. For instance: This checks for the presence of gtkmm and defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile.am files.
gtkmm-3.0 is the name of the current stable API. There was an older API called gtkmm-2-4 which installs in parallel when it is available. There were several versions of gtkmm-2.4, such as gtkmm 2.10 and there are several versions of the gtkmm-3.0 API. Note that the API name does not change for every version because that would be an incompatible API and ABI break. Theoretically, there might be a future gtkmm-4.0 API which would install in parallel with gtkmm-3.0 without affecting existing applications.
Note that if you mention extra modules in addition to gtkmm-3.0, they should be separated by spaces, not commas.
Openismus has more basic help with automake and autoconf.
Widgets
gtkmm applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, widgets are called "controls". For each widget in your application's windows, there is a C++ object in your application's code. So you just need to call a method of the widget's class to affect the visible widget.
m_box.pack_start(m_Button1); m_box.pack_start(m_Button2);
m_frame.add(m_box);
Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container widgets, such as Gtk::Grid, are not visible - they exist only to arrange other widgets. Here is some example code that adds 2 Gtk::Button widgets to a Gtk::Box container widget: and here is how to add the Gtk::Box, containing those buttons, to a Gtk::Frame, which has a visible frame and title:
Most of the chapters in this book deal with specific widgets. See the Container Widgets section for more details about adding widgets to container widgets.
Although you can specify the layout and appearance of windows and widgets with C++ code, you will probably find it more convenient to design your user interfaces with Glade and load them at runtime with Gtk::Builder. See the Glade and Gtk::Builder chapter.
Although gtkmm widget instances have lifetimes and scopes just like those of other C++ classes, gtkmm has an optional time-saving feature that you will see in some of the examples. Gtk::manage() allows you to say that a child widget is owned by the container into which you place it. This allows you to new the widget, add it to the container and forget about deleting it. You can learn more about gtkmm memory management techniques in the Memory Management chapter.
Signals
gtkmm, like most GUI toolkits, is event-driven. When an event occurs, such as the press of a mouse button, the appropriate signal will be emitted by the Widget that was pressed. Each Widget has a different set of signals that it can emit. To make a button click result in an action, we set up a signal handler to catch the button's "clicked" signal.
m_button1.signal_clicked().connect( sigc::mem_fun(*this, &HelloWorld::on_button_clicked) );
gtkmm uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's "clicked" signal with a signal handler called "on_button_clicked":
For more detailed information about signals, see the appendix.
For information about implementing your own signals rather than just connecting to the existing gtkmm signals, see the appendix.
Glib::ustring
You might be surprised to learn that gtkmm doesn't use std::string in its interfaces. Instead it uses Glib::ustring, which is so similar and unobtrusive that you could actually pretend that each Glib::ustring is a std::string and ignore the rest of this section. But read on if you want to use languages other than English in your application.
std::string uses 8 bit per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese. Although the encodings for these languages have now been specified by the Unicode Consortium, the C and C++ languages do not yet provide any standardised Unicode support. GTK+ and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring. It provides almost exactly the same interface as std::string, along with automatic conversions to and from std::string.
One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. std::string will still work for 7-bit ASCII strings. But when you try to localize your application for languages like Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using Glib::ustring instead.
Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting "Grüß Gott" would be "Gr\\xC3\\xBC\\xC3\\x9F Gott").
You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not possible to assume that the next byte is another character. Glib::ustring worries about the details of this for you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes.
Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not result in Unicode executables and libraries which are incompatible with ASCII ones.
Reference
See the Internationalization section for information about providing the UTF-8 string literals.
Intermediate types
Some API related to gtkmm uses intermediate data containers, such as Glib::StringArrayHandle, instead of a specific Standard C++ container such as std::vector or std::list, though gtkmm itself now uses just std::vector since gtkmm 3.0.
Glib::StringArrayHandle or Glib::ArrayHandlelt;Glib::ustringgt;: Use std::vectorlt;Glib::ustringgt;, std::listlt;Glib::ustringgt;, const char*[], etc.
Glib::ListHandlelt;Gtk::Widget*gt;: Use std::vectorlt;Gtk::Widget*gt;, std::listlt;Gtk::Widget*gt;, etc.
Glib::SListHandlelt;Gtk::Widget*gt;: Use std::vectorlt;Gtk::Widget*gt;, std::listlt;Gtk::Widget*gt;, etc.
You should not declare these types yourself. You should instead use whatever Standard C++ container you prefer. glibmm will do the conversion for you. Here are some of these intermediate types:
Mixing C and C++ APIs
You can use C APIs which do not yet have convenient C++ interfaces. It is generally not a problem to use C APIs from C++, and gtkmm helps by providing access to the underlying C object, and providing an easy way to create a C++ wrapper object from a C object, provided that the C API is also based on the GObject system.
To use a gtkmm instance with a C function that requires a C GObject instance, use the gobj() function to obtain a pointer to the underlying GObject instance. For instance
Gtk::Button* button = new Gtk::Button("example"); gtk_button_do_something_new(button-gt;gobj());
To obtain a gtkmm instance from a C GObject instance, use the Glib::wrap() function. For instance
GtkButton* cbutton = get_a_button(); Gtk::Button* button = Glib::wrap(cbutton);
Hello World in gtkmm
We've now learned enough to look at a real example. In accordance with an ancient tradition of computer science, we now introduce Hello World, a la gtkmm:
Try to compile and run it before going on. You should see something like this:
Hello World
Pretty thrilling, eh? Let's examine the code. First, the HelloWorld class:
class HelloWorld : public Gtk::Window { public: HelloWorld(); virtual ~HelloWorld(); protected: //Signal handlers: virtual void on_button_clicked(); //Member widgets: Gtk::Button m_button; };
This class implements the "Hello World" window. It's derived from Gtk::Window, and has a single Gtk::Button as a member. We've chosen to use the constructor to do all of the initialisation work for the window, including setting up the signals. Here it is, with the comments omitted:
HelloWorld::HelloWorld() : m_button ("Hello World") { set_border_width(10); m_button.signal_clicked().connect(sigc::mem_fun(*this, &HelloWorld::on_button_clicked)); add(m_button);. m_button.show(); }
Notice that we've used an initialiser statement to give the m_button object the label "Hello World".
Next we call the Window's set_border_width() method. This sets the amount of space between the sides of the window and the widget it contains.
We then hook up a signal handler to m_button's clicked signal. This prints our friendly greeting to stdout.
Next, we use the Window's add() method to put m_button in the Window. (add() comes from Gtk::Container, which is described in the chapter on container widgets.) The add() method places the Widget in the Window, but it doesn't display the widget. gtkmm widgets are always invisible when you create them - to display them, you must call their show() method, which is what we do in the next line.
Now let's look at our program's main() function. Here it is, without comments:
int main(int argc, char** argv) { Glib::RefPtrlt;Gtk::Applicationgt; app = Gtk::Application::create(argc, argv, "org.gtkmm.example"); HelloWorld helloworld; return app-gt;run(helloworld); }
First we instantiate an object stored in a RefPtr smartpointer called app. This is of type Gtk::Application. Every gtkmm program must have one of these. We pass our command-line arguments to its create() method. It takes the arguments it wants, and leaves you the rest, as we described earlier.
Next we make an object of our HelloWorld class, whose constructor takes no arguments, but it isn't visible yet. When we call Gtk::Application::run(), giving it the helloworld Window, it shows the Window and starts the gtkmmevent loop. During the event loop gtkmm idles, waiting for actions from the user, and responding appropriately. When the user closes the Window, run() will return, causing the final line of our main() function be to executed. The application will then finish.
Changes in gtkmm 3
gtkmm-3.0 is a new version of the gtkmm API that installs in parallel with the older gtkmm-2.4 API. The last version of the gtkmm-2.4 API was gtkmm 2.24. gtkmm 3 has no major fundamental differences to gtkmm 2 but does make several small changes that were not possible while maintaining binary compatibility. If you never used the gtkmm-2.4 API then you can safely ignore this chapter.
gtkmm 3's library is called libgtkmm-3.0 rather than libgtkmm-2.4 and installs its headers in a similarly-versioned directory, so your pkg-config check should ask for gtkmm-3.0 rather than gtkmm-2.4.
gtkmm 3 added some new classes:
Gtk::AppChooser, Gtk::AppChooserButton, Gtk::AppChooserDialog allow the user to select an installed application to open a particular type of content.
Gtk::Grid is a new container widget that will eventually replace Gtk::Box and Gtk::Table. It arranges its children according to properties of those children rather than its own layout details.
Gtk::Switch displays On/Off states more explictly than Gtk::CheckBox. It may be useful, for instance, when allowing users to activate hardware.
gtkmm 3 also made several small changes to the API, which you will probably encounter when porting code that used gtkmm-2.4. Here is a short list:
Gtk::CellLayout, used by Gtk::IconView, Gtk::TreeView::Column and Gtk::ComboBox, now has a Gtk::CellArea which can be used to specify more details of how the CellRenderers are arranged and aligned.
Gtk::ComboBox now derives from CellLayout, allowing easier layout and alignment of its Gtk::CellRenderers.
Gtk::Adjustment and IconSet and Gdk::Cursor are now used via Glib::RefPtr.
Gtk::Box, Gtk::ButtonBox, Gtk::IconView, Gtk::Paned, Gtk::ProgressBar, Gtk::ScaleButton, Gtk::Scrollbar and Gtk::Separator now derive from Gtk::Orientable, allowing their orientation (vertical or horizontal) to be specified without requiring the use of a derived class such as Gtk::HBox.
Gtk::IconView, Gtk::TextView, Gtk::TreeView and other widgets derive from Scrollable instead of having their own methods such as get_vadjustment() and instead of having their own set_scroll_adjustments signal.
Gtk::Style and Gtk::Rc were removed, replaced by Gtk::StyleContext, and Gtk::StyleProviders, such as Gtk::CssProvider.
Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes that cairomm is used for drawing, via the provided Cairo::Context and does not require you to call Cairo::Context::clip().
Gdk::RGBA replaces Color, adding an alpha component for opacity. Colormap was removed, along with its awkward use to allocate colors.
Gdk::Pixmap and Gdk::Bitmap were removed in favour of Gdk::Pixbuf.
Gdk::Drawable was removed, with its methods moving into Gdk::Window.
We now use std::vector in several methods instead of the intermediate *Handle types to make the API clearer.
All deprecated API was removed in gtkmm 3.0, though there will be new deprecations in future versions.
As a first step to porting your source code to gtkmm-3.0 you should probably ensure that your application builds with the deprecated gtkmm-2.4 API disabled, by defining macro such as GTKMM_DISABLE_DEPRECATED. There are some autotools macros that can help with this by defining them optionally at build time. See the gtkmm 3 porting wiki page for more details.
Buttons
gtkmm provides four basic types of buttons:
Push-Buttons
Gtk::Button. Standard buttons, usually marked with a label or picture. Pushing one triggers an action. See the Button section.
Toggle buttons
Gtk::ToggleButton. Unlike a normal Button, which springs back up, a ToggleButton stays down until you press it again. It might be useful as an on/off switch. See the ToggleButton section.
Checkboxes
Gtk::CheckButton. These act like ToggleButtons, but show their state in small squares, with their label at the side. They should be used in most situations which require an on/off setting. See the CheckButton section.
Radio buttons
Gtk::RadioButton. Named after the station selectors on old car radios, these buttons are used in groups for options which are mutually exclusive. Pressing one causes all the others in its group to turn off. They are similar to CheckBoxes (a small widget with a label at the side), but usually look different. See the RadioButton section.
Note that, due to GTK+'s theming system, the appearance of these widgets will vary. In the case of checkboxes and radio buttons, they may vary considerably.
Button
Constructors
There are two ways to create a Button. You can specify a label string in the Gtk::Button constructor, or set it later with set_label().
To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify true for the optional mnemonic parameter. For instance:
Gtk::Button* pButton = new Gtk::Button("_Something", true);
Stock items have been recommended for use in buttons. From gtkmm-3.10 they are deprecated. They should not be used in newly-written code. However, the documentation of namespace Gtk::Stock shows recommended labels and named icons to show in buttons.
Gtk::Button is also a container so you could put any other widget, such as a Gtk::Image into it.
Example
This example creates a button with a picture and a label.
buttons example
The Gtk::Button widget has the following signals, but most of the time you will just handle the clicked signal:
pressed
Emitted when the button is pressed.
released
Emitted when the button is released.
clicked
Emitted when the button is pressed and released.
enter
Emitted when the mouse pointer moves over the button's window.
leave
Emitted when the mouse pointer leaves the button's window.
ToggleButton
ToggleButtons are like normal Buttons, but when clicked they remain activated, or pressed, until clicked again.
To retrieve the state of the ToggleButton, you can use the get_active() method. This returns true if the button is "down". You can also set the toggle button's state, with set_active(). Note that, if you do this, and the state actually changes, it causes the "clicked" signal to be emitted. This is usually what you want.
You can use the toggled() method to toggle the button, rather than forcing it to be up or down: This switches the button's state, and causes the toggled signal to be emitted.
Gtk::ToggleButton is most useful as a base class for the Gtk::CheckButton and Gtk::RadioButton classes.
CheckButton
Gtk::CheckButton inherits from Gtk::ToggleButton. The only real difference between the two is Gtk::CheckButton's appearance. You can check, set, and toggle a checkbox using the same member methods as for Gtk::ToggleButton.
RadioButton
Like checkboxes, radio buttons also inherit from Gtk::ToggleButton, but these work in groups, and only one RadioButton in a group can be selected at any one time.
Groups
There are two ways to set up a group of radio buttons. The first way is to create the buttons, and set up their groups afterwards. Only the first two constructors are used. In the following example, we make a new window class called RadioButtons, and then put three radio buttons in it:
class RadioButtons : public Gtk::Window { public: RadioButtons(); protected: Gtk::RadioButton m_rb1, m_rb2, m_rb3; }; RadioButtons::RadioButtons() : m_rb1("button1"), m_rb2("button2"), m_rb3("button3") { Gtk::RadioButton::Group group = m_rb1.get_group(); m_rb2.set_group(group); m_rb3.set_group(group); }
We told gtkmm to put all three RadioButtons in the same group by obtaining the group with get_group() and using set_group() to tell the other RadioButtons to share that group.
m_rb2.set_group(m_rb1.get_group()); //doesn't work
Note that you can't just do because the group is modified by set_group() and therefore non-const.
The second way to set up radio buttons is to make a group first, and then add radio buttons to it. Here's an example:
class RadioButtons : public Gtk::Window { public: RadioButtons(); }; RadioButtons::RadioButtons() { Gtk::RadioButton::Group group; Gtk::RadioButton *m_rb1 = Gtk::manage( new Gtk::RadioButton(group,"button1")); Gtk::RadioButton *m_rb2 = manage( new Gtk::RadioButton(group,"button2")); Gtk::RadioButton *m_rb3 = manage( new Gtk::RadioButton(group,"button3")); }
We made a new group by simply declaring a variable, group, of type Gtk::RadioButton::Group. Then we made three radio buttons, using a constructor to make each of them part of group.
Methods
RadioButtons are "off" when created; this means that when you first make a group of them, they will all be off. Don't forget to turn one of them on using set_active():
The following example demonstrates the use of RadioButtons:
Range Widgets
Gtk::Scale and Gtk::Scrollbar both inherit from Gtk::Range and share much functionality. They contain a "trough" and a "slider" (sometimes called a "thumbwheel" in other GUI environments). Dragging the slider with the pointer moves it within the trough, while clicking in the trough advances the slider towards the location of the click, either completely, or by a designated amount, depending on which mouse button is used. This should be familiar scrollbar behaviour.
As will be explained in the Adjustment section, all Range widgets are associated with a Adjustment object. To change the lower, upper, and current values used by the widget you need to use the methods of its Adjustment, which you can get with the get_adjustment() method. The Range widgets' default constructors create an Adjustment automatically, or you can specify an existing Adjustment, maybe to share it with another widget. See the Adjustments section for further details.
Scrollbar Widgets
These are standard scrollbars. They should be used only to scroll another widget, such as, a Gtk::Entry, or a Gtk::Viewport, though it's usually easier to use the Gtk::ScrolledWindow widget in most cases.
The orientation of a Gtk::Scrollbar can be either horizontal or vertical.
Scale Widgets
Gtk::Scale widgets (or "sliders") allow the user to visually select and manipulate a value within a specific range. You might use one, for instance, to adjust the magnification level on a zoomed preview of a picture, or to control the brightness of a colour, or to specify the number of minutes of inactivity before a screensaver takes over the screen.
As with Scrollbars, the orientation can be either horizontal or vertical. The default constructor creates an Adjustment with all of its values set to 0.0. This isn't useful so you will need to set some Adjustment details to get meaningful behaviour.
Useful methods
Scale widgets can display their current value as a number next to the trough. By default they show the value, but you can change this with the set_draw_value() method.
The value displayed by a scale widget is rounded to one decimal point by default, as is the value field in its Gtk::Adjustment. You can change this with the set_digits() method.
Also, the value can be drawn in different positions relative to the trough, specified by the set_value_pos() method.
This example displays a window with three range widgets all connected to the same adjustment, along with a couple of controls for adjusting some of the parameters mentioned above and in the section on adjustments, so you can see how they affect the way these widgets work for the user.
Miscellaneous Widgets
Label
Labels are the main method of placing non-editable text in windows, for instance to place a title next to a Entry widget. You can specify the text in the constructor, or later with the set_text() or set_markup() methods.
The width of the label will be adjusted automatically. You can produce multi-line labels by putting line breaks ("\ ") in the label string.
The label text can be justified using the set_justify() method. The widget is also capable of word-wrapping, which can be activated with set_line_wrap().
Gtk::Label support some simple formatting, for instance allowing you to make some text bold, colored, or larger. You can do this by providing a string to set_markup(), using the Pango Markup syntax. For instance, &lt;bgt;bold textlt;/bgt; and &lt;sgt;strikethrough textlt;/sgt; .
Below is a short example to illustrate these functions. This example makes use of the Frame widget to better demonstrate the label styles. (The Frame widget is explained in the Frame section.) It is possible that the first character in m_Label_Normal is shown underlined only when you press the Alt key.
Entry
Simple Use
Entry widgets allow the user to enter text. You can change the contents with the set_text() method, and read the current contents with the get_text() method.
Occasionally you might want to make an Entry widget read-only. This can be done by passing false to the set_editable() method.
For the input of passwords, passphrases and other information you don't want echoed on the screen, calling set_visibility() with false will cause the text to be hidden.
You might want to be notified whenever the user types in a text entry widget. Gtk::Entry provides two signals, activate and changed, for this purpose. activate is emitted when the user presses the Enter key in a text-entry widget; changed is emitted when the text in the widget changes. You can use these, for instance, to validate or filter the text the user types. Moving the keyboard focus to another widget may also signal that the user has finished entering text. The focus_out_event signal that Gtk::Entry inherits from Gtk::Widget can notify you when that happens. The ComboBox with an Entry section contains example programs that use these signals.
If you pass true to the set_activates_default() method, pressing Enter in the Gtk::Entry will activate the default widget for the window containing the Gtk::Entry. This is especially useful in dialog boxes. The default widget is usually one of the dialog buttons, which e.g. will close the dialog box. To set a widget as the default widget, use Gtk::Widget::set_can_default() and Gtk::Widget::grab_default().
Simple Entry Example
This example uses Gtk::Entry. It also has two CheckButtons, with which you can toggle the editable and visible flags.
Entry Completion
A Entry widget can offer a drop-down list of pre-existing choices based on the first few characters typed by the user. For instance, a search dialog could suggest text from previous searches.
To enable this functionality, you must create a EntryCompletion object, and provide it to the Entry widget via the set_completion() method.
The EntryCompletion may use a TreeModel containing possible entries, specified with set_model(). You should then call set_text_column() to specify which of your model columns should be used to match possible text entries.
Alternatively, if a complete list of possible entries would be too large or too inconvenient to generate, a callback slot may instead be specified with set_match_func(). This is also useful if you wish to match on a part of the string other than the start.
Entry Completion Example
This example creates a Gtk::EntryCompletion and associates it with a Gtk::Entry widget. The completion uses a Gtk::TreeModel of possible entries, and some additional actions.
Entry Icons
An Entry widget can show an icon at the start or end of the text area. The icon can be specifed by methods such as set_icon_from_pixbuf() or set_icon_from_icon_name(). An application can respond to the user pressing the icon by handling the signal_icon_press signal.
Entry Icon Example
This example shows a Gtk::Entry widget with a named search icon, and prints text to the terminal when the icon is pressed.
Entry with Icon
Entry Progress
An Entry widget can show a progress bar inside the text area, under the entered text. The progress bar will be shown if the set_progress_fraction() or set_progress_pulse_step() methods are called.
Entry Progress Example
This example shows a Gtk::Entry widget with a progress bar.
Entry with Progress Bar
SpinButton
A SpinButton allows the user to select a value from a range of numeric values. It has an Entry widget with increment and decrement buttons at the side. Clicking the buttons causes the value to 'spin' up and down across the range of possible values. The Entry widget may also be used to enter a value directly.
The value can have an adjustable number of decimal places, and the step size is configurable. SpinButtons have an 'auto-repeat' feature as well: holding down the increment or decrement button can optionally cause the value to change more quickly the longer the button is held down.
value: value for the Spin Button
lower: lower range value
upper: upper range value
step_increment: value to increment/decrement when pressing mouse button 1 on a button
page_increment: value to increment/decrement when pressing mouse button 2 on a button
page_size: unused
SpinButtons use an Adjustment object to hold information about the range of values. These Adjustment attributes are used by the Spin Button like so:
Additionally, mouse button 3 can be used to jump directly to the upper or lower values.
The SpinButton can create a default Adjustment, which you can access via the get_adjustment() method, or you can specify an existing Adjustment in the constructor.
The number of decimal places can be altered using the set_digits() method.
You can set the spinbutton's value using the set_value() method, and retrieve it with get_value().
The spin() method 'spins' the SpinButton, as if its increment or decrement button had been clicked. You need to specify a Gtk::SpinType to specify the direction or new position.
To prevent the user from typing non-numeric characters into the entry box, pass true to the set_numeric() method.
To make the SpinButton 'wrap' between its upper and lower bounds, use the set_wrap() method.
To force it to snap to the nearest step_increment, use set_snap_to_ticks().
Here's an example of a SpinButton in action:
ProgressBar
Progress bars are used to show the status of an ongoing operation. For instance, a ProgressBar can show how much of a task has been completed.
To change the value shown, use the set_fraction() method, passing a double between 0.0 and 1.0 to provide the new percentage.
A ProgressBar is horizontal and left-to-right by default, but you can change it to a vertical progress bar by using the set_orientation() method.
Activity Mode
Besides indicating the amount of progress that has occured, the progress bar can also be used to indicate that there is some activity; this is done by placing the progress bar in activity mode. In this mode, the progress bar displays a small rectangle which moves back and forth. Activity mode is useful in situations where the progress of an operation cannot be calculated as a value range (e.g., receiving a file of unknown length).
To do this, you need to call the pulse() method at regular intervals. You can also choose the step size, with the set_pulse_step() method.
The progress bar can also display a configurable text string within its trough, using the set_text() method.
InfoBar
An InfoBar may show small items of information or ask brief questions. Unlike a Dialog, it appears at the top of the current window instead of opening a new window. Its API is very similar to the Gtk::Dialog API.
Tooltips
Tooltips are the little information windows that pop up when you leave your pointer over a widget for a few seconds. Use set_tooltip_text() to set a text string as a tooltip on any Widget. Gtk::ToolItems are not Widgets, but have the same method for convenience. Gtk::Tooltip is used for more advanced tooltip usage, such as showing an image as well as text.
Widget Reference
Tooltip Reference
Tooltip
Container Widgets
All container widgets derive from Gtk::Container, not always directly. Some container widgets, such as Gtk::Grid can hold many child widgets, so these typically have more complex interfaces. Others, such as Gtk::Frame contain only one child widget.
Single-item Containers
The single-item container widgets derive from Gtk::Bin, which provides the add() and remove() methods for the child widget. Note that Gtk::Button and Gtk::Window are technically single-item containers, but we have discussed them already elsewhere.
We also discuss the Gtk::Paned widget, which allows you to divide a window into two separate "panes". This widget actually contains two child widgets, but the number is fixed so it seems appropriate.
Frame
Frames can enclose one or a group of widgets within a box, optionally with a title. For instance, you might place a group of RadioButtons or CheckButtons in a Frame.
Paned
Panes divide a widget into two halves, separated by a moveable divider. The two halves (panes) can be oriented either horizontally (side by side) or vertically (one above the other).
Unlike the other widgets in this section, pane widgets contain not one but two child widgets, one in each pane. Therefore, you should use add1() and add2() instead of the add() method.
You can adjust the position of the divider using the set_position() method, and you will probably need to do so.
ScrolledWindow
ScrolledWindow widgets create a scrollable area. You can insert any type of widget into a ScrolledWindow window, and it will be accessible regardless of its size by using the scrollbars. Note that ScrolledWindow is not a Gtk::Window despite the slightly misleading name.
Scrolled windows have scrollbar policies which determine whether the Scrollbars will be displayed. The policies can be set with the set_policy() method. The policy may be one of Gtk::POLICY_AUTOMATIC or Gtk::POLICY_ALWAYS. Gtk::POLICY_AUTOMATIC will cause the scrolled window to display the scrollbar only if the contained widget is larger than the visible area. Gtk::POLICY_ALWAYS will cause the scrollbar to be displayed always.
Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react.
AspectFrame
The AspectFrame widget looks like a Frame widget, but it also enforces the aspect ratio (the ratio of the width to the height) of the child widget, adding extra space if necessary. For instance, this would allow you to display a photograph without allowing the user to distort it horizontally or vertically while resizing.
The following program uses a Gtk::AspectFrame to present a drawing area whose aspect ratio will always be 2:1, no matter how the user resizes the top-level window.
Alignment
The Alignment widget allows you to place a widget at a position and size relative to the size of the Alignment widget itself. For instance, it might be used to center a widget.
You need to specify the Alignment's characteristics to the constructor, or to the set() method. In particular, you won't notice much effect unless you specify a number other than 1.0 for the xscale and yscale parameters, because 1.0 simply means that the child widget will expand to fill all available space.
This example right-aligns a button in a window by using an Alignment widget.
See the ProgressBar section for another example that uses an Alignment.
Multiple-item widgets
Multiple-item widgets inherit from Gtk::Container; just as with Gtk::Bin, you use the add() and remove() methods to add and remove contained widgets. Unlike Gtk::Bin::remove(), however, the remove() method for Gtk::Container takes an argument, specifiying which widget to remove.
Packing
You've probably noticed that gtkmm windows seem "elastic" - they can usually be stretched in many different ways. This is due to the widget packing system.
Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:
The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger.
It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager.
Changing the layout of a window "on the fly", to make some extra widgets appear, for instance, is complex. It requires tedious recalculation of every widget's position.
gtkmm uses the packing system to solve these problems. Rather than specifying the position and size of each widget in the window, you can arrange your widgets in rows, columns, and/or grids. gtkmm can size your window automatically, based on the sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets. You can perfect your layout by specifying padding distance and centering values for each of your widgets. gtkmm then uses all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window.
gtkmm arranges widgets hierarchically, using containers. A Container widget contains other widgets. Most gtkmm widgets are containers. Windows, Notebook tabs, and Buttons are all container widgets. There are two flavours of containers: single-child containers, which are all descendants of Gtk::Bin, and multiple-child containers, which are descendants of Gtk::Container. Most widgets in gtkmm are descendants of Gtk::Bin, including Gtk::Window.
Yes, that's correct: a Window can contain at most one widget. How, then, can we use a window for anything useful? By placing a multiple-child container in the window. The most useful container widgets are Gtk::Grid and Gtk::Box.
Gtk::Grid arranges its child widgets in rows and columns. Use attach(), attach_next_to() and add() to insert child widgets.
Gtk::Box arranges its child widgets vertically or horizontally. Use pack_start() and pack_end() to insert child widgets.
There are several other containers, which we will also discuss.
If you've never used a packing toolkit before, it can take some getting used to. You'll probably find, however, that you don't need to rely on visual form editors quite as much as you might with other toolkits.
An improved Hello World
Let's take a look at a slightly improved helloworld, showing what we've learnt.
Hello World 2
After building and running this program, try resizing the window to see the behaviour. Also, try playing with the options to pack_start() while reading the Boxes section.
Boxes
Most packing uses boxes as in the above example. These are invisible containers into which we can pack our widgets. When packing widgets into a horizontal box, the objects are inserted horizontally from left to right or right to left depending on whether pack_start() or pack_end() is used. In a vertical box, widgets are packed from top to bottom or vice versa. You may use any combination of boxes inside or beside other boxes to create the desired effect.
Adding widgets
Per-child packing options
The pack_start() and pack_end() methods place widgets inside these containers. The pack_start() method will start at the top and work its way down in a Box with vertical orientation, or pack left to right in a Box with horizontal orientation. pack_end() will do the opposite, packing from bottom to top or from right to left. Using these methods allows us to right justify or left justify our widgets. We will use pack_start() in most of our examples.
There are several options governing how widgets are to be packed, and this can be confusing at first. If you have difficulties then it is sometimes a good idea to play with the glade GUI designer to see what is possible. You might even decide to use the Gtk::Builder API to load your GUI at runtime.
There are basically five different styles, as shown in this picture:
Box Packing 1
Each line contains one horizontal Box with several buttons. Each of the buttons on a line is packed into the Box with the same arguments to the pack_start() method.
This is the declaration of the pack_start() method:
void pack_start(Gtk::Widgetamp; child, Gtk::PackOptions options = Gtk::PACK_EXPAND_WIDGET, guint padding = 0);
The first argument is the widget you're packing. In our example these are all Buttons.
Gtk::PACK_SHRINK: Space is contracted to the child widget size. The widget will take up just-enough space and never expand.
Gtk::PACK_EXPAND_PADDING: Extra space is filled with padding. The widgets will be spaced out evenly, but their sizes won't change - there will be empty space between the widgets instead.
Gtk::PACK_EXPAND_WIDGET: Extra space is taken up by increasing the child widget size, without changing the amount of space between widgets.
The options argument can take one of these three options:
The padding argument specifies the width of an extra border area to leave around the packed widget.
Per-container packing options
Gtk::Box(Gtk::Orientation orientation = Gtk::ORIENTATION_HORIZONTAL, int spacing = 0); void set_spacing(int spacing); void set_homogeneous(bool homogeneous = true);
Here's the constructor for the Box widget, and methods that set per-container packing options: Passing true to set_homogeneous() will cause all of the contained widgets to be the same size. spacing is a (minimum) number of pixels to leave between each widget.
What's the difference between spacing (set when the box is created) and padding (set when elements are packed)? Spacing is added between objects, and padding is added on either side of a widget. The following figure should make it clearer:
Box Packing 2
Gtk::Application and command-line options
The following example program requires a command-line option. The source code shows two ways of handling command-line options in combination with Gtk::Application.
Handle the options in main() and hide them from Gtk::Application by setting argc = 1 in the call to Gtk::Application::create().
Give all command-line options to Gtk::Application::create() and add the flag Gio::APPLICATION_HANDLES_COMMAND_LINE. Connect a signal handler to the command_line signal, and handle the command-line options in the signal handler.
You must set the optional parameter after = false in the call to signal_command_line().connect(), because your signal handler must be called before the default signal handler. You must also call Gio::Application::activate() in the signal handler, unless you want your application to exit without showing its main window. (Gio::Application is a base class of Gtk::Application.)
Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use.
ButtonBoxes
Button boxes are a convenient way to quickly arrange a group of buttons. Their orientation can be either horizontal or vertical.
ButtonBoxes help to make applications appear consistent because they use standard settings, such as inter-button spacing and packing.
Buttons are added to a ButtonBox with the add() method.
Button boxes support several layout styles. The style can be retrieved and changed using get_layout() and set_layout().
ButtonBox
Grid
A Grid dynamically lays out child widgets in rows and columns. The dimensions of the grid do not need to be specified in the constructor.
Child widgets can span multiple rows or columns, using attach(), or added next to an existing widget inside the grid with attach_next_to(). Individual rows and columns of the grid can be set to have uniform height or width with set_row_homogeneous() and set_column_homogeneous().
You can set the margin and expand properties of the child Widgets to control their spacing and their behaviour when the Grid is resized.
This example creates a window with three buttons in a grid. The first two buttons are in the upper row, from left to right. A third button is attached underneath the first button, in a new lower row, spanning two columns.
Table
Gtk::Table allows us to place widgets in a grid, similar to Gtk::Grid.
Gtk::Table is deprecated from gtkmm version 3.4 and should not be used in newly-written code. Use Gtk::Grid instead.
Notebook
A Notebook has a set of stacked pages, each of which contains widgets. Labelled tabs allow the user to select the pages. Notebooks allow several sets of widgets to be placed in a small space, by only showing one page at a time. For instance, they are often used in preferences dialogs.
Use the append_page(), prepend_page() and insert_page() methods to add tabbed pages to the Notebook, supplying the child widget and the name for the tab.
To discover the currently visible page, use the get_current_page() method. This returns the page number, and then calling get_nth_page() with that number will give you a pointer to the actual child widget.
To programmatically change the selected page, use the set_current_page() method.
Assistant
An Assistant splits a complex operation into steps. Each step is a page, containing a header, a child widget and an action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with set_page_type().
Use the append_page(), prepend_page and insert_page() methods to add pages to the Assistant, supplying the child widget for each page.
To determine the currently-visible page, use the get_current_page() method, and pass the result to get_nth_page(), which returns a pointer to the actual widget. To programmatically change the current page, use the set_current_page() method.
To set the title of a page, use the set_page_title() method. The header and side images of a page can be set with the set_page_header_image() and set_page_side_image() methods.
To add widgets to the action area, use the add_action_widget() method. They will be packed alongside the default buttons. Use the remove_action_widget() method to remove widgets.
The TreeView widget
The Gtk::TreeView widget can contain lists or trees of data, in columns.
The Model
Each Gtk::TreeView has an associated Gtk::TreeModel, which contains the data displayed by the TreeView. Each Gtk::TreeModel can be used by more than one Gtk::TreeView. For instance, this allows the same underlying data to be displayed and edited in 2 different ways at the same time. Or the 2 Views might display different columns from the same Model data, in the same way that 2 SQL queries (or "views") might show different fields from the same database table.
Although you can theoretically implement your own Model, you will normally use either the ListStore or TreeStore model classes.
ListStore, for rows
The ListStore contains simple rows of data, and each row has no children.
TreeView - ListStore
TreeStore, for a hierarchy
The TreeStore contains rows of data, and each row may have child rows.
TreeView - TreeStore
Model Columns
The TreeModelColumnRecord class is used to keep track of the columns and their data types. You add TreeModelColumn instances to the ColumnRecord and then use those TreeModelColumns when getting and setting the data in model rows. You will probably find it convenient to derive a new TreeModelColumnRecord which has your TreeModelColumn instances as member data.
class ModelColumns : public Gtk::TreeModelColumnRecord { public: ModelColumns() { add(m_col_text); add(m_col_number); } Gtk::TreeModelColumnlt;Glib::ustringgt; m_col_text; Gtk::TreeModelColumnlt;intgt; m_col_number; }; ModelColumns m_Columns;
You specify the ColumnRecord when creating the Model, like so:
Glib::RefPtrlt;Gtk::ListStoregt; refListStore = Gtk::ListStore::create(m_Columns);
Note that the instance (such as m_Columns here) should usually not be static, because it often needs to be instantiated after glibmm has been instantiated.
Adding Rows
Add rows to the model with the append(), prepend(), or insert() methods.
Gtk::TreeModel::iterator iter = m_refListStore-gt;append();
You can dereference the iterator to get the Row:
Gtk::TreeModel::Row row = *iter;
Adding child rows
Gtk::TreeStore models can have child items. Add them with the append(), prepend(), or insert() methods, like so:
Gtk::TreeModel::iterator iter_child = m_refTreeStore-gt;append(row.children());
Setting values
You can use the operator[] override to set the data for a particular column in the row, specifying the TreeModelColumn used to create the model.
row[m_Columns.m_col_text] = "sometext";
Getting values
You can use the operator[] override to get the data in a particular column in a row, specifiying the TreeModelColumn used to create the model.
Glib::ustring strText = row[m_Columns.m_col_text]; int number = row[m_Columns.m_col_number];
The compiler will complain if you use an inappropriate type. For instance, this would generate a compiler error:
//compiler error - no conversion from ustring to int. int number = row[m_Columns.m_col_text];
"Hidden" Columns
You might want to associate extra data with each row. If so, just add it as a Model column, but don't add it to the View.
The View
The View is the actual widget (Gtk::TreeView) that displays the model (Gtk::TreeModel) data and allows the user to interact with it. The View can show all of the model's columns, or just some, and it can show them in various ways.
Using a Model
You can specify a Gtk::TreeModel when constructing the Gtk::TreeView, or you can use the set_model() method, like so:
m_TreeView.set_model(m_refListStore);
Adding View Columns
You can use the append_column() method to tell the View that it should display certain Model columns, in a certain order, with a certain column title.
m_TreeView.append_column("Messages", m_Columns.m_col_text);
When using this simple append_column() override, the TreeView will display the model data with an appropriate CellRenderer. For instance, strings and numbers are shown in a simple Gtk::Entry widget, and booleans are shown in a Gtk::CheckButton. This is usually what you need. For other column types you must either connect a callback that converts your type into a string representation, with TreeViewColumn::set_cell_data_func(), or derive a custom CellRenderer. Note that (unsigned) short is not supported by default - You could use (unsigned) int or (unsigned) long as the column type instead.
More than one Model Column per View Column
To render more than one model column in a view column, you need to create the TreeView::Column widget manually, and use pack_start() to add the model columns to it.
Then use append_column() to add the view Column to the View. Notice that Gtk::TreeView::append_column() is overridden to accept either a prebuilt Gtk::TreeView::Column widget, or just the TreeModelColumn from which it generates an appropriate Gtk::TreeView::Column widget.
Here is some example code from gtkmm/demos/gtk-demo/example_icontheme.cc, which has a pixbuf icon and a text name in the same column:
Gtk::TreeView::Column* pColumn = Gtk::manage(new Gtk::TreeView::Column("Icon Name")); // m_columns.icon and m_columns.iconname are columns in the model. // pColumn is the column in the TreeView: pColumn-gt;pack_start(m_columns.icon, /* expand= */ false); pColumn-gt;pack_start(m_columns.iconname); m_TreeView.append_column(*pColumn);
Specifying CellRenderer details
The default CellRenderers and their default behaviour will normally suffice, but you might occasionally need finer control. For instance, this example code from gtkmm/demos/gtk-demo/example_treeview_treestore.cc, appends a Gtk::CellRenderer widget and instructs it to render the data from various model columns through various aspects of its appearance.
int cols_count = m_TreeView.append_column_editable("Alex", m_columns.alex); Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1); if(pColumn) { Gtk::CellRendererToggle* pRenderer = static_castlt;Gtk::CellRendererToggle*gt;(pColumn-gt;get_first_cell()); pColumn-gt;add_attribute(pRenderer-gt;property_visible(), m_columns.visible); pColumn-gt;add_attribute(pRenderer-gt;property_activatable(), m_columns.world);
You can also connect to CellRenderer signals to detect user actions. For instance:
Gtk::CellRendererToggle* pRenderer = Gtk::manage( new Gtk::CellRendererToggle() ); pRenderer-gt;signal_toggled().connect( sigc::bind( sigc::mem_fun(*this, &Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave) );
Editable Cells
Automatically-stored editable cells.
Cells in a TreeView can be edited in-place by the user. To allow this, use the Gtk::TreeViewinsert_column_editable() and append_column_editable() methods instead of insert_column() and append_column(). When these cells are edited the new values will be stored immediately in the Model. Note that these methods are templates which can only be instantiated for simple column types such as Glib::ustring, int, and long.
Implementing custom logic for editable cells.
However, you might not want the new values to be stored immediately. For instance, maybe you want to restrict the input to certain characters or ranges of values.
To achieve this, you should use the normal Gtk::TreeViewinsert_column() and append_column() methods, then use get_column_cell_renderer() to get the Gtk::CellRenderer used by that column.
You should then cast that Gtk::CellRenderer* to the specific CellRenderer that you expect, so you can use specific API.
For instance, for a CellRendererText, you would set the cell's editable property to true, like so:
cell.property_editable() = true;
For a CellRendererToggle, you would set the activatable property instead.
You can then connect to the appropriate "edited" signal. For instance, connect to Gtk::CellRendererText::signal_edited(), or Gtk::CellRendererToggle::signal_toggled(). If the column contains more than one CellRenderer then you will need to use Gtk::TreeView::get_column() and then call get_cell_renderers() on that view Column.
In your signal handler, you should examine the new value and then store it in the Model if that is appropriate for your application.
Iterating over Model Rows
Gtk::TreeModel provides a C++ Standard Library-style container of its children, via the children() method. You can use the familiar begin() and end() methods iterator incrementing, like so:
typedef Gtk::TreeModel::Children type_children; //minimise code length. type_children children = refModel-gt;children(); for(type_children::iterator iter = children.begin(); iter != children.end(); ++iter) { Gtk::TreeModel::Row row = *iter; //Do something with the row - see above for set/get. }
Row children
Gtk::TreeModel::Children children = row.children();
When using a Gtk::TreeStore, the rows can have child rows, which can have their own children in turn. Use Gtk::TreeModel::Row::children() to get the container of child Rows:
The Selection
To find out what rows the user has selected, get the Gtk::TreeView::Selection object from the TreeView, like so:
Glib::RefPtrlt;Gtk::TreeSelectiongt; refTreeSelection = m_TreeView.get_selection();
Single or multiple selection
refTreeSelection-gt;set_mode(Gtk::SELECTION_MULTIPLE);
By default, only single rows can be selected, but you can allow multiple selection by setting the mode, like so:
The selected rows
For single-selection, you can just call get_selected(), like so:
TreeModel::iterator iter = refTreeSelection-gt;get_selected(); if(iter) //If anything is selected { TreeModel::Row row = *iter; //Do something with the row. }
For multiple-selection, you need to define a callback, and give it to selected_foreach(), selected_foreach_path(), or selected_foreach_iter(), like so:
refTreeSelection-gt;selected_foreach_iter( sigc::mem_fun(*this, &TheClass::selected_row_callback) ); void TheClass::selected_row_callback( const Gtk::TreeModel::iteratoramp; iter) { TreeModel::Row row = *iter; //Do something with the row. }
The "changed" signal
To respond to the user clicking on a row or range of rows, connect to the signal like so:
refTreeSelection-gt;signal_changed().connect( sigc::mem_fun(*this, &Example_IconTheme::on_selection_changed) );
Preventing row selection
Maybe the user should not be able to select every item in your list or tree. For instance, in the gtk-demo, you can select a demo to see the source code, but it doesn't make any sense to select a demo category.
To control which rows can be selected, use the set_select_function() method, providing a sigc::slot callback. For instance:
m_refTreeSelection-gt;set_select_function( sigc::mem_fun(*this, &DemoWindow::select_function) );
and then
bool DemoWindow::select_function( const Glib::RefPtrlt;Gtk::TreeModelgt;amp; model, const Gtk::TreeModel::Pathamp; path, bool) { const Gtk::TreeModel::iterator iter = model-gt;get_iter(path); return iter-gt;children().empty(); // only allow leaf nodes to be selected }
Changing the selection
To change the selection, specify a Gtk::TreeModel::iterator or Gtk::TreeModel::Row, like so:
Gtk::TreeModel::Row row = m_refModel-gt;children()[5]; //The fifth row. if(row) refTreeSelection-gt;select(row);
or
Gtk::TreeModel::iterator iter = m_refModel-gt;children().begin() if(iter) refTreeSelection-gt;select(iter);
Sorting
The standard tree models (TreeStore and ListStore) derive from TreeSortable, so they offer sorting functionality. For instance, call set_sort_column(), to sort the model by the specified column. Or supply a callback function to set_sort_func() to implement a more complicated sorting algorithm.
TreeSortable Reference
Sorting by clicking on columns
So that a user can click on a TreeView's column header to sort the TreeView's contents, call Gtk::TreeView::Column::set_sort_column(), supplying the model column on which model should be sorted when the header is clicked. For instance:
Gtk::TreeView::Column* pColumn = treeview.get_column(0); if(pColumn) pColumn-gt;set_sort_column(m_columns.m_col_id);
Independently sorted views of the same model
The TreeView already allows you to show the same TreeModel in two TreeView widgets. If you need one of these TreeViews to sort the model differently than the other then you should use a TreeModelSort instead of just, for instance, Gtk::TreeViewModel::set_sort_column(). TreeModelSort is a model that contains another model, presenting a sorted version of that model. For instance, you might add a sorted version of a model to a TreeView like so:
Glib::RefPtrlt;Gtk::TreeModelSortgt; sorted_model = Gtk::TreeModelSort::create(model); sorted_model-gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING); treeview.set_model(sorted_model);
Note, however, that the TreeView will provide iterators to the sorted model. You must convert them to iterators to the underlying child model in order to perform actions on that model. For instance:
void ExampleWindow::on_button_delete() { Glib::RefPtrlt;Gtk::TreeSelectiongt; refTreeSelection = m_treeview.get_selection(); if(refTreeSelection) { Gtk::TreeModel::iterator sorted_iter = m_refTreeSelection-gt;get_selected(); if(sorted_iter) { Gtk::TreeModel::iterator iter = m_refModelSort-gt;convert_iter_to_child_iter(sorted_iter); m_refModel-gt;erase(iter); } } }
TreeModelSort Reference
Drag and Drop
Gtk::TreeView already implements simple drag-and-drop when used with the Gtk::ListStore or Gtk::TreeStore models. If necessary, it also allows you to implement more complex behaviour when items are dragged and dropped, using the normal Drag and Drop API.
Reorderable rows
If you call Gtk::TreeView::set_reorderable() then your TreeView's items can be moved within the treeview itself. This is demonstrated in the TreeStore example.
However, this does not allow you any control of which items can be dragged, and where they can be dropped. If you need that extra control then you might create a derived Gtk::TreeModel from Gtk::TreeStore or Gtk::ListStore and override the Gtk::TreeDragSource::row_draggable() and Gdk::TreeDragDest::row_drop_possible() virtual methods. You can examine the Gtk::TreeModel::Paths provided and allow or disallow dragging or dropping by returning true or false.
This is demonstrated in the drag_and_drop example.
Popup Context Menu
Lots of people need to implement right-click context menus for TreeView's so we will explain how to do that here to save you some time. Apart from one or two points, it's much the same as a normal context menu, as described in the menus chapter.
Handling button_press_event
To detect a click of the right mouse button, you need to handle the button_press_event signal, and check exactly which button was pressed. Because the TreeView normally handles this signal completely, you need to either override the default signal handler in a derived TreeView class, or use connect_notify() instead of connect(). You probably also want to call the default handler before doing anything else, so that the right-click will cause the row to be selected first.
This is demonstrated in the Popup Context Menu example.
Examples
ListStore
This example has a Gtk::TreeView widget, with a Gtk::ListStore model.
TreeStore
This example is very similar to the ListStore example, but uses a Gtk::TreeStore model instead, and adds children to the rows.
This example is identical to the ListStore example, but it uses TreeView::append_column_editable() instead of TreeView::append_column().
TreeView - Editable Cells
This example is much like the TreeStore example, but has 2 extra columns to indicate whether the row can be dragged, and whether it can receive drag-and-dropped rows. It uses a derived Gtk::TreeStore which overrides the virtual functions as described in the TreeView Drag and Drop section.
TreeView - Drag And Drop
This example is much like the ListStore example, but derives a custom TreeView in order to override the button_press_event, and also to encapsulate the tree model code in our derived class. See the TreeView Popup Context Menu section.
TreeView - Popup Context Menu
Combo Boxes
The ComboBox widget offers a list (or tree) of choices in a dropdown menu. If appropriate, it can show extra information about each item, such as text, a picture, a checkbox, or a progress bar. The ComboBox widget usually restricts the user to the available choices, but it can optionally have an Entry, allowing the user to enter arbitrary text if none of the available choices are suitable.
The list is provided via a TreeModel, and columns from this model are added to the ComboBox's view with the ComboBox::pack_start() method. This provides flexibility and compile-time type-safety, but the ComboBoxText class provides a simpler text-based specialization in case that flexibility is not required.
The model
The model for a ComboBox can be defined and filled exactly as for a TreeView. For instance, you might derive a ComboBox class with one integer and one text column, like so:
ModelColumns() { add(m_col_id); add(m_col_name); } Gtk::TreeModelColumnlt;intgt; m_col_id; Gtk::TreeModelColumnlt;Glib::ustringgt; m_col_name; }; ModelColumns m_columns;
After appending rows to this model, you should provide the model to the ComboBox with the set_model() method. Then use the pack_start() or pack_end() methods to specify what columns will be displayed in the ComboBox. As with the TreeView you may either use the default cell renderer by passing the TreeModelColumn to the pack methods, or you may instantiate a specific CellRenderer and specify a particular mapping with either add_attribute() or set_cell_data_func(). Note that these methods are in the CellLayout base class.
The chosen item
To discover what item, if any, the user has chosen from the ComboBox, call ComboBox::get_active(). This returns a TreeModel::iterator that you can dereference to a Row in order to read the values in your columns. For instance, you might read an integer ID value from the model, even though you have chosen only to show the human-readable description in the ComboBox. For instance:
Gtk::TreeModel::iterator iter = m_Combo.get_active(); if(iter) { Gtk::TreeModel::Row row = *iter; //Get the data for the selected row, using our knowledge //of the tree model: int id = row[m_Columns.m_col_id]; set_something_id_chosen(id); //Your own function. } else set_nothing_chosen(); //Your own function.
Responding to changes
You might need to react to every change of selection in the ComboBox, for instance to update other widgets. To do so, you should handle the changed signal. For instance:
m_combo.signal_changed().connect( sigc::mem_fun(*this, &ExampleWindow::on_combo_changed) );
Full Example
ComboBox
Simple Text Example
ComboBoxText
ComboBox with an Entry
A ComboBox may contain an Entry widget for entering of arbitrary text, by specifying true for the constructor's has_entry parameter.
The text column
m_combo.set_entry_text_column(m_columns.m_col_name);
So that the Entry can interact with the drop-down list of choices, you must specify which of your model columns is the text column, with set_entry_text_column(). For instance:
When you select a choice from the drop-down menu, the value from this column will be placed in the Entry.
The entry
Because the user may enter arbitrary text, an active model row isn't enough to tell us what text the user has entered. Therefore, you should retrieve the Entry widget with the ComboBox::get_entry() method and call get_text() on that.
Gtk::Entry* entry = m_Combo.get_entry(); if (entry) { // The Entry shall receive focus-out events. entry-gt;add_events(Gdk::FOCUS_CHANGE_MASK); // Alternatively you can connect to m_Combo.signal_changed(). entry-gt;signal_changed().connect(sigc::mem_fun(*this, &ExampleWindow::on_entry_changed) ); entry-gt;signal_activate().connect(sigc::mem_fun(*this, &ExampleWindow::on_entry_activate) ); entry-gt;signal_focus_out_event().connect(sigc::mem_fun(*this, &ExampleWindow::on_entry_focus_out_event) ); }
When the user enters arbitrary text, it may not be enough to connect to the changed signal, which is emitted for every typed character. It is not emitted when the user presses the Enter key. Pressing the Enter key or moving the keyboard focus to another widget may signal that the user has finished entering text. To be notified of these events, connect to the Entry's activate and focus_out_event signals, like so The changed signals of ComboBox and Entry are both emitted for every change. It doesn't matter which one you connect to. But only Entry's focus_out_event signal is useful here.
X events are described in more detail in the X Event signals section in the appendix.
ComboBox with Entry
ComboBoxText with Entry
TextView
The TextView widget can be used to display and edit large amounts of formatted text. Like the TreeView, it has a model/view design. In this case the TextBuffer is the model.
The Buffer
Gtk::TextBuffer is a model containing the data for the Gtk::TextView, like the Gtk::TreeModel used by Gtk::TreeView. This allows two or more Gtk::TextViews to share the same TextBuffer, and allows those TextBuffers to be displayed slightly differently. Or you could maintain several Gtk::TextBuffers and choose to display each one at different times in the same Gtk::TextView widget.
The TextView creates its own default TextBuffer, which you can access via the get_buffer() method.
Iterators
Tags and Formatting
Tags
To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text. For instance, to define the tag and its properties:
Glib::RefPtrlt;Gtk::TextBuffer::Taggt; refTagMatch = Gtk::TextBuffer::Tag::create(); refTagMatch-gt;property_background() = "orange";
You can specify a name for the Tag when using the create() method, but it is not necessary.
The Tag class has many other properties.
TagTable
Each Gtk::TextBuffer uses a Gtk::TextBuffer::TagTable, which contains the Tags for that buffer. 2 or more TextBuffers may share the same TagTable. When you create Tags you should add them to the TagTable. For instance:
Glib::RefPtrlt;Gtk::TextBuffer::TagTablegt; refTagTable = Gtk::TextBuffer::TagTable::create(); refTagTable-gt;add(refTagMatch); //Hopefully a future version of gtkmm will have a set_tag_table() method, //for use after creation of the buffer. Glib::RefPtrlt;Gtk::TextBuffergt; refBuffer = Gtk::TextBuffer::create(refTagTable);
You can also use get_tag_table() to get, and maybe modify, the TextBuffer's default TagTable instead of creating one explicitly.
Applying Tags
If you have created a Tag and added it to the TagTable, you may apply that tag to part of the TextBuffer so that some of the text is displayed with that formatting. You define the start and end of the range of text by specifying Gtk::TextBuffer::iterators. For instance:
refBuffer-gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);
refBuffer-gt;insert_with_tag(iter, "Some text", refTagMatch);
Or you could specify the tag when first inserting the text:
You can apply more than one Tag to the same text, by using apply_tag() more than once, or by using insert_with_tags(). The Tags might specify different values for the same properties, but you can resolve these conflicts by using Tag::set_priority().
Marks
TextBuffer iterators are generally invalidated when the text changes, but you can use a Gtk::TextBuffer::Mark to remember a position in these situations. For instance,
Glib::RefPtrlt;Gtk::TextBuffer::Markgt; refMark = refBuffer-gt;create_mark(iter);
You can then use the get_iter() method later to create an iterator for the Mark's new position.
There are two built-in Marks - insert and selection_bound, which you can access with TextBuffer's get_insert() and get_selection_bound() methods.
As mentioned above, each TextView has a TextBuffer, and one or more TextViews can share the same TextBuffer.
Like the TreeView, you should probably put your TextView inside a ScrolledWindow to allow the user to see and move around the whole text area with scrollbars.
Default formatting
TextView has various methods which allow you to change the presentation of the buffer for this particular view. Some of these may be overridden by the Gtk::TextTags in the buffer, if they specify the same things. For instance, set_left_margin(), set_right_margin(), set_indent(), etc.
Scrolling
Gtk::TextView has various scroll_to_*() methods. These allow you to ensure that a particular part of the text buffer is visible. For instance, your application's Find feature might use Gtk::TextView::scroll_to_iter() to show the found text.
Widgets and ChildAnchors
You can embed widgets, such as Gtk::Buttons, in the text. Each such child widget needs a ChildAnchor. ChildAnchors are associated with iterators. For instance, to create a child anchor at a particular position, use Gtk::TextBuffer::create_child_anchor():
Glib::RefPtrlt;Gtk::TextChildAnchorgt; refAnchor = refBuffer-gt;create_child_anchor(iter);
Then, to add a widget at that position, use Gtk::TextView::add_child_at_anchor():
m_TextView.add_child_at_anchor(m_Button, refAnchor);
Menus and Toolbars
There are specific APIs for Menus and toolbars, but you should usually deal with them together, using the UIManager to define Actions which you can then arrange in menus and toolbars. In this way you can handle activation of the action instead of responding to the menu and toolbar items separately. And you can enable or disable both the menu and toolbar item via the action.
This involves the use of the Gtk::ActionGroup, Gtk::Action, and UIManager classes, all of which should be instantiated via their create() methods, which return RefPtrs.
Actions
First create the Actions and add them to an ActionGroup, with ActionGroup::add().
The arguments to Action::create() specify the action's name and how it will appear in menus and toolbars.
You can also specify a signal handler when calling ActionGroup::add(). This signal handler will be called when the action is activated via either a menu item or a toolbar button.
Note that you must specify actions for sub menus as well as menu items.
For instance:
m_refActionGroup = Gtk::ActionGroup::create(); m_refActionGroup-gt;add( Gtk::Action::create("MenuFile", "_File") ); m_refActionGroup-gt;add( Gtk::Action::create("New", "_New"), sigc::mem_fun(*this, &ExampleWindow::on_action_file_new) ); m_refActionGroup-gt;add( Gtk::Action::create("ExportData", "Export Data"), sigc::mem_fun(*this, &ExampleWindow::on_action_file_open) ); m_refActionGroup-gt;add( Gtk::Action::create("Quit", "_Quit"), sigc::mem_fun(*this, &ExampleWindow::on_action_file_quit) );
Note that this is where we specify the names of the actions as they will be seen by users in menus and toolbars. Therefore, this is where you should make strings translatable, by putting them inside the _() macro.
UIManager
Next you should create a UIManager and add the ActionGroup to the UIManager with insert_action_group() At this point is also a good idea to tell the parent window to respond to the specified keyboard shortcuts, by using add_accel_group().
For instance,
Glib::RefPtrlt;Gtk::UIManagergt; m_refUIManager = Gtk::UIManager::create(); m_refUIManager-gt;insert_action_group(m_refActionGroup); add_accel_group(m_refUIManager-gt;get_accel_group());
Then, you can define the actual visible layout of the menus and toolbars, and add the UI layout to the UIManager. This "ui string" uses an XML format, in which you should mention the names of the actions that you have already created. For instance:
Glib::ustring ui_info = "lt;uigt;" " &lt;menubar name='MenuBar'gt;" " &lt;menu action='MenuFile'gt;" " &lt;menuitem action='New'/gt;" " &lt;menuitem action='Open'/gt;" " &lt;separator/gt;" " &lt;menuitem action='Quit'/gt;" " &lt;/menugt;" " &lt;menu action='MenuEdit'gt;" " &lt;menuitem action='Cut'/gt;" " &lt;menuitem action='Copy'/gt;" " &lt;menuitem action='Paste'/gt;" " &lt;/menugt;" " &lt;/menubargt;" " &lt;toolbar name='ToolBar'gt;" " &lt;toolitem action='Open'/gt;" " &lt;toolitem action='Quit'/gt;" " &lt;/toolbargt;" "lt;/uigt;"; m_refUIManager-gt;add_ui_from_string(ui_info);
Remember that these names are just the identifiers that we used when creating the actions. They are not the text that the user will see in the menus and toolbars. We provided those human-readable names when we created the actions.
To instantiate a Gtk::MenuBar or Gtk::Toolbar which you can actually show, you should use the UIManager::get_widget() method, and then add the widget to a container. For instance:
Gtk::Widget* pMenubar = m_refUIManager-gt;get_widget("/MenuBar"); pBox-gt;add(*pMenuBar, Gtk::PACK_SHRINK);
Popup Menus
Menus are normally just added to a window, but they can also be displayed temporarily as the result of a mouse button click. For instance, a context menu might be displayed when the user clicks their right mouse button.
The UI layout for a popup menu should use the popup node. For instance:
Glib::ustring ui_info = "lt;uigt;" " &lt;popup name='PopupMenu'gt;" " &lt;menuitem action='ContextEdit'/gt;" " &lt;menuitem action='ContextProcess'/gt;" " &lt;menuitem action='ContextRemove'/gt;" " &lt;/popupgt;" "lt;/uigt;"; m_refUIManager-gt;add_ui_from_string(ui_info);
To show the popup menu, use Gtk::Menu's popup() method, providing the button identifier and the time of activation, as provided by the button_press_event signal, which you will need to handle anyway. For instance:
bool ExampleWindow::on_button_press_event(GdkEventButton* event) { if( (event-gt;type == GDK_BUTTON_PRESS) &amp; (event-gt;button == 3) ) { m_Menu_Popup-gt;popup(event-gt;button, event-gt;time); return true; //It has been handled. } else return false; }
Main Menu example
Main Menu
Popup Menu example
Popup Menu
ToolPalette
A ToolPalette is similar to a Toolbar but can contain a grid of items, categorized into groups. The user may hide or expand each group. As in a toolbar, the items may be displayed as only icons, as only text, or as icons with text.
The ToolPalette's items might be dragged or simply activated. For instance, the user might drag objects to a canvas to create new items there. Or the user might click an item to activate a certain brush size in a drawing application.
ToolItemGroups should be added to the tool palette via the base class's Gtk::Container::add() method, for instance like so:
Gtk::ToolItemGroup* group_brushes = Gtk::manage(new Gtk::ToolItemGroup("Brushes")); m_ToolPalette.add(*group_brushes);
Gtk::ToolItems can then be added to the group. For instance, like so:
Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, "Big")); button-gt;set_tooltip_text("Big Brush); group_brushes-gt;insert(*button);
You might then handle the ToolButton's clicked signal. Alternatively, you could allow the item to be dragged to another widget, by calling Gtk::ToolPalette::add_drag_dest() and then using Gtk::ToolPalette::get_drag_item() in the other widget's drag_data_received signal handler.
ToolPalette Reference
ToolItemGroup Reference
ToolItem Reference
Call add_drag_dest() to allow items or groups to be dragged from the tool palette to a particular destination widget. You can then use get_drag_item() to discover which ToolItem or ToolItemGroup is being dragged. You can use dynamic_cast to discover whether it is an item or a group. For instance, you might use this in your drag_data_received signal handler, to add a dropped item, or to show a suitable icon while dragging.
See the Drag and Drop chapter for general advice about Drag and Drop with gtkmm.
ToolPalette Example
This example adds a ToolPalette and a DrawingArea to a window and allows the user to drag icons from the tool palette to the drawing area. The tool palette contains several groups of items. The combo boxes allow the user to change the style and orientation of the tool palette.
Adjustments
gtkmm has various widgets that can be visually adjusted using the mouse or the keyboard, such as the Range widgets (described in the Range Widgets section). There are also a few widgets that display some adjustable part of a larger area, such as the Viewport widget. These widgets have Gtk::Adjustment objects that express this common part of their API.
So that applications can react to changes, for instance when a user moves a scrollbar, Gtk::Adjustment has a value_changed signal. You can then use the get_value() method to discover the new value.
Creating an Adjustment
The Gtk::Adjustment is created by its create() method which is as follows:
Glib::RefPtrlt;Gtk::Adjustmentgt; Gtk::Adjustment::create( double value, double lower, double upper, double step_increment = 1, double page_increment = 10, double page_size = 0);
The value argument is the initial value of the adjustment, usually corresponding to the topmost or leftmost position of an adjustable widget. The lower and upper arguments specify the possible range of values which the adjustment can hold. The step_increment argument specifies the smaller of the two increments by which the user can change the value, while the page_increment is the larger one. The page_size argument usually corresponds somehow to the visible area of a panning widget. The upper argument is used to represent the bottommost or rightmost coordinate in a panning widget's child.
Using Adjustments the Easy Way
The adjustable widgets can be roughly divided into those which use and require specific units for these values, and those which treat them as arbitrary numbers.
The group which treats the values as arbitrary numbers includes the Range widgets (Scrollbar and Scale), the ScaleButton widget, and the SpinButton widget. These widgets are typically "adjusted" directly by the user with the mouse or keyboard. They will treat the lower and upper values of an adjustment as a range within which the user can manipulate the adjustment's value. By default, they will only modify the value of an adjustment.
The other group includes the Viewport widget and the ScrolledWindow widget. All of these widgets use pixel values for their adjustments. These are also typically adjusted indirectly using scrollbars. While all widgets which use adjustments can either create their own adjustments or use ones you supply, you'll generally want to let this particular category of widgets create its own adjustments.
If you share an adjustment object between a Scrollbar and a TextView widget, manipulating the scrollbar will automagically adjust the TextView widget. You can set it up like this:
// creates its own adjustments Gtk::TextView textview; // uses the newly-created adjustment for the scrollbar as well Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);
Adjustment Internals
OK, you say, that's nice, but what if I want to create my own handlers to respond when the user adjusts a Range widget or a SpinButton. To access the value of a Gtk::Adjustment, you can use the get_value() and set_value() methods:
As mentioned earlier, Gtk::Adjustment can emit signals. This is, of course, how updates happen automatically when you share an Adjustment object between a Scrollbar and another adjustable widget; all adjustable widgets connect signal handlers to their adjustment's value_changed signal, as can your program.
So, for example, if you have a Scale widget, and you want to change the rotation of a picture whenever its value changes, you would create a signal handler like this:
void cb_rotate_picture (MyPicture* picture) { picture-gt;set_rotation(adj-gt;get_value()); ...
and connect it to the scale widget's adjustment like this:
adj-gt;signal_value_changed().connect(sigc::bindlt;MyPicture*gt;(sigc::mem_fun(*this, &cb_rotate_picture), picture));
What if a widget reconfigures the upper or lower fields of its Adjustment, such as when a user adds more text to a text widget? In this case, it emits the changed signal.
Range widgets typically connect a handler to this signal, which changes their appearance to reflect the change - for example, the size of the slider in a scrollbar will grow or shrink in inverse proportion to the difference between the lower and upper values of its Adjustment.
You probably won't ever need to attach a handler to this signal, unless you're writing a new type of range widget.
adjustment-gt;signal_changed();
Widgets Without X-Windows
Some Widgets do not have an associated X-Window, so they therefore do not receive X events. This means that the signals described in the X event signals section will not be emitted. If you want to capture events for these widgets you can use a special container called Gtk::EventBox, which is described in the EventBox section.
Here is a list of some of these Widgets:
Gtk::Alignment Gtk::Arrow Gtk::AspectFrame Gtk::Bin Gtk::Box Gtk::Button Gtk::CheckButton Gtk::Fixed Gtk::Frame Gtk::Grid Gtk::Image Gtk::Label Gtk::MenuItem Gtk::Notebook Gtk::Paned Gtk::RadioButton Gtk::Range Gtk::ScrolledWindow Gtk::Separator Gtk::Table (deprecated from gtkmm version 3.4) Gtk::Toolbar
These widgets are mainly used for decoration or layout, so you won't often need to capture events on them. They are intended to have no X-Window in order to improve performance.
EventBox
Some gtkmm widgets don't have associated X windows; they draw on their parents' windows. Because of this, they cannot receive events. Also, if they are incorrectly sized, they don't clip, so you can get messy overwriting etc. To receive events on one of these widgets, you can place it inside an EventBox widget and then call Gtk::Widget::set_events() on the EventBox before showing it.
Although the name EventBox emphasises the event-handling method, the widget can also be used for clipping (and more; see the example below).
The constructor for Gtk::EventBox is:
Gtk::EventBox();
A child widget can be added to the EventBox using:
event_box.add(child_widget);
The following example demonstrates both uses of an EventBox - a label is created that is clipped to a small box, and set up so that a mouse-click on the label causes the program to exit. Resizing the window reveals varying amounts of the label.
Dialogs
Dialogs are used as secondary windows, to provide specific information or to ask questions. Gtk::Dialog windows contain a few pre-packed widgets to ensure consistency, and a run() method which blocks until the user dismisses the dialog.
There are several derived Dialog classes which you might find useful. Gtk::MessageDialog is used for most simple notifications. But at other times you might need to derive your own dialog class to provide more complex functionality.
To pack widgets into a custom dialog, you should pack them into the Gtk::Box, available via get_content_area(). To just add a Button to the bottom of the Dialog, you could use the add_button() method.
The run() method returns an int. This may be a value from the Gtk::ResponseType if the user closed the dialog by clicking a standard button, or it could be the custom response value that you specified when using add_button().
MessageDialog
MessageDialog is a convenience class, used to create simple, standard message dialogs, with a message, an icon, and buttons for user response. You can specify the type of message and the text in the constructor, as well as specifying standard buttons via the Gtk::ButtonsType enum.
FileChooserDialog
The FileChooserDialog is suitable for use with "Open" or "Save" menu items.
Most of the useful member methods for this class are actually in the Gtk::FileChooser base class.
FileChooser
ColorChooserDialog
The ColorChooserDialog allows the user to choose a color. The ColorButton opens a color selection dialog when it is clicked.
FontChooserDialog
The FontChooserDialog allows the user to choose a font. The FontButton opens a font chooser dialog when it is clicked.
Non-modal AboutDialog
The AboutDialog offers a simple way to display information about a program, like its logo, name, copyright, website and license.
Most dialogs in this chapter are modal, that is, they freeze the rest of the application while they are shown. It's also possible to create a non-modal dialog, which does not freeze other windows in the application. The following example shows a non-modal AboutDialog. This is perhaps not the kind of dialog you would normally make non-modal, but non-modal dialogs can be useful in other cases. E.g. gedit's search-and-replace dialog is non-modal.
AboutDialog
The Drawing Area Widget
The DrawingArea widget is a blank window that gives you the freedom to create any graphic you desire. Along with that freedom comes the responsibility to handle draw signals on the widget. When a widget is first shown, or when it is covered and then uncovered again it needs to redraw itself. Most widgets have code to do this, but the DrawingArea does not, allowing you to write your own draw signal handler to determine how the contents of the widget will be drawn. This is most often done by overriding the virtual on_draw() member function.
GTK+ uses the Cairo drawing API. With gtkmm, you may use the cairomm C++ API for cairo.
You can draw very sophisticated shapes using Cairo, but the methods to do so are quite basic. Cairo provides methods for drawing straight lines, curved lines, and arcs (including circles). These basic shapes can be combined to create more complex shapes and paths which can be filled with solid colors, gradients, patterns, and other things. In addition, Cairo can perform complex transformations, do compositing of images, and render antialiased text.
Cairo and Pango
Although Cairo can render text, it's not meant to be a replacement for Pango. Pango is a better choice if you need to perform more advanced text rendering such as wrapping or ellipsizing text. Drawing text with Cairo should only be done if the text is part of a graphic.
In this section of the tutorial, we'll cover the basic Cairo drawing model, describe each of the basic drawing elements in some detail (with examples), and then present a simple application that uses Cairo to draw a custom clock widget.
The Cairo Drawing Model
The basic concept of drawing in Cairo involves defining 'invisible' paths and then stroking or filling them to make them visible.
To do any drawing in gtkmm with Cairo, you must first create a Cairo::Context object. This class holds all of the graphics state parameters that describe how drawing is to be done. This includes information such as line width, color, the surface to draw to, and many other things. This allows the actual drawing functions to take fewer arguments to simplify the interface. In gtkmm, a Cairo::Context is created by calling the Gdk::Window::create_cairo_context() function. Since Cairo contexts are reference-counted objects, this function returns a Cairo::RefPtrlt;Cairo::Contextgt; object.
The following example shows how to set up a Cairo context with a foreground color of red and a width of 2. Any drawing functions that use this context will use these settings.
Gtk::DrawingArea myArea; Cairo::RefPtrlt;Cairo::Contextgt; myContext = myArea.get_window()-gt;create_cairo_context(); myContext-gt;set_source_rgb(1.0, 0.0, 0.0); myContext-gt;set_line_width(2.0);
Each Cairo::Context is associated with a particular Gdk::Window, so the first line of the above example creates a Gtk::DrawingArea widget and the second line uses its associated Gdk::Window to create a Cairo::Context object. The final two lines change the graphics state of the context.
There are a number of graphics state variables that can be set for a Cairo context. The most common context attributes are color (using set_source_rgb() or set_source_rgba() for translucent colors), line width (using set_line_width()), line dash pattern (using set_dash()), line cap style (using set_line_cap()), and line join style (using set_line_join()), and font styles (using set_font_size(), set_font_face() and others). There are many other settings as well, such as transformation matrices, fill rules, whether to perform antialiasing, and others. For further information, see the cairomm API documentation.
It is good practice to put all modifications to the graphics state between save()/restore() function calls. For example, if you have a function that takes a Cairo::Context reference as an argument, you might implement it as follows:
void doSomething(const Cairo::RefPtrlt;Cairo::Contextgt;amp; context, int x) { context-gt;save(); // change graphics state // perform drawing operations context-gt;restore(); }
The current state of a Cairo::Context can be saved to an internal stack of saved states and later be restored to the state it was in when you saved it. To do this, use the save() method and the restore() method. This can be useful if you need to temporarily change the line width and color (or any other graphics setting) in order to draw something and then return to the previous settings. In this situation, you could call Cairo::Context::save(), change the graphics settings, draw the lines, and then call Cairo::Context::restore() to restore the original graphics state. Multiple calls to save() and restore() can be nested; each call to restore() restores the state from the matching paired save().
The virtual on_draw() method provides a Cairo context that you shall use for drawing in the Gtk::DrawingArea widget. It is not necessary to save and restore this Cairo context in on_draw().
Drawing Straight Lines
Since the Cairo graphics library was written with support for multiple output targets (the X window system, PNG images, OpenGL, etc), there is a distinction between user-space and device-space coordinates. The mapping between these two coordinate systems defaults to one-to-one so that integer values map roughly to pixels on the screen, but this setting can be adjusted if desired. Sometimes it may be useful to scale the coordinates so that the full width and height of a window both range from 0 to 1 (the 'unit square') or some other mapping that works for your application. This can be done with the Cairo::Context::scale() function.
Now that we understand the basics of the Cairo graphics library, we're almost ready to start drawing. We'll start with the simplest of drawing elements: the straight line. But first you need to know a little bit about Cairo's coordinate system. The origin of the Cairo coordinate system is located in the upper-left corner of the window with positive x values to the right and positive y values going down.
In this example, we'll construct a small but fully functional gtkmm program and draw some lines into the window. The lines are drawn by creating a path and then stroking it. A path is created using the functions Cairo::Context::move_to() and Cairo::Context::line_to(). The function move_to() is similar to the act of lifting your pen off of the paper and placing it somewhere else -- no line is drawn between the point you were at and the point you moved to. To draw a line between two points, use the line_to() function.
After you've finished creating your path, you still haven't drawn anything visible yet. To make the path visible, you must use the function stroke() which will stroke the current path with the line width and style specified in your Cairo::Context object. After stroking, the current path will be cleared so that you can start on your next path.
Many Cairo drawing functions have a _preserve() variant. Normally drawing functions such as clip(), fill(), or stroke() will clear the current path. If you use the _preserve() variant, the current path will be retained so that you can use the same path with the next drawing function.
Drawing Area - Lines
This program contains a single class, MyArea, which is a subclass of Gtk::DrawingArea and contains an on_draw() member function. This function is called whenever the image in the drawing area needs to be redrawn. It is passed a Cairo::RefPtr pointer to a Cairo::Context that we use for the drawing. The actual drawing code sets the color we want to use for drawing by using set_source_rgb() which takes arguments defining the Red, Green, and Blue components of the desired color (valid values are between 0 and 1). After setting the color, we created a new path using the functions move_to() and line_to(), and then stroked this path with stroke().
Drawing with relative coordinates
In the example above we drew everything using absolute coordinates. You can also draw using relative coordinates. For a straight line, this is done with the function Cairo::Context::rel_line_to().
Line styles
In addition to drawing basic straight lines, there are a number of things that you can customize about a line. You've already seen examples of setting a line's color and width, but there are others as well.
If you've drawn a series of lines that form a path, you may want them to join together in a certain way. Cairo offers three different ways to join lines together: Miter, Bevel, and Round. These are show below:
Different join types in Cairo
The line join style is set using the function Cairo::Context::set_line_join().
Line ends can have different styles as well. The default style is for the line to start and stop exactly at the destination points of the line. This is called a Butt cap. The other options are Round (uses a round ending, with the center of the circle at the end point) or Square (uses a squared ending, with the center of the square at the end point). This setting is set using the function Cairo::Context::set_line_cap().
There are other things you can customize as well, including creating dashed lines and other things. For more information, see the Cairo API documentation.
Drawing thin lines
If you try to draw one pixel wide lines, you may notice that the line sometimes comes up blurred and wider than it ought to be. This happens because Cairo will try to draw from the selected position, to both sides (half to each), so if you're positioned right on the intersection of the pixels, and want a one pixel wide line, Cairo will try to use half of each adjacent pixel, which isn't possible (a pixel is the smallest unit possible). This happens when the width of the line is an odd number of pixels (not just one pixel).
The trick is to position in the middle of the pixel where you want the line to be drawn, and thus guaranteeing you get the desired results. See Cairo FAQ.
Drawing Area - Thin Lines
Drawing Curved Lines
In addition to drawing straight lines Cairo allows you to easily draw curved lines (technically a cubic Bézier spline) using the Cairo::Context::curve_to() and Cairo::Context::rel_curve_to() functions. These functions take coordinates for a destination point as well as coordinates for two 'control' points. This is best explained using an example, so let's dive in.
This simple application draws a curve with Cairo and displays the control points for each end of the curve.
The only difference between this example and the straight line example is in the on_draw() function, but there are a few new concepts and functions introduced here, so let's examine them briefly.
We make a call to Cairo::Context::scale(), passing in the width and height of the drawing area. This scales the user-space coordinate system such that the width and height of the widget are both equal to 1.0 'units'. There's no particular reason to scale the coordinate system in this case, but sometimes it can make drawing operations easier.
The call to Cairo::Context::curve_to() should be fairly self-explanatory. The first pair of coordinates define the control point for the beginning of the curve. The second set of coordinates define the control point for the end of the curve, and the last set of coordinates define the destination point. To make the concept of control points a bit easier to visualize, a line has been drawn from each control point to the end-point on the curve that it is associated with. Note that these control point lines are both translucent. This is achieved with a variant of set_source_rgb() called set_source_rgba(). This function takes a fourth argument specifying the alpha value of the color (valid values are between 0 and 1).
Drawing Arcs and Circles
With Cairo, the same function is used to draw arcs, circles, or ellipses: Cairo::Context::arc(). This function takes five arguments. The first two are the coordinates of the center point of the arc, the third argument is the radius of the arc, and the final two arguments define the start and end angle of the arc. All angles are defined in radians, so drawing a circle is the same as drawing an arc from 0 to 2 * M_PI radians. An angle of 0 is in the direction of the positive X axis (in user-space). An angle of M_PI/2 radians (90 degrees) is in the direction of the positive Y axis (in user-space). Angles increase in the direction from the positive X axis toward the positive Y axis. So with the default transformation matrix, angles increase in a clockwise direction. (Remember that the positive Y axis points downwards.)
context-gt;save(); context-gt;translate(x, y); context-gt;scale(width / 2.0, height / 2.0); context-gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI); context-gt;restore();
To draw an ellipse, you can scale the current transformation matrix by different amounts in the X and Y directions. For example, to draw an ellipse with center at x, y and size width, height:
Here's an example of a simple program that draws an arc, a circle and an ellipse into a drawing area.
Drawing Area - Arcs
There are a couple of things to note about this example code. Again, the only real difference between this example and the previous ones is the on_draw() function, so we'll limit our focus to that function. In addition, the first part of the function is nearly identical to the previous examples, so we'll skip that portion.
Note that in this case, we've expressed nearly everything in terms of the height and width of the window, including the width of the lines. Because of this, when you resize the window, everything scales with the window. Also note that there are three drawing sections in the function and each is wrapped with a save()/restore() pair so that we're back at a known state after each drawing.
The section for drawing an arc introduces one new function, close_path(). This function will in effect draw a straight line from the current point back to the first point in the path. There is a significant difference between calling close_path() and manually drawing a line back to the starting point, however. If you use close_path(), the lines will be nicely joined together. If you use line_to() instead, the lines will end at the same point, but Cairo won't do any special joining.
Drawing counter-clockwise
The function Cairo::Context::arc_negative() is exactly the same as Cairo::Context::arc() but the angles go the opposite direction.
Drawing Text
Drawing Text with Pango
Text is drawn via Pango Layouts. The easiest way to create a Pango::Layout is to use Gtk::Widget::create_pango_layout(). Once created, the layout can be manipulated in various ways, including changing the text, font, etc. Finally, the layout can be rendered using the Pango::Layout::show_in_cairo_context() method.
Here is an example of a program that draws some text, some of it upside-down. The Printing chapter contains another example of drawing text.
Drawing Area - Text
Drawing Images
There is a method for drawing from a Gdk::Pixbuf to a Cairo::Context. A Gdk::Pixbuf buffer is a useful wrapper around a collection of pixels, which can be read from files, and manipulated in various ways.
Probably the most common way of creating Gdk::Pixbufs is to use Gdk::Pixbuf::create_from_file(), which can read an image file, such as a png file into a pixbuf ready for rendering.
The Gdk::Pixbuf can be rendered by setting it as the source pattern of the Cairo context with Gdk::Cairo::set_source_pixbuf(). Then draw the image with either Cairo::Context::paint() (to draw the whole image), or Cairo::Context::rectangle() and Cairo::Context::fill() (to fill the specified rectangle). set_source_pixbuf() is not a member of Cairo::Context. It takes a Cairo::Context as its first parameter.
Here is a small bit of code to tie it all together: (Note that usually you wouldn't load the image every time in the draw signal handler! It's just shown here to keep it all together.)
bool MyArea::on_draw(const Cairo::RefPtrlt;Cairo::Contextgt;amp; cr) { Glib::RefPtrlt;Gdk::Pixbufgt; image = Gdk::Pixbuf::create_from_file("myimage.png"); // Draw the image at 110, 90, except for the outermost 10 pixels. Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80); cr-gt;rectangle(110, 90, image-gt;get_width()-20, image-gt;get_height()-20); cr-gt;fill(); return true; }
Here is an example of a simple program that draws an image.
Drawing Area - Image
Example Application: Creating a Clock with Cairo
Now that we've covered the basics of drawing with Cairo, let's try to put it all together and create a simple application that actually does something. The following example uses Cairo to create a custom Clock widget. The clock has a second hand, a minute hand, and an hour hand, and updates itself every second.
As before, almost all of the interesting stuff is done in the draw signal handler on_draw(). Before we dig into the draw signal handler, notice that the constructor for the Clock widget connects a handler function on_timeout() to a timer with a timeout period of 1000 milliseconds (1 second). This means that on_timeout() will get called once per second. The sole responsibility of this function is to invalidate the window so that gtkmm will be forced to redraw it.
Now let's take a look at the code that performs the actual drawing. The first section of on_draw() should be pretty familiar by now. This example again scales the coordinate system to be a unit square so that it's easier to draw the clock as a percentage of window size so that it will automatically scale when the window size is adjusted. Furthermore, the coordinate system is scaled over and down so that the (0, 0) coordinate is in the very center of the window.
The function Cairo::Context::paint() is used here to set the background color of the window. This function takes no arguments and fills the current surface (or the clipped portion of the surface) with the source color currently active. After setting the background color of the window, we draw a circle for the clock outline, fill it with white, and then stroke the outline in black. Notice that both of these actions use the _preserve variant to preserve the current path, and then this same path is clipped to make sure that our next lines don't go outside the outline of the clock.
After drawing the outline, we go around the clock and draw ticks for every hour, with a larger tick at 12, 3, 6, and 9. Now we're finally ready to implement the time-keeping functionality of the clock, which simply involves getting the current values for hours, minutes and seconds, and drawing the hands at the correct angles.
Gtk::Widget has several methods and signals which are prefixed with "drag_". These are used for Drag and Drop.
Sources and Destinations
Things are dragged from sources to be dropped on destinations. Each source and destination has infomation about the data formats that it can send or receive, provided by Gtk::TargetEntry items. A drop destination will only accept a dragged item if they both share a compatible Gtk::TargetEntry item. Appropriate signals will then be emitted, telling the signal handlers which Gtk::TargetEntry was used.
target: A name, such as "STRING"
info: An identifier which will be sent to your signals to tell you which TargetEntry was used.
flags: Used only for drag and drop, this specifies whether the data may be dragged to other widgets and applications, or only to the same ones.
Gtk::TargetEntry objects contain this information:
Widgets can be identified as sources or destinations using these Gtk::Widget methods:
void drag_source_set(const std::vectorlt;Gtk::TargetEntrygt;amp; targets, Gdk::ModifierType start_button_mask, Gdk::DragAction actions);
targets is a vector of Gtk::TargetEntry elements.
start_button_mask is an ORed combination of values, which specify which modifier key or mouse button must be pressed to start the drag.
actions is an ORed combination of values, which specified which Drag and Drop operations will be possible from this source - for instance, copy, move, or link. The user can choose between the actions by using modifier keys, such as Shift to change from copy to move, and this will be shown by a different cursor.
void drag_dest_set(const std::vectorlt;Gtk::TargetEntrygt;amp; targets, Gtk::DestDefaults flags, Gdk::DragAction actions);
flags is an ORed combination of values which indicates how the widget will respond visually to Drag and Drop items.
actions indicates the Drag and Drop actions which this destination can receive - see the description above.
When a drop destination has accepted a dragged item, certain signals will be emitted, depending on what action has been selected. For instance, the user might have held down the Shift key to specify a move rather than a copy. Remember that the user can only select the actions which you have specified in your calls to drag_dest_set() and drag_source_set().
Copy
drag_begin: Provides DragContext.
drag_data_get: Provides info about the dragged data format, and a Gtk::SelectionData structure, in which you should put the requested data.
drag_end: Provides DragContext.
The source widget will emit these signals, in this order:
drag_motion: Provides DragContext and coordinates. You can call the drag_status() method of the DragContext to indicate which action will be accepted.
drag_drop: Provides DragContext and coordinates. You can call drag_get_data(), which triggers the drag_data_get signal in the source widget, and then the drag_data_received signal in the destination widget.
drag_data_received: Provides info about the dragged data format, and a Gtk::SelectionData structure which contains the dropped data. You should call the drag_finish() method of the DragContext to indicate whether the operation was successful.
The destination widget will emit these signals, in this order:
Move
drag_data_delete: Gives the source the opportunity to delete the original data if that's appropriate.
During a move, the source widget will also emit this signal:
DragContext
The drag and drop signals provide a DragContext, which contains some information about the drag and drop operation and can be used to influence the process. For instance, you can discover the source widget, or change the drag and drop icon, by using the set_icon() methods. More importantly, you should call the drag_finish() method from your drag_data_received signal handler to indicate whether the drop was successful.
Here is a very simple example, demonstrating a drag and drop Copy operation:
There is a more complex example in examples/others/dnd.
The Clipboard
Simple text copy-paste functionality is provided for free by widgets such as Gtk::Entry and Gtk::TextView, but you might need special code to deal with your own data formats. For instance, a drawing program would need special code to allow copy and paste within a view, or between documents.
You can usually pretend that Gtk::Clipboard is a singleton. You can get the default clipboard instance with Gtk::Clipboard::get(). This is probably the only clipboard you will ever need.
Your application doesn't need to wait for clipboard operations, particularly between the time when the user chooses Copy and then later chooses Paste. Most Gtk::Clipboard methods take sigc::slots which specify callback methods. When Gtk::Clipboard is ready, it will call these methods, either providing the requested data, or asking for data.
Targets
Different applications contain different types of data, and they might make that data available in a variety of formats. gtkmm calls these data types targets.
For instance, gedit can supply and receive the "UTF8_STRING" target, so you can paste data into gedit from any application that supplies that target. Or two different image editing applications might supply and receive a variety of image formats as targets. As long as one application can receive one of the targets that the other supplies then you will be able to copy data from one to the other.
A target can be in a variety of binary formats. This chapter, and the examples, assume that the data is 8-bit text. This would allow us to use an XML format for the clipboard data. However this would probably not be appropriate for binary data such as images. Gtk::Clipboard provides overloads that allow you to specify the format in more detail if necessary.
The Drag and Drop API uses the same mechanism. You should probably use the same data targets and formats for both Clipboard and Drag and Drop operations.
When the user asks to copy some data, you should tell the Clipboard what targets are available, and provide the callback methods that it can use to get the data. At this point you should store a copy of the data, to be provided when the clipboard calls your callback method in response to a paste.
Glib::RefPtrlt;Gtk::Clipboardgt; refClipboard = Gtk::Clipboard::get(); //Targets: std::vectorlt;Gtk::TargetEntrygt; targets; targets.push_back( Gtk::TargetEntry("example_custom_target") ); targets.push_back( Gtk::TargetEntry("UTF8_STRING") ); refClipboard-gt;set( targets, sigc::mem_fun(*this, &ExampleWindow::on_clipboard_get), sigc::mem_fun(*this, &ExampleWindow::on_clipboard_clear) );
Your callback will then provide the stored data when the user chooses to paste the data. For instance:
void ExampleWindow::on_clipboard_get( Gtk::SelectionDataamp; selection_data, guint /* info */) { const std::string target = selection_data.get_target(); if(target == "example_custom_target") selection_data.set("example_custom_target", m_ClipboardStore); }
The ideal example below can supply more than one clipboard target.
The clear callback allows you to free the memory used by your stored data when the clipboard replaces its data with something else.
Paste
When the user asks to paste data from the Clipboard, you should request a specific format and provide a callback method which will be called with the actual data. For instance:
refClipboard-gt;request_contents("example_custom_target", sigc::mem_fun(*this, &ExampleWindow::on_clipboard_received) );
Here is an example callback method:
void ExampleWindow::on_clipboard_received( const Gtk::SelectionDataamp; selection_data) { Glib::ustring clipboard_data = selection_data.get_data_as_string(); //Do something with the pasted data. }
Discovering the available targets
To find out what targets are currently available on the Clipboard for pasting, call the request_targets() method, specifying a method to be called with the information. For instance:
refClipboard-gt;request_targets( sigc::mem_fun(*this, &ExampleWindow::on_clipboard_received_targets) );
In your callback, compare the vector of available targets with those that your application supports for pasting. You could enable or disable a Paste menu item, depending on whether pasting is currently possible. For instance:
void ExampleWindow::on_clipboard_received_targets( const std::vectorlt;Glib::ustringgt;amp; targets) { const bool bPasteIsPossible = std::find(targets.begin(), targets.end(), example_target_custom) != targets.end(); // Enable/Disable the Paste button appropriately: m_Button_Paste.set_sensitive(bPasteIsPossible); }
Simple
This example allows copy and pasting of application-specific data, using the standard text target. Although this is simple, it's not ideal because it does not identify the Clipboard data as being of a particular type.
Clipboard - Simple
Ideal
Defines a custom clipboard target, though the format of that target is still text.
It supports pasting of 2 targets - both the custom one and a text one that creates an arbitrary text representation of the custom data.
It uses request_targets() and the owner_change signal and disables the Paste button if it can't use anything on the clipboard.
This is like the simple example, but it
Clipboard - Ideal
Printing
At the application development level, gtkmm's printing API provides dialogs that are consistent across applications and allows use of Cairo's common drawing API, with Pango-driven text rendering. In the implementation of this common API, platform-specific backends and printer-specific drivers are used.
PrintOperation
The primary object is Gtk::PrintOperation, allocated for each print operation. To handle page drawing connect to its signals, or inherit from it and override the default virtual signal handlers. PrintOperation automatically handles all the settings affecting the print loop.
begin_print: You must handle this signal, because this is where you create and set up a Pango::Layout using the provided Gtk::PrintContext, and break up your printing output into pages.
paginate: Pagination is potentially slow so if you need to monitor it you can call the PrintOperation::set_show_progress() method and handle this signal.
request_page_setup: Provides a PrintContext, page number and Gtk::PageSetup. Handle this signal if you need to modify page setup on a per-page basis.
draw_page: You must handle this signal, which provides a PrintContext and a page number. The PrintContext should be used to create a Cairo::Context into which the provided page should be drawn. To render text, iterate over the Pango::Layout you created in the begin_print handler.
For each page that needs to be rendered, the following signals are emitted:
end_print: A handler for it is a safe place to free any resources related to a PrintOperation. If you have your custom class that inherits from PrintOperation, it is naturally simpler to do it in the destructor.
done: This signal is emitted when printing is finished, meaning when the print data is spooled. Note that the provided Gtk::PrintOperationResult may indicate that an error occurred. In any case you probably want to notify the user about the final status.
status_changed: Emitted whenever a print job's status changes, until it is finished. Call the PrintOperation::set_track_print_status() method to monitor the job status after spooling. To see the status, use get_status() or get_status_string().
The PrintOperation::run() method starts the print loop, during which various signals are emitted:
Page setup
The PrintOperation class has a method called set_default_page_setup() which selects the default paper size, orientation and margins. To show a page setup dialog from your application, use the Gtk::run_page_setup_dialog() method, which returns a Gtk::PageSetup object with the chosen settings. Use this object to update a PrintOperation and to access the selected Gtk::PaperSize, Gtk::PageOrientation and printer-specific margins.
You should save the chosen Gtk::PageSetup so you can use it again if the page setup dialog is shown again.
//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members... Glib::RefPtrlt;Gtk::PageSetupgt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings); m_refPageSetup = new_page_setup;
For instance,
The Cairo coordinate system, in the draw_page handler, is automatically rotated to the current page orientation. It is normally within the printer margins, but you can change that via the PrintOperation::set_use_full_page() method. The default measurement unit is device pixels. To select other units, use the PrintOperation::set_unit() method.
Rendering text
Text rendering is done using Pango. The Pango::Layout object for printing should be created by calling the PrintContext::create_pango_layout() method. The PrintContext object also provides the page metrics, via get_width() and get_height(). The number of pages can be set with PrintOperation::set_n_pages(). To actually render the Pango text in on_draw_page, get a Cairo::Context with PrintContext::get_cairo_context() and show the Pango::LayoutLines that appear within the requested page number.
See an example of exactly how this can be done.
Asynchronous operations
By default, PrintOperation::run() returns when a print operation is completed. If you need to run a non-blocking print operation, call PrintOperation::set_allow_async(). Note that set_allow_async() is not supported on all platforms, however the done signal will still be emitted.
run() may return PRINT_OPERATION_RESULT_IN_PROGRESS. To track status and handle the result or error you need to implement signal handlers for the done and status_changed signals:
// in class ExampleWindow's method... Glib::RefPtrlt;PrintOperationgt; op = PrintOperation::create(); // ...set up op... op-gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &ExampleWindow::on_printoperation_done), op)); // run the op
void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtrlt;PrintOperationgt;amp; op) { if (result == Gtk::PRINT_OPERATION_RESULT_ERROR) //notify user else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY) //Update PrintSettings with the ones used in this PrintOperation if (! op-gt;is_finished()) op-gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &ExampleWindow::on_printoperation_status_changed), op)); }
Second, check for an error and connect to the status_changed signal. For instance:
void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtrlt;PrintFormOperationgt;amp; op) { if (op-gt;is_finished()) //the print job is finished else //get the status with get_status() or get_status_string() //update UI }
Finally, check the status. For instance,
Export to PDF
Glib::RefPtrlt;Gtk::PrintOperationgt; op = Gtk::PrintOperation::create(); // ...set up op... op-gt;set_export_filename("test.pdf"); Gtk::PrintOperationResult res = op-gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);
The 'Print to file' option is available in the print dialog, without the need for extra implementation. However, it is sometimes useful to generate a pdf file directly from code. For instance,
Extending the print dialog
Set the title of the tab via PrintOperation::set_custom_tab_label(), create a new widget and return it from the create_custom_widget signal handler. You'll probably want this to be a container widget, packed with some others.
Get the data from the widgets in the custom_widget_apply signal handler.
You may add a custom tab to the print dialog:
Gtk::Widget* CustomPrintOperation::on_create_custom_widget() { set_custom_tab_label("My custom tab"); Gtk::Box* hbox = new Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 8); hbox-gt;set_border_width(6); Gtk::Label* label = Gtk::manage(new Gtk::Label("Enter some text: ")); hbox-gt;pack_start(*label, false, false); label-gt;show(); hbox-gt;pack_start(m_Entry, false, false); m_Entry.show(); return hbox; } void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */) { Glib::ustring user_input = m_Entry.get_text(); //... }
Although the custom_widget_apply signal provides the widget you previously created, to simplify things you can keep the widgets you expect to contain some user input as class members. For example, let's say you have a Gtk::Entry called m_Entry as a member of your CustomPrintOperation class:
The example in examples/book/printing/advanced demonstrates this.
Preview
// in a class that inherits from Gtk::Window... Glib::RefPtrlt;PrintOperationgt; op = PrintOperation::create(); // ...set up op... op-gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);
The native GTK+ print dialog has a preview button, but you may also start a preview directly from an application:
On Unix, the default preview handler uses an external viewer program. On Windows, the native preview dialog will be shown. If necessary you may override this behaviour and provide a custom preview dialog. See the example located in /examples/book/printing/advanced.
The following example demonstrates how to print some input from a user interface. It shows how to implement on_begin_print and on_draw_page, as well as how to track print status and update the print settings.
Printing - Simple
Recently Used Documents
gtkmm provides an easy way to manage recently used documents. The classes involved in implementing this functionality are RecentManager, RecentChooserDialog, RecentChooserMenu, RecentChooserWidget, RecentAction, and RecentFilter.
Each item in the list of recently used files is identified by its URI, and can have associated metadata. The metadata can be used to specify how the file should be displayed, a description of the file, its mime type, which application registered it, whether it's private to the registering application, and several other things.
RecentManager
RecentManager acts as a database of recently used files. You use this class to register new files, remove files from the list, or look up recently used files. There is one list of recently used files per user.
You can create a new RecentManager, but you'll most likely just want to use the default one. You can get a reference to the default RecentManager with get_default().
RecentManager is the model of a model-view pattern, where the view is a class that implements the RecentChooser interface.
Adding Items to the List of Recent Files
To add a new file to the list of recent documents, in the simplest case, you only need to provide the URI. For example:
Glib::RefPtrlt;Gtk::RecentManagergt; recent_manager = Gtk::RecentManager::get_default(); recent_manager-gt;add_item(uri);
If you want to register a file with metadata, you can pass a RecentManager::Data parameter to add_item(). The metadata that can be set on a particular file item is as follows:
app_exec: The command line to be used to launch this resource. This string may contain the "f" and "u" escape characters which will be expanded to the resource file path and URI respectively
app_name: The name of the application that registered the resource
description: A short description of the resource as a UTF-8 encoded string
display_name: The name of the resource to be used for display as a UTF-8 encoded string
groups: A list of groups associated with this item. Groups are essentially arbitrary strings associated with a particular resource. They can be thought of as 'categories' (such as "email", "graphics", etc) or tags for the resource.
is_private: Whether this resource should be visible only to applications that have registered it or not
mime_type: The MIME type of the resource
In addition to adding items to the list, you can also look up items from the list and modify or remove items.
Looking up Items in the List of Recent Files
To look up recently used files, RecentManager provides several functions. To look up a specific item by its URI, you can use the lookup_item() function, which will return a RecentInfo class. If the specified URI did not exist in the list of recent files, lookup_item() throws a RecentManagerError exception. For example:
Glib::RefPtrlt;Gtk::RecentInfogt; info; try { info = recent_manager-gt;lookup_item(uri); } catch(const Gtk::RecentManagerErroramp; ex) { std::cerr &lt;lt; "RecentManagerError: " &lt;lt; ex.what() &lt;lt; std::endl; } if (info) { // item was found }
A RecentInfo object is essentially an object containing all of the metadata about a single recently-used file. You can use this object to look up any of the properties listed above.
If you don't want to look for a specific URI, but instead want to get a list of all recently used items, RecentManager provides the get_items() function. The return value of this function is a std::vector of all recently used files. The following code demonstrates how you might get a list of recently used files:
std::vectorlt; Glib::RefPtrlt;Gtk::RecentInfogt; &gt; info_list = recent_manager-gt;get_items();
The maximum age of items in the recently used files list can be set with Gtk::Settings::property_gtk_recent_files_max_age(). Default value: 30 days.
Modifying the List of Recent Files
There may be times when you need to modify the list of recent files. For instance, if a file is moved or renamed, you may need to update the file's location in the recent files list so that it doesn't point to an incorrect location. You can update an item's location by using move_item().
In addition to changing a file's URI, you can also remove items from the list, either one at a time or by clearing them all at once. The former is accomplished with remove_item(), the latter with purge_items().
The functions move_item(), remove_item() and purge_items() have no effect on the actual files that are referred to by the URIs, they only modify the list of recent files.
RecentChooser
RecentChooser is an interface that can be implemented by widgets displaying the list of recently used files. gtkmm provides four built-in implementations for choosing recent files: RecentChooserWidget, RecentChooserDialog, RecentChooserMenu, and RecentAction.
RecentChooserWidget is a simple widget for displaying a list of recently used files. RecentChooserWidget is the basic building block for RecentChooserDialog, but you can embed it into your user interface if you want to.
RecentChooserMenu and RecentAction allow you to list recently used files as a menu.
Simple RecentChooserDialog example
Shown below is a simple example of how to use the RecentChooserDialog and the RecentAction classes in a program. This simple program has a menubar with a Recent Files Dialog menu item. When you select this menu item, a dialog pops up showing the list of recently used files.
If this is the first time you're using a program that uses the Recent Files framework, the dialog may be empty at first. Otherwise it should show the list of recently used documents registered by other applications.
After selecting the Recent Files Dialog menu item, you should see something similar to the following window.
The constructor for ExampleWindow creates the menu using UIManager (see for more information). It then adds the menu and the toolbar to the window.
Filtering Recent Files
For any of the RecentChooser classes, if you don't wish to display all of the items in the list of recent files, you can filter the list to show only those that you want. You can filter the list with the help of the RecentFilter class. This class allows you to filter recent files by their name (add_pattern()), their mime type (add_mime_type()), the application that registered them (add_application()), or by a custom filter function (add_custom()). It also provides the ability to filter based on how long ago the file was modified and which groups it belongs to.
After you've created and set up the filter to match only the items you want, you can apply a filter to a chooser widget with the RecentChooser::add_filter() function.
Plugs and Sockets
Overview
From time to time, it may be useful to be able to embed a widget from another application within your application. gtkmm allows you to do this with the Gtk::Socket and Gtk::Plug classes. It is not anticipated that very many applications will need this functionality, but in the rare case that you need to display a widget that is running in a completely different process, these classes can be very helpful.
The communication between a Socket and a Plug follows the XEmbed protocol. This protocol has also been implemented in other toolkits (e.g. Qt), which allows the same level of integration when embedding a Qt widget in GTK+ or vice versa.
The way that Sockets and Plugs work together is through their window ids. Both a Socket and a Plug have IDs that can be retrieved with their get_id() member functions. The use of these IDs will be explained below in .
Sockets
A Socket is a special kind of container widget that provides the ability to embed widgets from one process into another process in a way that is transparent to the user.
Plugs
A Plug is a special kind of Window that can be plugged into a Socket. Besides the normal properties and methods of Gtk::Window, a Plug provides a constructor that takes the ID of a Socket, which will automatically embed the Plug into the Socket that matches that ID.
Since a Plug is just a special type of Gtk::Window class, you can add containers or widgets to it like you would to any other window.
Connecting Plugs and Sockets
After a Socket or Plug object is realized, you can obtain its ID with its get_id() function. This ID can then be shared with other processes so that other processes know how to connect to each other.
Create a Socket object in one process and pass the ID of that Socket to another process so that it can create a Plug object by specifying the given Socket ID in its constructor. There is no way to assign a Plug to a particular Socket after creation, so you must pass the Socket ID to the Plug's constructor.
Create a Plug independantly from any particular Socket and pass the ID of the Plug to other processes that need to use it. The ID of the Plug can be associated with a particular Socket object using the Socket::add_id() function. This is the approach used in the example below.
There are two basic strategies that can be used:
Plugs and Sockets Example
The following is a simple example of using sockets and plugs. The method of communication between processes is deliberately kept very simple: The Plug writes its ID out to a text file named plug.id and the process with the socket reads the ID from this file. In a real program, you may want to use a more sophisticated method of inter-process communication.
This example creates two executable programs: socket and plug. The idea is that socket has an application window that will embed a widget from the plug program. The way this example is designed, plug must be running first before starting socket. To see the example in action, execute the following commands in order from within the example directory:
Start the plug program and send it to the background (or just use a different terminal).
$ ./plug &
After which you should see something like the following:
The window ID is: 69206019
Then start the socket program:
$ ./socket
After starting socket, you should see the following output in the terminal:
I've been embedded. A plug was added
The first line of output is from plug, after it has been notified that it has been embedded inside of a Socket. The second line was emitted by socket in response to its plug_added signal. If everything was done as described above, the socket window should look roughly like the following:
If for some reason the Socket couldn't attach the Plug, the window would look something like this:
Keyboard Events
X events differ in some ways from other signals. These differences are described in the X Event signals section in the appendix. Here we will use keyboard events to show how X events can be used in a program.
Whenever you press or release a key, an event is emitted. You can connect a signal handler to handle such events.
To receive the keyboard events, you must first call the Gtk::Widget::add_events() function with a bit mask of the events you're interested in. The event signal handler will receive an argument that depends on the type of event. For keyboard events it's a GdkEventKey*. As discribed in the appendix, the event signal handler returns a bool value, to indicate that the signal is fully handled (true) or allow event propagation (false).
To determine which key was pressed or released, you read the value of GdkEventKey::keyval and compare it with a constant in the lt;gdk/gdkkeysyms.hgt; header file. The states of modifier keys (shift, ctrl, etc.) are available as bit-flags in GdkEventKey::state.
bool on_key_press_or_release_event(GdkEventKey* event) { if (event-gt;type == GDK_KEY_PRESS &amp; event-gt;keyval == GDK_KEY_1 &amp; (event-gt;state & (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK) { handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key return true; } return false; } Gtk::Entry m_entry; // in a class definition // in the class constructor m_entry.signal_key_press_event().connect( sigc::ptr_fun(amp;on_key_press_or_release_event) ); m_entry.signal_key_release_event().connect( sigc::ptr_fun(amp;on_key_press_or_release_event) ); m_entry.add_events(Gdk::KEY_PRESS_MASK | Gdk::KEY_RELEASE_MASK);
Here's a simple example:
In this example there are three keyboard shortcuts: Alt+1 selects the first radio button, Alt+2 selects the second one, and the Esc key hides (closes) the window. The default event signal handler is overridden, as described in the Overriding default signal handlers section in the appendix.
Keyboard Events - Simple
Event Propagation
Event propagation means that, when an event is emitted on a particular widget, it can be passed to its parent widget (and that widget can pass it to its parent, and so on) and, if the parent has an event handler, that handler will be called.
Contrary to other events, keyboard events are first sent to the toplevel window (Gtk::Window), where it will be checked for any keyboard shortcuts that may be set (accelerator keys and mnemonics, used for selecting menu items from the keyboard). After this (and assuming the event wasn't handled), it is sent to the widget which has focus, and the propagation begins from there.
The event will propagate until it reaches the top-level widget, or until you stop the propagation by returning true from an event handler.
Notice, that after canceling an event, no other function will be called (even if it is from the same widget).
In this example there are three event handlers that are called after Gtk::Window's default event handler, one in the Gtk::Entry, one in the Gtk::Grid and one in the Gtk::Window.
In the Gtk::Window, we have also the default handler overridden (on_key_release_event()), and another handler being called before the default handler (windowKeyReleaseBefore()).
The purpose of this example is to show the steps the event takes when it is emitted.
When you write in the entry, a key release event will be emitted, which will go first to the toplevel window (Gtk::Window), since we have one event handler set to be called before, that's what is called first (windowKeyReleaseBefore()). Then the default handler is called (which we have overridden), and after that the event is sent to the widget that has focus, the Entry in our example and, depending on whether we let it propagate, it can reach the Grid's and the Window's event handlers. If it propagates, the text you're writing will appear in the Label above the Entry.
Keyboard Events - Event Propagation
Timeouts, I/O and Idle Functions
Timeouts
You may be wondering how to make gtkmm do useful work while it's idling along. Happily, you have several options. Using the following methods you can create a timeout method that will be called every few milliseconds.
sigc::connection Glib::SignalTimeout::connect(const sigc::slotlt;boolgt;amp; slot, unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);
The first argument is a slot you wish to have called when the timeout occurs. The second argument is the number of milliseconds between calls to that method. You receive a sigc::connection object that can be used to deactivate the connection using its disconnect() method:
my_connection.disconnect();
bool MyCallback() { std::cout &lt;lt; "Hello World!\ " &lt;lt; std::endl; return true; }
Another way of destroying the connection is your signal handler. It has to be of the type sigc::slotlt;boolgt;. As you see from the definition your signal handler has to return a value of the type bool. A definition of a sample method might look like this:
You can stop the timeout method by returning false from your signal handler. Therefore, if you want your method to be called repeatedly, it should return true.
Here's an example of this technique:
Monitoring I/O
A nifty feature of Glib (one of the libraries underlying gtkmm) is the ability to have it check for data on a file descriptor for you. This is especially useful for networking applications. The following method is used to do this:
sigc::connection Glib::SignalIO::connect(const sigc::slotlt;bool,Glib::IOConditiongt;amp; slot, int fd, Glib::IOCondition condition, int priority = Glib::PRIORITY_DEFAULT);
The first argument is a slot you wish to have called when the specified event (see argument 3) occurs on the file descriptor you specify using argument two. Argument three may be one or more (using |) of:
Glib::IO_IN - Call your method when there is data ready for reading on your file descriptor.
Glib::IO_OUT - Call your method when the file descriptor is ready for writing.
Glib::IO_PRI - Call your method when the file descriptor has urgent data to be read.
Glib::IO_ERR - Call your method when an error has occurred on the file descriptor.
Glib::IO_HUP - Call your method when hung up (the connection has been broken usually for pipes and sockets).
The return value is a sigc::connection that may be used to stop monitoring this file descriptor using its disconnect() method. The slot signal handler should be declared as follows:
bool input_callback(Glib::IOCondition condition);
where condition is as specified above. As usual the slot is created with sigc::mem_fun() (for a member method of an object), or sigc::ptr_fun() (for a function).
A little example follows. To use the example just execute it from a terminal; it doesn't create a window. It will create a pipe named testfifo in the current directory. Then start another shell and execute echo "Hello" &gt; testfifo. The example will print each line you enter until you execute echo "Q" &gt; testfifo.
Idle Functions
If you want to specify a method that gets called when nothing else is happening, use the following:
sigc::connection Glib::SignalIdle::connect(const sigc::slotlt;boolgt;amp; slot, int priority = Glib::PRIORITY_DEFAULT_IDLE);
This causes gtkmm to call the specified method whenever nothing else is happening. You can add a priority (lower numbers are higher priorities). There are two ways to remove the signal handler: calling disconnect() on the sigc::connection object, or returning false in the signal handler, which should be declared as follows:
bool idleFunc();
Since this is very similar to the methods above this explanation should be sufficient to understand what's going on. However, here's a little example:
This example points out the difference of idle and timeout methods a little. If you need methods that are called periodically, and speed is not very important, then you want timeout methods. If you want methods that are called as often as possible (like calculating a fractal in background), then use idle methods.
Try executing the example and increasing the system load. The upper progress bar will increase steadily; the lower one will slow down.
Memory management
Normal C++ memory management
gtkmm allows the programmer to control the lifetime (that is, the construction and destruction) of any widget in the same manner as any other C++ object. This flexibility allows you to use new and delete to create and destroy objects dynamically or to use regular class members (that are destroyed automatically when the class is destroyed) or to use local instances (that are destroyed when the instance goes out of scope). This flexibility is not present in some C++ GUI toolkits, which restrict the programmer to only a subset of C++'s memory management features.
Here are some examples of normal C++ memory management:
Class Scope widgets
If a programmer does not need dynamic memory allocation, automatic widgets in class scope may be used. One advantage of automatic widgets in class scope is that memory management is grouped in one place. The programmer does not risk memory leaks from failing to delete a widget.
The primary disadvantage of using class scope widgets is revealing the class implementation rather than the class interface in the class header.
#include &lt;gtkmm/button.hgt; #include &lt;gtkmm/window.hgt; class Foo : public Gtk::Window { private: Gtk::Button theButton; // will be destroyed when the Foo object is destroyed };
Function scope widgets
{ Gtk::Button aButton; aButton.show(); ... app-gt;run(); }
If a programmer does not need a class scope widget, a function scope widget may also be used. The advantages to function scope over class scope are the increased data hiding and reduced dependencies.
Dynamic allocation with new and delete
Gtk::Button* pButton = new Gtk::Button("Test"); // do something useful with pButton delete pButton;
Although, in most cases, the programmer will prefer to allow containers to automatically destroy their children using Gtk::manage() (see below), the programmer is not required to use Gtk::manage(). The traditional new and delete operators may also be used. Here, the programmer deletes pButton to prevent a memory leak.
Managed Widgets
Alternatively, you can let a widget's container control when the widget is destroyed. In most cases, you want a widget to last only as long as the container it is in. To delegate the management of a widget's lifetime to its container, first create it with Gtk::manage() and pack it into its container with Gtk::Container::add(), Gtk::Box::pack_start(), or a similar method. Now the widget will be destroyed whenever its container is destroyed.
Dynamic allocation with manage() and add()
gtkmm provides the manage() function and add() methods to create and destroy widgets. Every widget except a top-level window must be added or packed into a container in order to be displayed. The manage() function marks a widget so that when the widget is added to a container, the container becomes responsible for deleting the widget.
MyContainer::MyContainer() { Gtk::Button* pButton = Gtk::manage(new Gtk::Button("Test")); add(*pButton); //add *pButton to MyContainer }
Now, when objects of type MyContainer are destroyed, the button will also be deleted. It is no longer necessary to delete pButton to free the button's memory; its deletion has been delegated to the MyContainer object.
Of course, a top-level container will not be added to another container. The programmer is responsible for destroying the top-level container using one of the traditional C++ techniques. For instance, your top-level Window might just be an instance in your main() function.
Shared resources
Some objects, such as Gdk::Pixbufs and Pango::Fonts, are obtained from a shared store. Therefore you cannot instantiate your own instances. These classes typically inherit from Glib::Object. Rather than requiring you to reference and unreference these objects, gtkmm uses the Glib::RefPtrlt;gt; smartpointer. Cairomm has its own smartpointer, Cairo::RefPtrlt;gt;.
Glib::RefPtrlt;Gdk::Pixbufgt; pixbuf = Gdk::Pixbuf::create_from_file(filename);
Objects such as Gdk::Pixbuf can only be instantiated with a create() function. For instance,
int width = 0; if(pixbuf) { width = pixbuf-gt;get_width(); }
You have no way of getting a bare Gdk::Pixbuf. In the example, pixbuf is a smart pointer, so you can do this, much like a normal pointer:
When pixbuf goes out of scope an unref() will happen in the background and you don't need to worry about it anymore. There's no new so there's no delete.
Glib::RefPtrlt;Gdk::Pixbufgt; pixbuf2 = pixbuf;
If you copy a RefPtr, for instance , or if you pass it as a method argument or a return type, then RefPtr will do any necessary referencing to ensure that the instance will not be destroyed until the last RefPtr has gone out of scope.
See the appendix for detailed information about RefPtr.
Bjarne Stroustrup, "The C++ Programming Language" Forth Edition - section 34.3
Nicolai M. Josuttis, "The C++ Standard Library" - section 4.2
If you wish to learn more about smartpointers, you might look in these books:
Glade and Gtk::Builder
Although you can use C++ code to instantiate and arrange widgets, this can soon become tedious and repetitive. And it requires a recompilation to show changes. The Glade application allows you to layout widgets on screen and then save an XML description of the arrangement. Your application can then use the Gtk::Builder API to load that XML file at runtime and obtain a pointer to specifically named widget instances.
Less C++ code is required.
UI changes can be seen more quickly, so UIs are able to improve.
Designers without programming skills can create and edit UIs.
This has the following advantages:
You still need C++ code to deal with User Interface changes triggered by user actions, but using Gtk::Builder for the widget layout allows you to focus on implementing that functionality.
Loading the .glade file
Glib::RefPtrlt;Gtk::Buildergt; builder = Gtk::Builder::create_from_file("basic.glade");
Gtk::Builder must be used via a Glib::RefPtr. Like all such classes, you need to use a create() method to instantiate it. For instance, This will instantiate the windows defined in the .glade file, though they will not be shown immediately unless you have specified that via the Properties window in Glade.
Glib::RefPtrlt;Gtk::Buildergt; builder = Gtk::Builder::create_from_file("basic.glade", "treeview_products");
To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance,
Accessing widgets
Gtk::Dialog* pDialog = 0; builder-gt;get_widget("DialogBasic", pDialog);
To access a widget, for instance to show() a dialog, use the get_widget() method, providing the widget's name. This name should be specified in the Glade Properties window. If the widget could not be found, or is of the wrong type, then the pointer will be set to 0.
Gtk::Builder checks for a null pointer, and checks that the widget is of the expected type, and will show warnings on the command line about these.
Remember that you are not instantiating a widget with get_widget(), you are just obtaining a pointer to one that already exists. You will always receive a pointer to the same instance when you call get_widget() on the same Gtk::Builder, with the same widget name. The widgets are instantiated during Gtk::Builder::create_from_file().
get_widget() returns child widgets that are manage()ed (see the Memory Management chapter), so they will be deleted when their parent container is deleted. So, if you get only a child widget from Gtk::Builder, instead of a whole window, then you must either put it in a Container or delete it. Windows (such as Dialogs) cannot be managed because they have no parent container, so you must delete them at some point.
This simple example shows how to load a Glade file at runtime and access the widgets with Gtk::Builder.
Using derived widgets
You can use Glade to layout your own custom widgets derived from gtkmm widget classes. This keeps your code organized and encapsulated. Of course you won't see the exact appearance and properties of your derived widget in Glade, but you can specify its location and child widgets and the properties of its gtkmm base class.
DerivedDialog* pDialog = 0; builder-gt;get_widget_derived("DialogBasic", pDialog);
Use Gtk::Builder::get_widget_derived() like so:
Your derived class must have a constructor that takes a pointer to the underlying C type, and the Gtk::Builder instance. All relevant classes of gtkmm typedef their underlying C type as BaseObjectType (Gtk::Dialog typedefs BaseObjectType as GtkDialog, for instance).
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtrlt;Gtk::Buildergt;amp; builder) : Gtk::Dialog(cobject) { }
You must call the base class's constructor in the initialization list, providing the C pointer. For instance,
DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtrlt;Gtk::Buildergt;amp; builder) : Gtk::Dialog(cobject), m_builder(builder), m_pButton(0) { //Get the Glade-instantiated Button, and connect a signal handler: m_builder-gt;get_widget("quit_button", m_pButton); if(m_pButton) { m_pButton-gt;signal_clicked().connect( sigc::mem_fun(*this, &DerivedDialog::on_button_quit) ); } }
You could then encapsulate the manipulation of the child widgets in the constructor of the derived class, maybe using get_widget() or get_widget_derived() again. For instance,
This example shows how to load a Glade file at runtime and access the widgets via a derived class.
Internationalization and Localization
gtkmm applications can easily support multiple languages, including non-European languages such as Chinese and right-to-left languages such as Arabic. An appropriately-written and translated gtkmm application will use the appropriate language at runtime based on the user's environment.
You might not anticipate the need to support additional languages, but you can never rule it out. And it's easier to develop the application properly in the first place rather than retrofitting later.
The process of writing source code that allows for translation is called internationalization, often abbreviated to i18n. The Localization process, sometimes abbreviated as l10n, provides translated text for other languages, based on that source code.
The main activity in the internationalization process is finding strings seen by users and marking them for translation. You do not need to do it all at once - if you set up the necessary project infrastructure correctly then your application will work normally regardless of how many strings you've covered.
String literals should be typed in the source code in English, but surrounded by a macro. The gettext (or intltool) utility can then extract the marked strings for translation, and substitute the translated text at runtime.
Preparing your project
In the instructions below we will assume that you will not be using gettext directly, but intltool, which was written specifically for GNOME. intltool uses gettext(), which extracts strings from source code, but intltool can also combine strings from other files, for example from desktop menu details, and GUI resource files such as Glade files, into standard gettext.pot/.po files.
We also assume that you are using autotools (e.g. automake and autoconf) to build your project, and that you are using ./autogen.sh from gnome-common, which, among other things, takes care of some intltool initialization.
Create a sub-directory named po in your project's root directory. This directory will eventually contain all of your translations. Within it, create a file named LINGUAS and a file named POTFILES.in. It is common practice to also create a ChangeLog file in the po directory so that translators can keep track of translation changes.
LINGUAS contains an alphabetically sorted list of codes identifying the languages for which your program is translated (comment lines starting with a # are ignored). Each language code listed in the LINGUAS file must have a corresponding .po file. So, if your program has German and Japanese translations, your LINGUAS file would look like this:
# keep this file sorted alphabetically, one language code per line de ja
(In addition, you'd have the files ja.po and de.po in your po directory which contain the German and Japanese translations, respectively.)
POTFILES.in is a list of paths to all files which contain strings marked up for translation, starting from the project root directory. So for example, if your project sources were located in a subdirectory named src, and you had two files that contained strings that should be translated, your POTFILES.in file might look like this:
src/main.cc src/other.cc
If you are using gettext directly, you can only mark strings for translation if they are in source code file. However, if you use intltool, you can mark strings for translation in a variety of other file formats, including Glade UI files, xml, .desktop files and several more. So, if you have designed some of the application UI in Glade then also add your .glade files to the list in POTFILES.in.
Now that there is a place to put your translations, you need to initialize intltool and gettext. Add the following code to your configure.ac, substituting 'programname' with the name of your program:
IT_PROG_INTLTOOL([0.35.0]) GETTEXT_PACKAGE=programname AC_SUBST(GETTEXT_PACKAGE) AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], ["$GETTEXT_PACKAGE"], [The domain to use with gettext]) AM_GLIB_GNU_GETTEXT PROGRAMNAME_LOCALEDIR=[${datadir}/locale] AC_SUBST(PROGRAMNAME_LOCALEDIR)
This PROGRAMNAME_LOCALEDIR variable will be used later in the Makefile.am file, to define a macro that will be used when you initialize gettext in your source code.
Add po to the SUBDIRS variable. Without this, your translations won't get built and installed when you build the program
INTLTOOL_FILES = intltool-extract.in \\ intltool-merge.in \\ intltool-update.in
Define INTLTOOL_FILES as:
Add INTLTOOL_FILES to the EXTRA_DIST list of files. This ensures that when you do a make dist, these commands will be included in the source tarball.
DISTCLEANFILES = ... intltool-extract \\ intltool-merge \\ intltool-update \\ po/.intltool-merge-cache
Update your DISTCLEANFILES:
In the top-level Makefile.am:
In your src/Makefile.am, update your AM_CPPFLAGS to add the following preprocessor macro definition:
AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\"${PROGRAMNAME_LOCALEDIR}\\"
This macro will be used when you initialize gettext in your source code.
Marking strings for translation
String literals should be typed in the source code in English, but they should be surrounded by a call to the gettext() function. These strings will be extracted for translation and the translations may be used at runtime instead of the original English strings.
The GNU gettext package allows you to mark strings in source code, extract those strings for translation, and use the translated strings in your application.
display_message("Getting ready for i18n.");
display_message(_("Getting ready for i18n."));
However, Glib defines gettext() support macros which are shorter wrappers in an easy-to-use form. To use these macros, include lt;glibmm/i18n.hgt;, and then, for example, substitute: with:
xgettext -a -o my-strings --omit-header *.cc *.h
For reference, it is possible to generate a file which contains all strings which appear in your code, even if they are not marked for translation, together with file name and line number references. To generate such a file named my-strings, execute the following command, within the source code directory:
bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR); bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8"); textdomain(GETTEXT_PACKAGE);
Finally, to let your program use the translation for the current locale, add this code to the beginning of your main.cc file, to initialize gettext.
How gettext works
intltool / xgettext script extracts the strings and puts them in a mypackage.pot file. The translators of your application create their translations by first copying this .pot file to a localename.po file. A locale identifies a language and an encoding for that language, including date and numerical formats. Later, when the text in your source code has changed, the msmerge script is used to update the localename.po files from the regenerated .pot file.
At install time, the .po files are converted to a binary format (with the extension .mo) and placed in a system-wide directory for locale files, for example /usr/share/locale/.
When the application runs, the gettext library checks the system-wide directory to see if there is a .mo file for the user's locale environment (you can set the locale with, for instance, "export LANG=de_DE.UTF-8" from a bash console). Later, when the program reaches a gettext call, it looks for a translation of a particular string. If none is found, the original string is used.
Testing and adding translations
intltool-update --pot
To convince yourself that you've done well, you may wish to add a translation for a new locale. In order to do that, go to the po subdirectory of your project and execute the following command:
That will create a file named programname.pot. Now copy that file to languagecode.po, such as de.po or hu.po. Also add that language code to LINGUAS. The .po file contains a header and a list of English strings, with space for the translated strings to be entered. Make sure you set the encoding of the .po file (specified in the header, but also as content) to UTF-8.
It's possible that certain strings will be marked as fuzzy in the .po file. These translations will not substitute the original string. To make them appear, simply remove the fuzzy tag.
Resources
L10N Guidelines for Developers
Intltool README
How to use Git for GNOME translators
gettext manual
gtkmm_hello
example package
gnomemm_hello
More information about what lies behind the internationalization and localization process is presented and demonstrated in:
Expecting UTF8
A properly internationalized application will not make assumptions about the number of bytes in a character. That means that you shouldn't use pointer arithmetic to step through the characters in a string, and it means you shouldn't use std::string or standard C functions such as strlen() because they make the same assumption.
However, you probably already avoid bare char* arrays and pointer arithmetic by using std::string, so you just need to start using Glib::ustring instead. See the Basics chapter about Glib::ustring.
Glib::ustring and std::iostreams
std::ostringstream output; output.imbue(std::locale("")); // use the user's locale for this stream output &lt;lt; percentage &lt;lt; " % done"; label-gt;set_text(Glib::locale_to_utf8(output.str()));
Unfortunately, the integration with the standard iostreams is not completely foolproof. gtkmm converts Glib::ustrings to a locale-specific encoding (which usually is not UTF-8) if you output them to an ostream with operatorlt;lt;. Likewise, retrieving Glib::ustrings from istream with operatorgt;gt; causes a conversion in the opposite direction. But this scheme breaks down if you go through a std::string, e.g. by inputting text from a stream to a std::string and then implicitly converting it to a Glib::ustring. If the string contained non-ASCII characters and the current locale is not UTF-8 encoded, the result is a corrupted Glib::ustring. You can work around this with a manual conversion. For instance, to retrieve the std::string from a ostringstream:
Pitfalls
There are a few common mistakes that you would discover eventually yourself. But this section might help you to avoid them.
Same strings, different semantics
Sometimes two english strings are identical but have different meanings in different contexts, so they would probably not be identical when translated. Since the English strings are used as look-up keys, this causes problems.
In these cases, you should add extra characters to the strings. For instance, use "jumps[noun]" and "jumps[verb]" instead of just "jumps" and strip them again outside the gettext call. If you add extra characters you should also add a comment for the translators before the gettext call. Such comments will be shown in the .po files. For instance:
// note to translators: don't translate the "[noun]" part - it is // just here to distinguish the string from another "jumps" string text = strip(gettext("jumps[noun]"), "[noun]");
Composition of strings
C programmers use sprintf() to compose and concatenate strings. C++ favours streams, but unfortunately, this approach makes translation difficult, because each fragment of text is translated separately, without allowing the translators to rearrange them according to the grammar of the language.
For instance, this code would be problematic:
std::cout &lt;lt; _("Current amount: ") &lt;lt; amount &lt;lt; _(" Future: ") &lt;lt; future &lt;lt; std::endl; label.set_text(_("Really delete ") + filename + _(" now?"));
std::cout &lt;lt; Glib::ustring::compose( _("Current amount: %1 Future: %2"), amount, future) &lt;lt; std::endl; label.set_text(Glib::ustring::compose(_("Really delete %1 now?"), filename));
So you should either avoid this situation or use Glib::ustring::compose() which supports syntax such as:
Assuming the displayed size of strings
You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English string. Luckily, most gtkmm widgets will expand at runtime to the required size.
Unusual words
You should avoid cryptic abbreviations, slang, or jargon. They are usually difficult to translate, and are often difficult for even native speakers to understand. For instance, prefer "application" to "app"
Using non-ASCII characters in strings
Currently, gettext does not support non-ASCII characters (i.e. any characters with a code above 127) in source code. For instance, you cannot use the copyright sign (©).
To work around this, you could write a comment in the source code just before the string, telling the translators to use the special character if it is available in their languages. For english, you could then make an American English en_US.po translation which used that special character.
Getting help with translations
If your program is free software, there is a whole GNOME subproject devoted to helping you make translations, the GNOME Translation Project.
The way it works is that you upload your source code to a git repository where translators can access it, then contact the gnome-i18n mailing list and ask to have your program added to the list of modules to translate.
Then you make sure you update the file POTFILES.in in the po/ subdirectory (intltool-update -M can help with this) so that the translators always access updated myprogram.pot files, and simply freeze the strings at least a couple of days before you make a new release, announcing it on gnome-i18n. Depending on the number of strings your program contains and how popular it is, the translations will then start to tick in as languagename.po files.
Note that most language teams only consist of 1-3 persons, so if your program contains a lot of strings, it might last a while before anyone has the time to look at it. Also, most translators do not want to waste their time (translating is a very time-consuming task) so if they do not assess your project as being really serious (in the sense that it is polished and being maintained) they may decide to spend their time on some other project.
Custom Widgets
gtkmm makes it very easy to derive new widgets by inheriting from an existing widget class, either by deriving from a container and adding child widgets, or by deriving from a single-item widget, and changing its behaviour. But you might occasionally find that no suitable starting point already exists. In this case, you can implement a widget from scratch.
Custom Containers
get_request_mode_vfunc(): Return what Gtk::SizeRequestMode is preferred by the container.
get_preferred_width_vfunc(): Calculate the minimum and natural width of the container.
get_preferred_height_vfunc(): Calculate the minimum and natural height of the container.
get_preferred_width_for_height_vfunc(): Calculate the minimum and natural width of the container, if it would be given the specified height.
get_preferred_height_for_width_vfunc(): Calculate the minimum and natural height of the container, if it would be given the specified width.
on_size_allocate(): Position the child widgets, given the height and width that the container has actually been given.
forall_vfunc(): Call the same callback for each of the children.
on_add(): Add a child widget to the container.
on_remove(): Remove a child widget from the container.
child_type_vfunc(): Return what type of child can be added.
When deriving from Gtk::Container, you should override the following virtual methods:
The get_request_mode_vfunc(), get_preferred_width_vfunc(), get_preferred_height_vfunc(), get_preferred_width_for_height_vfunc(), get_preferred_height_for_width_vfunc(), and on_size_allocate() virtual methods control the layout of the child widgets. For instance, if your container has 2 child widgets, with one below the other, your get_request_mode_vfunc() might request height-for-width layout. Then your get_preferred_width_vfunc() might report the maximum of the widths of the child widgets, and get_preferred_height_for_width_vfunc() might report the sum of their heights. If you want padding between the child widgets then you would add that to the width and height too. Your widget's container will use this result to ensure that your widget gets enough space, and not less. By examining each widget's parent, and its parent, this logic will eventually decide the size of the top-level window.
You are not guaranteed to get the Gtk::SizeRequestMode that you request. Therefore all four of the get_preferred_xxx_vfunc() methods must return sensible values.
on_size_allocate() receives the actual height and width that the parent container has decided to give to your widget. This might be more than the minimum, or even more than the natural size, for instance if the top-level window has been expanded. You might choose to ignore the extra space and leave a blank area, or you might choose to expand your child widgets to fill the space, or you might choose to expand the padding between your widgets. It's your container, so you decide. Don't forget to call set_allocation() inside your on_size_allocate() implementation to actually use the allocated space that has been offered by the parent container.
Unless your container is a top-level window that derives from Gtk::Window, you should probably also call Gtk::Widget::set_has_window(false) in your constructor. This means that your container does not create its own Gdk::Window, but uses its parent's window. (Note the difference between Gtk::Window and Gdk::Window.) If your container does need its own Gdk::Window, and does not derive from Gtk::Window, you must also override the on_realize() method as described in the Custom Widgets section. And unless your container draws directly onto the underlying Gdk::Window, you should probably call set_redraw_on_allocate(false) to improve performance.
By overriding forall_vfunc() you can allow applications to operate on all of the container's child widgets. For instance, show_all_children() uses this to find all the child widgets and show them.
Although your container might have its own method to set the child widgets, you should still provide an implementation for the virtual on_add() and on_remove() methods from the base class, so that the add() and remove() methods will do something appropriate if they are called.
Your implementation of the child_type_vfunc() method should report the type of widget that may be added to your container, if it is not yet full. This is usually Gtk::Widget::get_type() to indicate that the container may contain any class derived from Gtk::Widget. If the container may not contain any more widgets, then this method should return G_TYPE_NONE.
This example implements a container with two child widgets, one above the other. Of course, in this case it would be far simpler just to use a vertical Gtk::Box.
Custom Container
By deriving directly from Gtk::Widget you can do all the drawing for your widget directly, instead of just arranging child widgets. For instance, a Gtk::Label draws the text of the label, but does not do this by using other widgets.
get_request_mode_vfunc(): (optional) Return what Gtk::SizeRequestMode is preferred by the widget.
get_preferred_width_vfunc(): Calculate the minimum and natural width of the widget.
get_preferred_height_vfunc(): Calculate the minimum and natural height of the widget.
get_preferred_width_for_height_vfunc(): Calculate the minimum and natural width of the widget, if it would be given the specified height.
get_preferred_height_for_width_vfunc(): Calculate the minimum and natural height of the widget, if it would be given the specified width.
on_size_allocate(): Position the widget, given the height and width that it has actually been given.
on_realize(): Associate a Gdk::Window with the widget.
on_unrealize(): (optional) Break the association with the Gdk::Window.
on_map(): (optional)
on_unmap(): (optional)
on_draw(): Draw on the supplied Cairo::Context.
When deriving from Gtk::Widget, you should override the following virtual methods. The methods marked (optional) need not be overridden in all custom widgets. The base class's methods may be appropriate.
The first 6 methods in the previous table are also overridden in custom containers. They are briefly described in the Custom Containers section.
Most custom widgets need their own Gdk::Window to draw on. Then you can call Gtk::Widget::set_has_window(true) in your constructor. (This is the default value.) If you do not call set_has_window(false), you must override on_realize() and call Gtk::Widget::set_realized() and Gtk::Widget::set_window() from there.
This example implements a widget which draws a Penrose triangle.
Custom Widget
Multi-threaded programs
The constraints
glibmm provides the normal set of thread launching functions, mutexes, condition variables and scoped locking classes required for writing multi-threaded programs using C++.
These interactions arise from the fact that, amongst other things, a class inheriting from sigc::trackable will, via that inheritance, have a std::list object keeping track of slots created by calls to sigc::mem_fun() representing any of its non-static methods (more particularly it keeps a list of callbacks which will null the connected slots on its destruction). Each sigc::slot object also keeps, via sigc::slot_rep, its own sigc::trackable object to track any sigc::connection objects which it needs to inform about its demise, and also has a function to deregister itself from any sigc::trackable on disconnection or destruction. sigc::signal objects also keep lists of slots, which will be updated by a call to their connect() method or calls to any sigc::connection object relating to such a connection.
However, care is required when writing programs based on gtkmm using multiple threads of execution, arising from the fact that libsigc++, and in particular sigc::trackable, are not thread-safe. That's because none of the complex interactions that occur behind the scenes when using libsigc++ are protected by a mutex or other means of synchronization.
The rules
This requires a number of rules to be observed when writing multi-threaded programs using gtkmm. These are set out below, but one point to note is that extra care is required when deriving classes from sigc::trackable, because the effects are unintuitive (see particularly points 4 and 5 below).
Use Glib::Dispatcher to invoke gtkmm functions from worker threads (this is dealt with in more detail in the next section).
A sigc::signal object should be regarded as owned by the thread which created it. Only that thread should connect a sigc::slot object to the signal object, and only that thread should emit() or call operator()() on the signal, or null any connected sigc::slot object. It follows (amongst other things) that any signal object provided by a gtkmm widget should only be operated on in the main GUI thread and any object deriving from sigc::trackable having its non-static methods referenced by slots connected to the signal object should only be destroyed in that thread.
Any sigc::connection object should be regarded as owned by the thread in which the method returning the sigc::connection object was called. Only that thread should call sigc::connection methods on the object.
A sigc::slot object created by a call to sigc::mem_fun() which references a method of a class deriving from sigc::trackable should never be copied to another thread, nor destroyed by a different thread than the one which created it. (One consequence of this is that Glib::Threads::Thread::create() should not be called with a slot argument created by a call to sigc::mem_fun() which represents a method of such a class. It is however safe to pass Glib::Threads::Thread::create() a function object representing such a method by using, say, boost::bind() or, in C++11, std::bind() or a C++11 lambda expression.)
If a particular class object derives from sigc::trackable, only one thread should create sigc::slot objects representing any of the class's non-static methods by calling sigc::mem_fun(). The first thread to create such a slot should be regarded as owning the relevant object for the purpose of creating further slots referencing any of its non-static methods using that function, or nulling those slots by disconnecting them or destroying the trackable object.
Although glib is itself thread-safe, any glibmm wrappers which use libsigc++ will not be. So for example, only the thread in which a main loop runs should call Glib::SignalIdle::connect(), Glib::SignalIO::connect(), Glib::SignalTimeout::connect(), Glib::SignalTimeout::connect_seconds for that main loop, or manipulate any sigc::connection object returned by them.
The connect*_once() variants, Glib::SignalIdle::connect_once(), Glib::SignalTimeout::connect_once(), Glib::SignalTimeout::connect_seconds_once(), are thread-safe for any case where the slot is not created by a call to sigc::mem_fun() which represents a method of a class deriving from sigc::trackable. This is similar to Glib::Threads::Thread::create() as mentioned in point 4.
Using Glib::Dispatcher
The slots connected to sigc::signal objects execute in the thread which calls emit() or operator()() on the signal. Glib::Dispatcher does not behave this way: instead its connected slots execute in the thread in which the Glib::Dispatcher object was constructed (which must have a glib main loop). If a Glib::Dispatcher object is constructed in the main GUI thread (which will therefore be the receiver thread), any worker thread can emit on it and have the connected slots safely execute gtkmm functions.
Some thread safety rules on the use of Glib::Dispatcher still apply. As mentioned, a Glib::Dispatcher object must be constructed in the receiver thread (the thread in whose main loop it will execute its connected slots). By default this is the main program thread, although there is a Glib::Dispatcher constructor which can take the Glib::MainContext object of any thread which has a main loop. Only the receiver thread should call connect() on the Glib::Dispatcher object, or manipulate any related sigc::connection object, unless additional synchronization is employed. However, any worker thread can safely emit on the Glib::Dispatcher object without any locking once the receiver thread has connected the slots, provided that it is constructed before the worker thread is started (if it is constructed after the thread has started, additional synchronization will normally be required to ensure visibility).
Aside from the fact that connected slots always execute in the receiver thread, Glib::Dispatcher objects are similar to sigc::signallt;voidgt; objects. They therefore cannot pass unbound arguments nor return a value. The best way to pass unbound arguments is with a thread-safe (asynchronous) queue. At the time of writing glibmm does not have one, although most people writing multi-threaded code will have one available to them (they are relatively easy to write although there are subtleties in combining thread safety with strong exception safety).
A Glib::Dispatcher object can be emitted on by the receiver thread as well as by a worker thread, although this should be done within reasonable bounds. On unix-like systems Glib::Dispatcher objects share a single common pipe, which could in theory at least fill up on a very heavily loaded system running a program with a very large number of Dispatcher objects in use. Were the pipe to fill up before the receiver thread's main loop has had an opportunity to read from it to empty it, and the receiver thread attempt to emit and so write to it when it is in that condition, the receiver thread would block on the write, so deadlocking. Where the receiver thread is to emit, a normal sigc::signallt;voidgt; object could of course be used instead.
This is an example program with two threads, one GUI thread, like in all gtkmm programs, and one worker thread. The worker thread is created when you press the Start work button. It is deleted when the work is finished, when you press the Stop work button, or when you press the Quit button.
A Glib::Dispatcher is used for sending notifications from the worker thread to the GUI thread. The ExampleWorker class contains data which is accessed by both threads. This data is protected by a Glib::Threads::Mutex. Only the GUI thread updates the GUI.
Multi-Threaded Program
Recommended Techniques
This section is simply a gathering of wisdom, general style guidelines and hints for creating gtkmm applications.
Use GNU autoconf and automake! They are your friends :) Automake examines C files, determines how they depend on each other, and generates a Makefile so the files can be compiled in the correct order. Autoconf permits automatic configuration of software installation, handling a large number of system quirks to increase portability.
Subclass Widgets to better organize your code. You should probably subclass your main Window at least. Then you can make your child Widgets and signal handlers members of that class.
Create your own signals instead of passing pointers around. Objects can communicate with each other via signals and signal handlers. This is much simpler than objects holding pointers to each other and calling each other's methods. gtkmm's classes uses special versions of sigc::signal, but you should use normal sigc::signals, as described in the libsigc++ documentation.
Application Lifetime
Most applications will have only one Window, or only one main window. These applications can use the Gtk::Application::run(Gtk::Windowamp;) overload. It shows the window and returns when the window has been hidden. This might happen when the user closes the window, or when your code decides to hide() the window. You can prevent the user from closing the window (for instance, if there are unsaved changes) by overriding Gtk::Window::on_delete_event().
Most of our examples use this technique.
Using a gtkmm widget
Our examples all tend to have the same structure. They follow these steps for using a Widget:
Declare a variable of the type of Widget you wish to use, generally as member variable of a derived container class. You could also declare a pointer to the widget type, and then create it with new in your code. Even when using the widget via a pointer, it's still probably best to make that pointer a member variable of a container class so that you can access it later.
Set the attributes of the widget. If the widget has no default constructor, then you will need to initialize the widget in the initalizer list of your container class's constructor.
Connect any signals you wish to use to the appropriate handlers.
Pack the widget into a container using the appropriate call, e.g. Gtk::Container::add() or pack_start().
Call show() to display the widget.
Gtk::Widget::show() lets gtkmm know that we have finished setting the attributes of the widget, and that it is ready to be displayed. You can use Gtk::Widget::hide() to make it disappear again. The order in which you show the widgets is not important, but we do suggest that you show the top-level window last; this way, the whole window will appear with its contents already drawn. Otherwise, the user will first see a blank window, into which the widgets will be gradually drawn.
Contributing
This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any aspect of gtkmm that does not already have documentation, please consider contributing to this document.
Ideally, we would like you to provide a patch to the docs/tutorial/C/gtkmm-tutorial-in.xml file. This file is currently in the gtkmm-documentation module in GNOME git.
If you do decide to contribute, please post your contribution to the gtkmm mailing list at lt;gtkmm-list@gnome.orggt;. Also, be aware that the entirety of this document is free, and any addition you provide must also be free. That is, people must be able to use any portion of your examples in their programs, and copies of this document (including your contribution) may be distributed freely.
The RefPtr smartpointer
Glib::RefPtr is a smartpointer. Specifically, it is a reference-counting smartpointer. You might be familiar with std::auto_ptrlt;gt;, std::unique_ptrlt;gt; and std::shared_ptrlt;gt;, which are also smartpointers. Glib::RefPtrlt;gt; is similar to std::shared_ptrlt;gt;, which is also reference-counting. Glib::RefPtrlt;gt; was introduced long before there was a reference-counting smartpointer in the C++ Standard Library.
A smartpointer acts much like a normal pointer. Here are a few examples.
Copying
You can copy RefPtrs, just like normal pointers. But unlike normal pointers, you don't need to worry about deleting the underlying instance.
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename); Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf2 = refPixbuf;
Of course this means that you can store RefPtrs in standard containers, such as std::vector or std::list.
std::listlt; Glib::RefPtrlt;Gdk::Pixbufgt; &gt; listPixbufs; Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename); listPixbufs.push_back(refPixbuf);
Dereferencing
You can dereference a smartpointer with the -gt; operator, to call the methods of the underlying instance, just like a normal pointer.
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename); int width = refPixbuf-gt;get_width();
But unlike most smartpointers, you can't use the * operator to access the underlying instance.
Glib::RefPtrlt;Gdk::Pixbufgt; refPixbuf = Gdk::Pixbuf::create_from_file(filename); Gdk::Pixbufamp; underlying = *refPixbuf; //Syntax error - will not compile.
Casting
You can cast RefPtrs to base types, just like normal pointers.
Glib::RefPtrlt;Gtk::TreeStoregt; refStore = Gtk::TreeStore::create(columns); Glib::RefPtrlt;Gtk::TreeModelgt; refModel = refStore;
This means that any method which takes a const Glib::RefPtrlt;BaseTypegt; argument can also take a const Glib::RefPtrlt;DerivedTypegt;. The cast is implicit, just as it would be for a normal pointer.
You can also cast to a derived type, but the syntax is a little different than with a normal pointer.
Glib::RefPtrlt;Gtk::TreeStoregt; refStore = Glib::RefPtrlt;Gtk::TreeStoregt;::cast_dynamic(refModel); Glib::RefPtrlt;Gtk::TreeStoregt; refStore2 = Glib::RefPtrlt;Gtk::TreeStoregt;::cast_static(refModel);
Checking for null
Just like normal pointers, you can check whether a RefPtr points to anything.
Glib::RefPtrlt;Gtk::TreeModelgt; refModel = m_TreeView.get_model(); if(refModel) { int cols_count = refModel-gt;get_n_columns(); ... }
But unlike normal pointers, RefPtrs are automatically initialized to null so you don't need to remember to do that yourself.
Constness
The use of the const keyword in C++ is not always clear. You might not realise that const Something* declares a pointer to a const Something. The pointer can be changed, but not the Something that it points to.
Therefore, the RefPtr equivalent of Something* for a method parameter is const Glib::RefPtrlt;Somethinggt;amp;, and the equivalent of const Something* is const Glib::RefPtrlt;const Somethinggt;amp;.
The const ... & around both is just for efficiency, like using const std::stringamp; instead of std::string for a method parameter to avoid unnecessary copying.
Connecting signal handlers
gtkmm widget classes have signal accessor methods, such as Gtk::Button::signal_clicked(), which allow you to connect your signal handler. Thanks to the flexibility of libsigc++, the callback library used by gtkmm, the signal handler can be almost any kind of function, but you will probably want to use a class method. Among GTK+ C coders, these signal handlers are often named callbacks.
Here's an example of a signal handler being connected to a signal:
#include &lt;gtkmm/button.hgt; void on_button_clicked() { std::cout &lt;lt; "Hello World" &lt;lt; std::endl; } main() { Gtk::Button button("Hello World"); button.signal_clicked().connect(sigc::ptr_fun(amp;on_button_clicked)); }
There's rather a lot to think about in this (non-functional) code. First let's identify the parties involved:
The signal handler is on_button_clicked().
We're hooking it up to the Gtk::Button object called button.
When the Button emits its clicked signal, on_button_clicked() will be called.
Now let's look at the connection again:
... button.signal_clicked().connect(sigc::ptr_fun(amp;on_button_clicked)); ...
Note that we don't pass a pointer to on_button_clicked() directly to the signal's connect() method. Instead, we call sigc::ptr_fun(), and pass the result to connect().
sigc::ptr_fun() generates a sigc::slot. A slot is an object which looks and feels like a function, but is actually an object. These are also known as function objects, or functors. sigc::ptr_fun() generates a slot for a standalone function or static method. sigc::mem_fun() generates a slot for a member method of a particular instance.
Here's a slightly larger example of slots in action:
void on_button_clicked(); class some_class { void on_button_clicked(); }; some_class some_object; main() { Gtk::Button button; button.signal_clicked().connect( sigc::ptr_fun(amp;on_button_clicked) ); button.signal_clicked().connect( sigc::mem_fun(some_object, &some_class::on_button_clicked) ); }
The first call to connect() is just like the one we saw last time; nothing new here.
The next is more interesting. sigc::mem_fun() is called with two arguments. The first argument is some_object, which is the object that our new slot will be pointing at. The second argument is a pointer to one of its methods. This particular version of sigc::mem_fun() creates a slot which will, when "called", call the pointed-to method of the specified object, in this case some_object.on_button_clicked().
Another thing to note about this example is that we made the call to connect() twice for the same signal object. This is perfectly fine - when the button is clicked, both signal handlers will be called.
We just told you that the button's clicked signal is expecting to call a method with no arguments. All signals have requirements like this - you can't hook a function with two arguments to a signal expecting none (unless you use an adapter, such as sigc::bind(), of course). Therefore, it's important to know what type of signal handler you'll be expected to connect to a given signal.
Writing signal handlers
To find out what type of signal handler you can connect to a signal, you can look it up in the reference documentation or the header file. Here's an example of a signal declaration you might see in the gtkmm headers:
Glib::SignalProxy1lt;bool, Gtk::DirectionTypegt; signal_focus()
Other than the signal's name (focus), two things are important to note here: the number following the word SignalProxy at the beginning (1, in this case), and the types in the list (bool and Gtk::DirectionType). The number indicates how many arguments the signal handler should have; the first type, bool, is the type that the signal handler should return; and the next type, Gtk::DirectionType, is the type of this signal's first, and only, argument. By looking at the reference documentation, you can see the names of the arguments too.
The same principles apply for signals which have more arguments. Here's one with three (taken from lt;gtkmm/textbuffer.hgt;):
Glib::SignalProxy3lt;void, const TextBuffer::iteratoramp;, const Glib::ustrinamp;, intgt; signal_insert();
It follows the same form. The number 3 at the end of the type's name indicates that our signal handler will need three arguments. The first type in the type list is void, so that should be our signal handler's return type. The following three types are the argument types, in order. Our signal handler's prototype could look like this:
void on_insert(const TextBuffer::iteratoramp; pos, const Glib::ustringamp; text, int bytes)
Disconnecting signal handlers
Let's take another look at a Signal's connect method:
sigc::signallt;void,intgt;::iterator signallt;void,intgt;::connect( const sigc::slotlt;void,intgt;amp; );
Notice that the return value is of type sigc::signallt;void,intgt;::iterator. This can be implicitly converted into a sigc::connection which in turn can be used to control the connection. By keeping a connection object you can disconnect its associated signal handler using the method sigc::connection::disconnect().
Overriding default signal handlers
So far we've told you to perform actions in response to button-presses and the like by handling signals. That's certainly a good way to do things, but it's not the only way.
Instead of laboriously connecting signal handlers to signals, you can simply make a new class which inherits from a widget - say, a Button - and then override the default signal handler, such as Button::on_clicked(). This can be a lot simpler than hooking up signal handlers for everything.
Subclassing isn't always the best way to accomplish things. It is only useful when you want the widget to handle its own signal by itself. If you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects.
gtkmm classes are designed with overriding in mind; they contain virtual member methods specifically intended to be overridden.
Let's look at an example of overriding:
#include &lt;gtkmm/button.hgt; class OverriddenButton : public Gtk::Button { protected: virtual void on_clicked(); } void OverriddenButton::on_clicked() { std::cout &lt;lt; "Hello World" &lt;lt; std::endl; // call the base class's version of the method: Gtk::Button::on_clicked(); }
Here we define a new class called OverriddenButton, which inherits from Gtk::Button. The only thing we change is the on_clicked() method, which is called whenever Gtk::Button emits the clicked signal. This method prints "Hello World" to stdout, and then calls the original, overridden method, to let Gtk::Button do what it would have done had we not overridden.
You don't always need to call the parent's method; there are times when you might not want to. Note that we called the parent method after writing "Hello World", but we could have called it before. In this simple example, it hardly matters much, but there are times when it will. With signals, it's not quite so easy to change details like this, and you can do something here which you can't do at all with connected signal handlers: you can call the parent method in the middle of your custom code.
Binding extra arguments
m_button1.signal_clicked().connect( sigc::bindlt;Glib::ustringgt;( sigc::mem_fun(*this, &HelloWorld::on_button_clicked), "button 1") );
virtual void on_button_clicked(Glib::ustring data);
If you use one signal handler to catch the same signal from several widgets, you might like that signal handler to receive some extra information. For instance, you might want to know which button was clicked. You can do this with sigc::bind(). Here's some code from the helloworld2 example. This says that we want the signal to send an extra Glib::ustring argument to the signal handler, and that the value of that argument should be "button 1". Of course we will need to add that extra argument to the declaration of our signal handler: Of course, a normal "clicked" signal handler would have no arguments.
sigc::bind() is not commonly used, but you might find it helpful sometimes. If you are familiar with GTK+ programming then you have probably noticed that this is similar to the extra gpointer data arguments which all GTK+ callbacks have. This is generally overused in GTK+ to pass information that should be stored as member data in a derived widget, but widget derivation is very difficult in C. We have far less need of this hack in gtkmm.
X Event signals
The Widget class has some special signals which correspond to the underlying X-Windows events. These are suffixed by _event; for instance, Widget::signal_button_press_event().
You might occasionally find it useful to handle X events when there's something you can't accomplish with normal signals. Gtk::Button, for example, does not send mouse-pointer coordinates with its clicked signal, but you could handle button_press_event if you needed this information. X events are also often used to handle key-presses.
These signals behave slightly differently. The value returned from the signal handler indicates whether it has fully "handled" the event. If the value is false then gtkmm will pass the event on to the next signal handler. If the value is true then no other signal handlers will need to be called.
Handling an X event doesn't affect the Widget's other signals. If you handle button_press_event for Gtk::Button, you'll still be able to get the clicked signal. They are emitted at (nearly) the same time.
Note also that not all widgets receive all X events by default. To receive additional X events, you can use Gtk::Widget::set_events() before showing the widget, or Gtk::Widget::add_events() after showing the widget. However, some widgets must first be placed inside an EventBox widget. See the Widgets Without X-Windows chapter.
bool on_button_press(GdkEventButton* event); Gtk::Button button("label"); button.signal_button_press_event().connect( sigc::ptr_fun(amp;on_button_press) );
When the mouse is over the button and a mouse button is pressed, on_button_press() will be called.
GdkEventButton is a structure containing the event's parameters, such as the coordinates of the mouse pointer at the time the button was pressed. There are several different types of GdkEvent structures for the various events.
Signal Handler sequence
button.signal_button_press_event().connect( sigc::ptr_fun(amp;on_mywindow_button_press), false );
By default, your signal handlers are called after any previously-connected signal handlers. However, this can be a problem with the X Event signals. For instance, the existing signal handlers, or the default signal handler, might return true to stop other signal handlers from being called. To specify that your signal handler should be called before the other signal handlers, so that it will always be called, you can specify false for the optional after parameter. For instance,
The event is delivered first to the widget the event occurred in. If all signal handlers in that widget return false (indicating that the event has not been handled), then the signal will be propagated to the parent widget and emitted there. This continues all the way up to the top-level widget if no one handles the event.
Exceptions in signal handlers
When a program is aborted because of an unhandled C++ exception, it's sometimes possible to use a debugger to find the location where the exception was thrown. This is more difficult than usual if the exception was thrown from a signal handler.
This section describes primarily what you can expect on a Linux system, when you use the gdb debugger.
// without_signal.cc #include &lt;gtkmm.hgt; bool throwSomething() { throw "Something"; return true; } int main(int argc, char** argv) { throwSomething(); Glib::RefPtrlt;Gtk::Applicationgt; app = Gtk::Application::create(argc, argv, "org.gtkmm.without_signal"); return app-gt;run(); }
First, let's look at a simple example where an exception is thrown from a normal function (no signal handler).
&gt; gdb without_signal (gdb) run terminate called after throwing an instance of 'char const*' Program received signal SIGABRT, Aborted. (gdb) backtrace #7 0x08048864 in throwSomething () at without_signal.cc:6 #8 0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12
Here is an excerpt from a gdb session. Only the most interesting parts of the output are shown. You can see that the exception was thrown from without_signal.cc, line 6 (throw "Something";).
// with_signal.cc #include &lt;gtkmm.hgt; bool throwSomething() { throw "Something"; return true; } int main(int argc, char** argv) { Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500); Glib::RefPtrlt;Gtk::Applicationgt; app = Gtk::Application::create(argc, argv, "org.gtkmm.with_signal"); app-gt;hold(); return app-gt;run(); }
Now let's see what happens when an exception is thrown from a signal handler. Here's the source code.
&gt; gdb with_signal (gdb) run (with_signal:2703): glibmm-ERROR **: unhandled exception (type unknown) in signal handler Program received signal SIGTRAP, Trace/breakpoint trap. (gdb) backtrace #2 0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77 #3 Glib::exception_handlers_invoke () at exceptionhandler.cc:150 #4 0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212 #13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178 #14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16
And here's an excerpt from a gdb session. The exception is caught in glibmm, and the program ends with a call to g_error(). Other exceptions may result in different behaviour, but in any case the exception from a signal handler is caught in glibmm or gtkmm, and gdb can't see where it was thrown.
&gt; gdb with_signal (gdb) catch throw Catchpoint 1 (throw) (gdb) run Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw () (gdb) backtrace #0 0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6 #1 0x08048bd4 in throwSomething () at with_signal.cc:6 (gdb) continue Continuing. (with_signal:2375): glibmm-ERROR ** unhandled exception (type unknown) in signal handler Program received signal SIGTRAP, Trace/breakpoint trap.
To see where the exception is thrown, you can use the gdb command catch throw.
(gdb) catch throw (gdb) commands (gdb) backtrace (gdb) continue (gdb) end (gdb) set pagination off (gdb) run
If there are many caught exceptions before the interesting uncaught one, this method can be tedious. It can be automated with the following gdb commands. These commands will print a backtrace from each throw and continue. The backtrace from the last (or possibly the last but one) throw before the program stops, is the interesting one.
Creating your own signals
Now that you've seen signals and signal handlers in gtkmm, you might like to use the same technique to allow interaction between your own classes. That's actually very simple by using the libsigc++ library directly.
This isn't purely a gtkmm or GUI issue. gtkmm uses libsigc++ to implement its proxy wrappers for the GTK+ signal system, but for new, non-GTK+ signals, you can create pure C++ signals, using the sigc::signallt;gt; template.
sigc::signallt;void, bool, intgt; signal_something;
For instance, to create a signal that sends 2 parameters, a bool and an int, just declare a sigc::signal, like so:
class Server { public: //signal accessor: typedef sigc::signallt;void, bool, intgt; type_signal_something; type_signal_something signal_something(); protected: type_signal_something m_signal_something; }; Server::type_signal_something Server::signal_something() { return m_signal_something; }
You could just declare that signal as a public member variable, but some people find that distasteful and prefer to make it available via an accessor method, like so:
server.signal_something().connect( sigc::mem_fun(client, &Client::on_server_something) );
You can then connect to the signal using the same syntax used when connecting to gtkmm signals. For instance,
This is a full working example that defines and uses custom signals.
Comparison with other signalling systems
(An aside: GTK+ calls this scheme "signalling"; the sharp-eyed reader with GUI toolkit experience will note that this same design is often seen under the name of "broadcaster-listener" (e.g., in Metrowerks' PowerPlant framework for the Macintosh). It works in much the same way: one sets up broadcasters, and then connects listeners to them; the broadcaster keeps a list of the objects listening to it, and when someone gives the broadcaster a message, it calls all of its objects in its list with the message. In gtkmm, signal objects play the role of broadcasters, and slots play the role of listeners - sort of. More on this later.)
gtkmm signal handlers are strongly-typed, whereas GTK+ C code allows you to connect a callback with the wrong number and type of arguments, leading to a segfault at runtime. And, unlike Qt, gtkmm achieves this without modifying the C++ language.
Re. Overriding signal handlers: You can do this in the straight-C world of GTK+ too; that's what GTK's object system is for. But in GTK+, you have to go through some complicated procedures to get object-oriented features like inheritance and overloading. In C++, it's simple, since those features are supported in the language itself; you can let the compiler do the dirty work.
This is one of the places where the beauty of C++ really comes out. One wouldn't think of subclassing a GTK+ widget simply to override its action method; it's just too much trouble. In GTK+, you almost always use signals to get things done, unless you're writing a new widget. But because overriding methods is so easy in C++, it's entirely practical - and sensible - to subclass a button for that purpose.
gtkmm and Win32
One of the major advantages of gtkmm is that it is crossplatform. gtkmm programs written on other platforms such as GNU/Linux can generally be transferred to Windows (and vice versa) with few modifications to the source.
gtkmm currently works with the MingW/GCC3.4 compiler and Microsoft Visual C++ 2005 or later (including the freely available express editions) on the Windows platform. There is an installer available for gtkmm on Microsoft Windows. Refer to https://wiki.gnome.org/Projects/gtkmm/MSWindows for instructions how to use it.
Building gtkmm on Win32
Please see https://wiki.gnome.org/Projects/gtkmm/MSWindows/BuildingGtkmm for instructions on how to build gtkmm on Windows.
Working with gtkmm's Source Code
If you are interested in helping out with the development of gtkmm, or fixing a bug in gtkmm, you'll probably need to build the development version of gtkmm. However, you should not install a development version over your stable version. Instead, you should install it alongside your existing gtkmm installation, in a separate path.
The easiest way to do this is using jhbuild. jhbuild is a program that makes building GNOME software much easier by calculating dependencies and building things in the correct order. This section will give a brief explanation of how to set up jhbuild to build and install gtkmm from the source repository (git). For up-to-date information on jhbuild, please refer to the jhbuild manual. If you need assistance using jhbuild, you should ask for help on the gnome-love mailing list.
Note that to build gtkmm from git, you'll often need to build many of its dependencies from git as well. jhbuild makes this easier than it would normally be, but it will take quite a while to build and install them all. You will probably encounter build problems, though these will usually be corrected quickly if you report them.
Setting up jhbuild
To set up jhbuild, follow the basic installation instructions from the jhbuild manual. After you have installed jhbuild, you should copy the sample jhbuild configuration file into your home directory by executing the following command from the jhbuild directory: $ cp examples/sample.jhbuildrc ~/.jhbuildrc
moduleset = 'gnome-suites-core-deps-3.12'
The gtkmm module is defined in the gnome-suites-core-deps-3.x.modules moduleset, so edit your .jhbuildrc file and set your moduleset setting to the latest version e.g. like so:
modules = [ 'gtkmm' ]
After setting the correct moduleset, you need to tell jhbuild which module or modules to build. To build gtkmm and all of its dependencies, set modules like so:
You can build several modules by setting the modules variable to a meta-package, e.g. meta-gnome-core, or listing more than one module name. The modules variable specifies which modules will be built when you don't explicitly specify anything on the command line. You can always build a different moduleset later by specifying it on the commandline (e.g. jhbuild build gtkmm).
Setting a prefix
By default, jhbuild's configuration is configured to install all software built with jhbuild under the /opt/gnome prefix. You can choose a different prefix, but it is recommended that you keep this prefix different from other software that you've installed (don't set it to /usr!) If you've followed the jhbuild instructions then this prefix belongs to your user, so you don't need to run jhbuild as root.
When you downloaded jhbuild from the git repository, you got a number of .modules files, specifying dependencies between modules. By default jhbuild does not use the downloaded versions of these files, but reads the latest versions in the git repository. This is usually what you want. If you don't want it, use the use_local_modulesets variable in .jhbuildrc.
Installing and Using the git version of gtkmm
Once you've configured jhbuild as described above, building gtkmm should be relatively straightforward. The first time you run jhbuild, you should run the following sequence of commands to ensure that jhbuild has the required tools and verify that it is set up correctly: $ jhbuild bootstrap $ jhbuild sanitycheck
Installing gtkmm with jhbuild
If everything worked correctly, you should be able to build gtkmm and all of its dependencies from git by executing jhbuild build (or, if you didn't specify gtkmm in the modules variable, with the command jhbuild build gtkmm).
This command will build and install a series of modules and will probably take quite a long time the first time through. After the first time, however, it should go quite a bit faster since it only needs to rebuild files that changed since the last build. Alternatively, after you've built and installed gtkmm the first time, you can rebuild gtkmm by itself (without rebuilding all of its dependencies) with the command jhbuild buildone gtkmm.
Using the git version of gtkmm
After you've installed the git version of gtkmm, you're ready to start using and experimenting with it. In order to use the new version of gtkmm you've just installed, you need to set some environment variables so that your configure script knows where to find the new libraries. Fortunately, jhbuild offers an easy solution to this problem. Executing the command jhbuild shell will start a new shell with all of the correct environment variables set. Now if you re-configure and build your project just as you usually do, it should link against the newly installed libraries. To return to your previous environment, simply exit the jhbuild shell.
Once you've built your software, you'll need to run your program within the jhbuild environment as well. To do this, you can again use the jhbuild shell command to start a new shell with the jhbuild environment set up. Alternatively, you can execute a one-off command in the jhbuild environment using the following command: jhbuild run command-name. In this case, the command will be run with the correct environment variables set, but will return to your previous environment after the program exits.
Wrapping C Libraries with gmmproc
gtkmm uses the gmmproc tool to generate most of its source code, using .defs files that define the APIs of GObject-based libraries. So it's quite easy to create additional gtkmm-style wrappers of other glib/GObject-based libraries.
This involves a variety of tools, some of them crufty, but at least they work, and has been used successfully by several projects.
The build structure
Generation of the source code for a gtkmm-style wrapper API requires use of tools such as gmmproc and generate_wrap_init.pl. In theory you could write your own build files to use these appropriately, but a much better option is to make use of the build infrastructure provided by the mm-common module. To get started, it helps a lot to pick an existing binding module as an example to look at.
For instance, let's pretend that we are wrapping a C library called libsomething. It provides a GObject-based API with types named, for instance, SomeWidget and SomeStuff.
Copying the skeleton project
$ git clone git://git.gnome.org/mm-common $ cp -a mm-common/skeletonmm libsomethingmm
Typically our wrapper library would be called libsomethingmm. We can start by copying the skeleton source tree from the mm-common module.
libsomethingmm: The top-level directory.
libsomething: Contains the main include file and the pkg-config .pc file.
src: Contains .hg and .ccg source files.
libsomethingmm: Contains generated and hand-written .h and .cc files.
private: Contains generated *_p.h files.
This provides a directory structure for the source .hg and .ccg files and the generated .h and .cc files, with filelist.am Automake include files that can specify the various files in use, in terms of generic Automake variables. The directory structure usually looks like this, after we have renamed the directories appropriately:
$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\ d="${f%/*}"; b="${f##*/}"; mv "$f" "$d/${b//skeleton/libsomething}"; \\ done
As well as renaming the directories, we should rename some of the source files. For instance: A number of the skeleton files must still be filled in with project-specific content later.
Note that files ending in .in will be used to generate files with the same name but without the .in suffix, by replacing some variables with actual values during the configure stage.
Modifying build files
Now we edit the files to adapt them to our needs. You might prefer to use a multiple-file search-replace utility for this, such as regexxer. Note that nearly all of the files provided with the skeleton source tree contain placeholder text. Thus, the substitutions should be performed globally, and not be limited to the Automake and Autoconf files.
All mentions of skeleton should be replaced by the correct name of the C library you are wrapping, such as "something" or "libsomething". In the same manner, all instances of SKELETON should be replaced by "SOMETHING" or "LIBSOMETHING", and all occurrences of Skeleton changed to "Something".
Likewise, replace all instances of Joe Hacker by the name of the intended copyright holder, which is probably you. Do the same for the joe@example.com email address.
configure.ac
The AC_CONFIG_SRCDIR() line must mention a file in our source tree. We can edit this later if we don't yet know the names of any of the files that we will create.
It is common for binding modules to track the version number of the library they are wrapping. So, for instance, if the C library is at version 1.23.4, then the initial version of the binding module would be 1.23.0. However, avoid starting with an even minor version number as that usually indicates a stable release.
The AC_CONFIG_HEADERS() line is used to generate two or more configuration header files. The first header file in the list contains all configuration macros which are set during the configure run. The remaining headers in the list contain only a subset of configuration macros and their corresponding config.h.in file will not be autogenerated. The reason for this separation is that the namespaced configuration headers are installed with your library and define publically visible macros.
The AC_SUBST([SOMETHINGMM_MODULES], ['...']) line may need to be modified to check for the correct dependencies.
The AC_CONFIG_FILES() block must mention the correct directory names, as described above.
In configure.ac,
Makefile.am files
In skeleton/src/Makefile.am we must mention the correct values for the generic variables that are used elsewhere in the build system:
binding_name
The name of the library, such as libsomethingmm.
wrap_init_flags
Additional command-line flags passed to the generate_wrap_init.pl script, such as the C++ namespace and the parent directory prefix of include files.
In skeleton/skeletonmm/Makefile.am we must mention the correct values for the generic variables that are used elsewhere in the build system:
lib_LTLIBRARIES
This variable must mention the correct library name, and this library name must be used to form the _SOURCES, _LDFLAGS, and _LIBADD variable names. It is permissible to use variables substituted by configure like @SOMETHINGMM_API_VERSION@ as part of the variable names.
AM_CPPFLAGS
The command line options passed to the C preprocessor.
AM_CXXFLAGS
The command line options passed to the C++ compiler.
Next we must adapt the various Makefile.am files:
Creating .hg and .ccg files
We should now create our first .hg and .ccg files, to wrap one of the objects in the C library. One pair of example source files already exists: skeleton.ccg and skeleton.hg. Create copies of these files as necessary.
We must mention all of our .hg and .ccg files in the skeleton/src/filelist.am file, typically in the files_hg variable.
Any additional non-generated .h and .cc source files may be placed in skeleton/skeletonmm/ and listed in skeleton/skeletonmm/filelist.am, typically in the files_extra_h and files_extra_cc variables.
In the .hg and .ccg files section you can learn about the syntax used in these files.
Generating the .defs files.
objects (GObjects, widgets, interfaces, boxed-types and plain structs)
functions
enums
signals
properties
vfuncs
The .defs files are text files, in a lisp format, that describe the API of a C library, including its
gtk.defs
Includes the other files.
gtk_methods.defs
Objects and functions.
gtk_enums.defs
Enumerations.
gtk_signals.defs
Signals and properties.
gtk_vfuncs.defs
vfuncs (function pointer member fields in structs), written by hand.
At the moment, we have separate tools for generating different parts of these .defs, so we split them up into separate files. For instance, in the gtk/src directory of the gtkmm sources, you will find these files:
The skeletonmm/codegen/generate_defs_and_docs.sh script generates all .defs files and the *_docs.xml file, described in the Documentation section.
Generating the methods .defs
$ ./h2def.py /usr/include/gtk-3.0/gtk/*.h &gt; gtk_methods.defs
This .defs file describes objects and their functions. It is generated by the h2def.py script which you can find in glibmm's tools/defs_gen directory. For instance,
Generating the enums .defs
$ ./enum.pl /usr/include/gtk-3.0/gtk/*.h &gt; gtk_enums.defs
This .defs file describes enum types and their possible values. It is generated by the enum.pl script which you can find in glibmm's tools directory. For instance,
Generating the signals and properties .defs
$ cd tools/extra_defs_gen $ ./generate_extra_defs &gt; gtk_signals.defs
This .defs file describes signals and properties. It is generated by the special generate_extra_defs utility that is in every wrapping project, such as gtkmm/tools/extra_defs_gen/. For instance
You must edit the source code of your own generate_extra_defs tool in order to generate the .defs for the GObject C types that you wish to wrap. In the skeleton source tree, the source file is named codegen/extradefs/generate_extra_defs_skeleton.cc. If not done so already, the file should be renamed, with the basename of your new binding substituted for the skeleton placeholder. The codegen/Makefile.am file should also mention the new source filename.
#include &lt;libsomething.hgt; int main(int, char**) { something_init(); std::cout &lt;lt; get_defs(SOME_TYPE_WIDGET) &lt;lt; get_defs(SOME_TYPE_STUFF); return 0; }
Then edit the .cc file to specify the correct types. For instance, your main() function might look like this:
Writing the vfuncs .defs
This .defs file describes virtual functions (vfuncs). It must be written by hand. There is the skeleton file skeleton/src/skeleton_vfunc.defs to start from. You can also look at gtkmm's gtk/src/gtk_vfuncs.defs file.
The .hg and .ccg files
The .hg and .ccg source files are very much like .h and .cc C++ source files, but they contain extra macros, such as _CLASS_GOBJECT() and _WRAP_METHOD(), from which gmmproc generates appropriate C++ source code, usually at the same position in the header. Any additional C++ source code will be copied verbatim into the corresponding .h or .cc file.
#include &lt;gtkmm/bin.hgt; #include &lt;gtkmm/activatable.hgt; _DEFS(gtkmm,gtk) _PINCLUDE(gtkmm/private/bin_p.h) namespace Gtk { class Button : public Bin, public Activatable { _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin) _IMPLEMENTS_INTERFACE(Activatable) public: _CTOR_DEFAULT explicit Button(const Glib::ustringamp; label, bool mnemonic = false); _WRAP_METHOD(void set_label(const Glib::ustringamp; label), gtk_button_set_label) ... _WRAP_SIGNAL(void clicked(), "clicked") ... _WRAP_PROPERTY("label", Glib::ustring) }; } // namespace Gtk
A .hg file will typically include some headers and then declare a class, using some macros to add API or behaviour to this class. For instance, gtkmm's button.hg looks roughly like this:
_DEFS()
Specifies the destination directory for generated sources, and the name of the main .defs file that gmmproc should parse.
_PINCLUDE()
Tells gmmproc to include a header in the generated private/button_p.h file.
_CLASS_GTKOBJECT()
Tells gmmproc to add some typedefs, constructors, and standard methods to this class, as appropriate when wrapping a widget.
_IMPLEMENTS_INTERFACE()
Tells gmmproc to add initialization code for the interface.
_CTOR_DEFAULT
Add a default constructor.
_WRAP_METHOD(), _WRAP_SIGNAL(), and _WRAP_PROPERTY()
Add methods to wrap parts of the C API.
The macros in this example do the following:
$ cd gtk/src $ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm
The .h and .cc files will be generated from the .hg and .ccg files by processing them with gmmproc like so, though this happens automatically when using the above build structure:
Notice that we provided gmmproc with the path to the .m4 convert files, the path to the .defs file, the name of a .hg file, the source directory, and the destination directory.
You should avoid including the C header from your C++ header, to avoid polluting the global namespace, and to avoid exporting unnecessary public API. But you will need to include the necessary C headers from your .ccg file.
The macros are explained in more detail in the following sections.
m4 Conversions
_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')
The macros that you use in the .hg and .ccg files often need to know how to convert a C++ type to a C type, or vice-versa. gmmproc takes this information from an .m4 file in your tools/m4/ directory. This allows it to call a C function in the implementation of your C++ method, passing the appropriate parameters to that C functon. For instance, this tells gmmproc how to convert a GtkTreeView pointer to a Gtk::TreeView pointer:
$3 will be replaced by the parameter name when this conversion is used by gmmproc.
_CONVERSION(`PrintSettingsamp;',`GtkPrintSettings*',__FR2P) _CONVERSION(`const PrintSettingsamp;',`GtkPrintSettings*',__FCR2P) _CONVERSION(`const Glib::RefPtrlt;Printergt;amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))
Some extra macros make this easier and consistent. Look in gtkmm's .m4 files for examples. For instance:
m4 Initializations
Often when wrapping methods, it is desirable to store the return of the C function in what is called an output parameter. In this case, the C++ method returns void but an output parameter in which to store the value of the C function is included in the argument list of the C++ method. gmmproc allows such functionality, but appropriate initialization macros must be included to tell gmmproc how to initialize the C++ parameter from the return of the C function.
_INITIALIZATION(`Gtk::Widgetamp;',`GtkWidget*',`$3 = Glib::wrap($4)')
For example, if there was a C function that returned a GtkWidget* and for some reason, instead of having the C++ method also return the widget, it was desirable to have the C++ method place the widget in a specified output parameter, an initialization macro such as the following would be necessary:
$3 will be replaced by the output parameter name of the C++ method and $4 will be replaced by the return of the C function when this initialization is used by gmmproc. For convenience, $1 will also be replaced by the C++ type without the ampersand (amp;) and $2 will be replaced by the C type.
Class macros
The class macro declares the class itself and its relationship with the underlying C type. It generates some internal constructors, the member gobject_, typedefs, the gobj() accessors, type registration, and the Glib::wrap() method, among other things.
Other macros, such as _WRAP_METHOD() and _WRAP_SIGNAL() may only be used after a call to a _CLASS_* macro.
_CLASS_GOBJECT
This macro declares a wrapper for a type that is derived from GObject, but whose wrapper is not derived from Gtk::Object.
_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )
_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)
For instance, from accelgroup.hg:
_CLASS_GTKOBJECT
This macro declares a wrapper for a type whose wrapper is derived from Gtk::Object, such as a widget or dialog.
_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )
_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)
For instance, from button.hg:
You will typically use this macro when the class already derives from Gtk::Object. For instance, you will use it when wrapping a GTK+ Widget, because Gtk::Widget derives from Gtk::Object.
You might also derive non-widget classes from Gtk::Object so they can be used without Glib::RefPtr. For instance, they could then be instantiated with Gtk::manage() or on the stack as a member variable. This is convenient, but you should use this only when you are sure that true reference-counting is not needed. We consider it useful for widgets.
_CLASS_BOXEDTYPE
This macro declares a wrapper for a non-GObject struct, registered with g_boxed_type_register_static().
_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free function )
_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)
For instance, from Gdk::RGBA:
_CLASS_BOXEDTYPE_STATIC
This macro declares a wrapper for a simple assignable struct such as GdkRectangle. It is similar to _CLASS_BOXEDTYPE, but the C struct is not allocated dynamically.
_CLASS_BOXEDTYPE_STATIC( C++ class, C class )
_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)
For instance, for Gdk::Rectangle:
_CLASS_OPAQUE_COPYABLE
This macro declares a wrapper for an opaque struct that has copy and free functions. The new, copy and free functions will be used to instantiate the default constructor, copy constructor and destructor.
_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, free function )
_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)
For instance, from Glib::Checksum:
_CLASS_OPAQUE_REFCOUNTED
This macro declares a wrapper for a reference-counted opaque struct. The C++ wrapper cannot be directly instantiated and can only be used with Glib::RefPtr.
_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function, unref function )
_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)
For instance, for Pango::Coverage:
_CLASS_GENERIC
This macro can be used to wrap structs which don't fit into any specialized category.
_CLASS_GENERIC( C++ class, C class )
_CLASS_GENERIC(AttrIter, PangoAttrIterator)
For instance, for Pango::AttrIter:
_CLASS_INTERFACE
This macro declares a wrapper for a type that is derived from GTypeInterface.
_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, Base C++ class (optional), Base C class (optional) )
_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)
For instance, from celleditable.hg:
_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)
Two extra parameters are optional, for the case that the interface derives from another interface, which should be the case when the GInterface has another GInterface as a prerequisite. For instance, from loadableicon.hg:
Constructor macros
The _CTOR_DEFAULT() and _WRAP_CTOR() macros add constructors, wrapping the specified *_new() C functions. These macros assume that the C object has properties with the same names as the function parameters, as is usually the case, so that it can supply the parameters directly to a g_object_new() call. These constructors never actually call the *_new() C functions, because gtkmm must actually instantiate derived GTypes, and the *_new() C functions are meant only as convenience functions for C programmers.
class TextMark : public Glib::Object { _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject) protected: _WRAP_CTOR(TextMark(const Glib::ustringamp; name, bool left_gravity = true), gtk_text_mark_new) public: _WRAP_CREATE(const Glib::ustringamp; name, bool left_gravity = true)
When using _CLASS_GOBJECT(), the constructors should be protected (rather than public) and each constructor should have a corresponding _WRAP_CREATE() in the public section. This prevents the class from being instantiated without using a RefPtr. For instance:
This macro creates a default constructor with no arguments.
_WRAP_CTOR
This macro creates a constructor with arguments, equivalent to a *_new() C function. It won't actually call the *_new() function, but will simply create an equivalent constructor with the same argument types. It takes a C++ constructor signature, and a C function name.
errthrow
This tells gmmproc that the C *_new() has a final GError** parameter which should be ignored.
It also takes an optional extra argument:
Hand-coding constructors
Button::Button(const Glib::ustringamp; label, bool mnemonic) : _CONSTRUCT("label", label.c_str(), "use_underline", gboolean(mnemonic)) {}
When a constructor must be partly hand written because, for instance, the *_new() C function's parameters do not correspond directly to object properties, or because the *_new() C function does more than call g_object_new(), the _CONSTRUCT() macro may be used in the .ccg file to save some work. The _CONSTRUCT macro takes a series of property names and values. For instance, from button.ccg:
Method macros
_WRAP_METHOD
This macro generates the C++ method to wrap a C function.
_WRAP_METHOD( C++ method signature, C function name)
_WRAP_METHOD(void set_text(const Glib::ustringamp; text), gtk_entry_set_text)
For instance, from entry.hg:
The C function (e.g. gtk_entry_set_text) is described more fully in the .defs file, and the convert*.m4 files contain the necessary conversion from the C++ parameter type to the C parameter type. This macro also generates doxygen documentation comments based on the *_docs.xml and *_docs_override.xml files.
refreturn
Do an extra reference() on the return value, in case the C function does not provide a reference.
Use the last GError** parameter of the C function to throw an exception.
deprecated
Puts the generated code in #ifdef blocks. Text about the deprecation can be specified as an optional parameter.
constversion
Just call the non-const version of the same function, instead of generating almost duplicate code.
ifdef
Puts the generated code in #ifdef blocks.
slot_name
Specifies the name of the slot parameter of the method, if it has one. This enables gmmproc to generate code to copy the slot and pass the copy on to the C function in its final gpointer user_data parameter. The slot_callback option must also be used to specify the name of the glue callback function to also pass on to the C function.
slot_callback
Used in conjunction with the slot_name option to specify the name of the glue callback function that handles extracting the slot and then calling it. The address of this callback is also passed on to the C function that the method wraps.
no_slot_copy
Tells gmmproc not to pass a copy of the slot to the C function, if the method has one. Instead the slot itself is passed. The slot parameter name and the glue callback function must have been specified with the slot_name and slot_callbback options respectively.
There are some optional extra arguments:
Objects used via RefPtr: Pass the RefPtr as a const reference. For instance, const Glib::RefPtrlt;Gtk::FileFiltergt;amp; filter.
Const Objects used via RefPtr: If the object should not be changed by the function, then make sure that the object is const, even if the RefPtr is already const. For instance, const Glib::RefPtrlt;const Gtk::FileFiltergt;amp; filter.
Wrapping GList* and GSList* parameters: First, you need to discover what objects are contained in the list's data field for each item, usually by reading the documentation for the C function. The list can then be wrapped by a std::vector type. For instance, std::vectorlt; Glib::RefPtrlt;Gdk::Pixbufgt; &gt;. You may need to define a Traits type to specify how the C and C++ types should be converted.
#m4 _CONVERSION(`GSList*',`std::vectorlt;Widget*gt;',`Glib::SListHandlerlt;Widget*gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')
Wrapping GList* and GSList* return types: You must discover whether the caller should free the list and whether it should release the items in the list, again by reading the documentation of the C function. With this information you can choose the ownership (none, shallow or deep) for the m4 conversion rule, which you should probably put directly into the .hg file because the ownership depends on the function rather than the type. For instance:
Selecting which C++ types should be used is also important when wrapping C API. Though it's usually obvious what C++ types should be used in the C++ method, here are some hints:
_WRAP_METHOD_DOCS_ONLY
This macro is like _WRAP_METHOD(), but it generates only the documentation for a C++ method that wraps a C function. Use this when you must hand-code the method, but you want to use the documentation that would be generated if the method was generated.
_WRAP_METHOD_DOCS_ONLY(C function name)
_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)
For instance, from container.hg:
_IGNORE / _IGNORE_SIGNAL
gmmproc will warn you on stdout about functions and signals that you have forgotten to wrap, helping to ensure that you are wrapping the complete API. But if you don't want to wrap some functions or signals, or if you chose to hand-code some methods then you can use the _IGNORE() or _IGNORE_SIGNAL() macro to make gmmproc stop complaining.
_IGNORE(C function name 1, C function name2, etc)
_IGNORE_SIGNAL(C signal name 1, C signal name2, etc)
_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing)
For instance, from buttonbox.hg:
_WRAP_SIGNAL
This macro generates the C++ libsigc++-style signal to wrap a C GObject signal. It actually generates a public accessor method, such as signal_clicked(), which returns a proxy object. gmmproc uses the .defs file to discover the C parameter types and the .m4 convert files to discover appropriate type conversions.
_WRAP_SIGNAL( C++ signal handler signature, C signal name)
_WRAP_SIGNAL(void clicked(),"clicked")
Signals usually have function pointers in the GTK struct, with a corresponding enum value and a g_signal_new() in the .c file.
no_default_handler
Do not generate an on_something() virtual method to allow easy overriding of the default signal handler. Use this when adding a signal with a default signal handler would break the ABI by increasing the size of the class's virtual function table.
custom_default_handler
Generate a declaration of the on_something() virtual method in the .h file, but do not generate a definition in the .cc file. Use this when you must generate the definition by hand.
custom_c_callback
Do not generate a C callback function for the signal. Use this when you must generate the callback function by hand.
Do an extra reference() on the return value of the on_something() virtual method, in case the C function does not provide a reference.
_WRAP_PROPERTY
This macro generates the C++ method to wrap a C GObject property. You must specify the property name and the wanted C++ type for the property. gmmproc uses the .defs file to discover the C type and the .m4 convert files to discover appropriate type conversions.
_WRAP_PROPERTY(C property name, C++ type)
_WRAP_PROPERTY("label", Glib::ustring)
_WRAP_VFUNC
This macro generates the C++ method to wrap a virtual C function.
_WRAP_VFUNC( C++ method signature, C function name)
_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)
For instance, from widget.hg:
The C function (e.g. get_request_mode) is described more fully in the *_vfuncs.defs file, and the convert*.m4 files contain the necessary conversion from the C++ parameter type to the C parameter type.
Do an extra reference() on the return value of the something_vfunc() function, in case the virtual C function does not provide a reference.
refreturn_ctype
Do an extra reference() on the return value of an overridden something_vfunc() function in the C callback function, in case the calling C function expects it to provide a reference.
Use the last GError** parameter of the C virtual function (if there is one) to throw an exception.
custom_vfunc
Do not generate a definition of the vfunc in the .cc file. Use this when you must generate the vfunc by hand.
custom_vfunc_callback
Do not generate a C callback function for the vfunc. Use this when you must generate the callback function by hand.
A rule to which there may be exceptions: If the virtual C function returns a pointer to an object derived from GObject, i.e. a reference-counted object, then the virtual C++ function shall return a Glib::RefPtrlt;gt; object. One of the extra arguments refreturn or refreturn_ctype is required.
Other macros
_IMPLEMENTS_INTERFACE
This macro generates initialization code for the interface.
_IMPLEMENTS_INTERFACE(C++ interface name)
_IMPLEMENTS_INTERFACE(Activatable)
There is one optional extra argument:
_WRAP_ENUM
This macro generates a C++ enum to wrap a C enum. You must specify the desired C++ name and the name of the underlying C enum.
_WRAP_ENUM(WindowType, GtkWindowType)
For instance, from enums.hg:
If the enum is not a GType, you must pass a third parameter NO_GTYPE. This is the case when there is no *_get_type() function for the C enum, but be careful that you don't just need to include an extra header for that function. You should also file a bug against the C API, because all enums should be registered as GTypes.
_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)
For example, from icontheme.hg:
_WRAP_ENUM_DOCS_ONLY
This macro just generates a Doxygen documentationn block for the enum. This is useful for enums that can't be wrapped with _WRAP_ENUM() because they are complexly defined (maybe using C macros) but including the generated enum documentation is still desired. It is used with the same syntax as _WRAP_ENUM() and also process the same options (though NO_GTYPE is just ignored because it makes no difference when just generating the enum's documentation).
_WRAP_GERROR
This macro generates a C++ exception class, derived from Glib::Error, with a Code enum and a code() method. You must specify the desired C++ name, the name of the corresponding C enum, and the prefix for the C enum values.
This exception can then be thrown by methods which are generated from _WRAP_METHOD() with the errthrow option.
_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)
For instance, from pixbuf.hg:
_MEMBER_GET / _MEMBER_SET
Use these macros if you're wrapping a simple struct or boxed type that provides direct access to its data members, to create getters and setters for the data members.
_MEMBER_GET(C++ name, C name, C++ type, C type)
_MEMBER_SET(C++ name, C name, C++ type, C type)
_MEMBER_GET(x, x, int, int)
For example, in rectangle.hg:
_MEMBER_GET_PTR / _MEMBER_SET_PTR
Use these macros to automatically provide getters and setters for a data member that is a pointer type. For the getter function, it will create two methods, one const and one non-const.
_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)
_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)
// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*) // It's just a comment. It's difficult to find a real-world example.
For example, for Pango::Analysis in item.hg:
_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT
Use these macros to provide getters and setters for a data member that is a GObject type that must be referenced before being returned.
_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)
_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)
_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)
For example, in Pangomm, layoutline.hg:
gmmproc Parameter Processing
gmmproc allows processing the parameters in a method signature for the macros that process method signatures (like _WRAP_METHOD(), _WRAP_CTOR() and _WRAP_CREATE()) in a variety of ways:
Parameter Reordering
void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device, GdkEventMask events);
_WRAP_METHOD(void set_device_events(Gdk::EventMask events{events}, const Glib::RefPtrlt;const Gdk::Devicegt;amp; device{device}), gtk_widget_set_device_events)
_WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const Glib::RefPtrlt;const Gdk::Devicegt;amp; device{.}), gtk_widget_set_device_events)
For all the macros that process method signatures, it is possible to specify a different order for the C++ parameters than the existing order in the C function, virtual function or signal. For example, say that the following C function were being wrapped as a C++ method for the Gtk::Widget class: However, changing the order of the C++ method's two parameters is necessary. Something like the following would wrap the function as a C++ method with a different order for the two parameters: The {c_param_name} following the method parameter names tells gmmproc to map the C++ parameter to the specified C parameter within the {}. Since the C++ parameter names correspond to the C ones, the above could be re-written as:
Please note that when reordering parameters for a _WRAP_SIGNAL() method signature, the C parameter names would always be p0, p1, etc. because the generate_extra_defs utility uses those parameter names no matter what the C API's parameter names may be. It's how the utility is written presently.
Optional Parameter Processing
GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar* label);
_WRAP_CTOR(ToolButton(Widgetamp; icon_widget, const Glib::ustringamp; label{?}), gtk_tool_button_new)
For all macros processing method signatures except _WRAP_SIGNAL() and _WRAP_VFUNC() it is also possible to make the parameters optional so that extra C++ methods are generated without the specified optional parameter. For example, say that the following *_new() function were being wrapped as a constructor in the Gtk::ToolButton class: Also, say that the C API allowed NULL for the function's label parameter so that that parameter is optional. It would be possible to have gmmproc generate the original constructor (with all the parameters) along with an additional constructor without that optional parameter by appending a {?} to the parameter name like so: In this case, two constructors would be generated: One with the optional parameter and one without it.
Output Parameter Processing
GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);
_WRAP_METHOD(void get_request_mode(SizeRequestModeamp; mode{OUT}) const, gtk_widget_get_request_mode)
_INITIALIZATION(`SizeRequestModeamp;',`GtkSizeRequestMode',`$3 = (SizeRequestMode)($4)')
_INITIALIZATION(`SizeRequestModeamp;',`GtkSizeRequestMode',`$3 = ($1)($4)')
With _WRAP_METHOD() it is also possible for the return of the wrapped C function (if it has one) to be placed in an output parameter of the C++ method instead of having the C++ method also return a value like the C function does. To do that, simply include the output parameter in the C++ method parameter list appending a {OUT} to the output parameter name. For example, if gtk_widget_get_request_mode() is declared as the following: And having the C++ method set an output parameter is desired instead of returning a SizeRequestMode, something like the following could be used: The {OUT} appended to the name of the mode output parameter tells gmmproc to place the return of the C function in that output parameter. In this case, however, a necessary initialization macro like the following would also have to be specified: Which could also be written as:
gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view, GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);
_WRAP_METHOD(bool get_cell_rect(const TreeModel::Pathamp; path, const CellRendereramp; cell, Gdk::Rectangleamp; rect{gt;gt;}) const, gtk_icon_view_get_cell_rect)
_INITIALIZATION(`Gdk::Rectangleamp;',`GdkRectangle', `$3 = Glib::wrap(amp;($4))')
_WRAP_METHOD() also supports setting C++ output parameters from C output parameters if the C function being wrapped has any. Suppose, for example, that we want to wrap the following C function that returns a value in its C output parameter rect: To have gmmproc place the value returned in the C++ rect output parameter, something like the following _WRAP_METHOD() directive could be used: The {gt;gt;} following the rect parameter name indicates that the C++ output parameter should be set from the value returned in the C parameter from the C function. gmmproc will generate a declaration of a temporary variable in which to store the value of the C output parameter and a statement that sets the C++ output parameter from the temporary variable. In this case it may be necessary to have an _INITIALIZATION() describing how to set a Gdk::Rectangleamp; from a GdkRectangle* such as the following:
Basic Types
Some of the basic types that are used in C APIs have better alternatives in C++. For example, there's no need for a gboolean type since C++ has bool. The following list shows some commonly-used types in C APIs and what you might convert them to in a C++ wrapper library.
Basic Type equivalents
C type
C++ type
gboolean
bool
gint
int
guint
gdouble
double
gunichar
gchar*
std::string
(or for filenames)
Hand-coded source files
You might want to include additional source files that will not be generated by gmmproc from .hg and .ccg files. You can simply place these in your libsomething/libsomethingmm directory and mention them in the Makefile.am in the files_extra_h and files_extra_cc variables.
Initialization
void init() { Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table. wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes. }
Your library must be initialized before it can be used, to register the new types that it makes available. Also, the C library that you are wrapping might have its own initialization function that you should call. You can do this in an init() function that you can place in hand-coded init.h and init.cc files. This function should initialize your dependencies (such as the C function, and gtkmm) and call your generated wrap_init() function. For instance:
The implementation of the wrap_init() method in wrap_init.cc is generated by generate_wrap_init.pl, but the declaration in wrap_init.h is hand-coded, so you will need to adjust wrap_init.h so that the wrap_init() function appears in the correct C++ namespace.
Problems in the C API.
You are likely to encounter some problems in the library that you are wrapping, particularly if it is a new project. Here are some common problems, with solutions.
Unable to predeclare structs
typedef struct _ExampleWidget ExampleWidget; struct _ExampleWidget { ... };
By convention, structs are declared in glib/GTK+-style headers like so:
The extra typedef allows the struct to be used in a header without including its full definition, simply by predeclaring it, by repeating that typedef. This means that you don't have to include the C library's header in your C++ header, thus keeping it out of your public API. gmmproc assumes that this technique was used, so you will see compiler errors if that is not the case.
example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct' ../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here make[4]: *** [example-widget.lo] Error 1
example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol ../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'
This compiler error might look like this: or this:
This is easy to correct in the C library, so do send a patch to the relevant maintainer.
Lack of properties
GtkWidget* example_widget_new(int something, const char* thing) { return g_object_new (EXAMPLE_TYPE_WIDGET, "something", something, "thing", thing, NULL); }
By convention, glib/GTK+-style objects have *_new() functions, such as example_widget_new() that do nothing more than call g_object_new() and return the result. The input parameters are supplied to g_object_new() along with the names of the properties for which they are values. For instance,
This allows language bindings to implement their own equivalents (such as C++ constructors), without using the *_new() function. This is often necessary so that they can actually instantiate a derived GType, to add their own hooks for signal handlers and vfuncs.
At the least, the _new() function should not use any private API (functions that are only in a .c file). Even when there are no functions, we can sometimes reimplement 2 or 3 lines of code in a _new() function as long as those lines of code use API that is available to us.
GtkWidget* example_widget_new(int something, const char* thing) { ExampleWidget* widget; widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL); example_widget_construct(widget, "something", something, "thing", thing); } void example_widget_construct(ExampleWidget* widget, int something, const char* thing) { //Do stuff that uses private API: widget-gt;priv-gt;thing = thing; do_something(something); }
Another workaround is to add a *_construct() function that the C++ constructor can call after instantiating its own type. For instance,
Adding properties, and ensuring that they interact properly with each other, is relatively difficult to correct in the C library, but it is possible, so do file a bug and try to send a patch to the relevant maintainer.
Documentation
In general, gtkmm-style projects use Doxygen, which reads specially formatted C++ comments and generates HTML documentation. You may write these doxygen comments directly in the header files.
Reusing C documentation
You might wish to reuse documentation that exists for the C library that you are wrapping. GTK-style C libraries typically use gtk-doc and therefore have source code comments formatted for gtk-doc and some extra documentation in .sgml and .xml files. The docextract_to_xml.py script, from glibmm's tools/defs_gen directory, can read these files and generate an .xml file that gmmproc can use to generate doxygen comments. gmmproc will even try to transform the documentation to make it more appropriate for a C++ API.
./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ &gt; gtk_docs.xml
Because this automatic transformation is not always appropriate, you might want to provide hand-written text for a particular method. You can do this by copying the XML node for the function from your something_docs.xml file to the something_docs_override.xml file and changing the contents.
Documentation build structure
If you copied the skeleton source tree in mm-common and substituted the placeholder text, then you will already have suitable Makefile.am and Doxyfile.in files. With the mm-common build setup, the list of Doxygen input files is not defined in the Doxygen configuration file, but passed along from make to the standard input of doxygen. The input file list is defined by the doc_input variable in the Makefile.am file.
translator-credits
Gene
Ruebsamen
Chapter on "Win32 Installation".
Cedric
Gustin
Gtk::Main kit(argc, argv);
Gtk::Window window;
Gtk::Main::run(window);
Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);
Wherever possible you should use Stock items, to ensure consistency with other applications, and to improve the appearance of your applications by using icons. For instance, This will use standard text, in all languages, with standard keyboard accelerators, with a standard icon.
There are horizontal and vertical scrollbar classes - Gtk::HScrollbar and Gtk::VScrollbar.
Update Policies
Gtk::UPDATE_CONTINUOUS - This is the default. The value_changed signal is emitted continuously, i.e. whenever the slider is moved by even the tiniest amount.
Gtk::UPDATE_DISCONTINUOUS - The value_changed signal is only emitted once the slider has stopped moving and the user has released the mouse button.
Gtk::UPDATE_DELAYED - The value_changed signal is emitted when the user releases the mouse button, or if the slider stops moving for a short period of time.
The update policy of a Range widget defines at what points during user interaction it will change the value field of its Gtk::Adjustment and emit the value_changed signal. The update policies, set with the set_update_policy() method, are:
You can modify the update policy using the set_update_policy() method, specifying either Gtk::UPDATE_ALWAYS or Gtk::UPDATE_IF_VALID. Gtk::UPDATE_ALWAYS causes the SpinButton to ignore errors encountered while converting the text in the entry box to a numeric value. This setting also therefore allows the SpinButton to accept non-numeric values. You can force an immediate update using the update() method.
where percentage is a number, from 0 to 1, indicating what fraction of the bar should be filled.
Panes divide a widget into two halves, separated by a moveable divider. There are two such widgets: Gtk::HPaned adds a horizontal divider, and Gtk::VPaned adds a vertical one. Other than the names and the orientations, there's no difference between the two.
Gtk::Table arranges its widgets in a grid. Use attach() to insert widgets.
Gtk::Box(bool homogeneous = false, int spacing = 0);
Button boxes are a convenient way to quickly arrange a group of buttons. They come in both horizontal (Gtk::HButtonBox) and vertical (Gtk::VButtonBox) flavours. They are exactly alike, except in name and orientation.
Constructor
The grid's dimensions need to be specified in the constructor:
Gtk::Table(int rows = 1, int columns = 1, bool homogeneous = false);
The first argument is the number of rows to make in the table, while the second, obviously, is the number of columns. If homogeneous is true, the table cells will all be the same size (the size of the largest widget in the table).
The rows and columns are indexed starting at 0. If you specify rows = 2 and columns = 2, the layout would look something like this:
0 1 2 0+----------+----------+ | | | 1+----------+----------+ | | | 2+----------+----------+
Note that the coordinate system starts in the upper left hand corner.
To place a widget into a box, use the following method:
void Gtk::Table::attach(Gtk::Widgetamp; child, guint left_attach, guint right_attach, guint top_attach, guint bottom_attach, guint xoptions = Gtk::FILL | Gtk::EXPAND, guint yoptions = Gtk::FILL | Gtk::EXPAND, guint xpadding = 0, guint ypadding = 0);
The first argument is the widget you wish to place in the table.
The left_attach and right_attach arguments specify where to place the widget, and how many boxes to use. For example, if you want a button in the lower-right cell of a 2 x 2 table, and want it to occupy that cell only, then left_attach would be 1, right_attach 2, top_attach 1, and bottom_attach 2. If, on the other hand, you wanted a widget to take up the entire top row of our 2 x 2 table, you'd set left_attach = 0, right_attach = 2, top_attach = 0, and bottom_attach = 1.
xoptions and yoptions are used to specify packing options and may be bitwise ORed together to allow multiple options. These options are:
Gtk::FILL
If the table box is larger than the widget, and Gtk::FILL is specified, the widget will expand to use all the room available.
Gtk::SHRINK
If the table widget is allocated less space than it requested (because the user resized the window), then the widgets will normally just disappear off the bottom of the window. If Gtk::SHRINK is specified, the widgets will shrink with the table.
Gtk::EXPAND
This will cause the table to expand to use up anyremaining space in the window.
The padding arguments work just as they do for pack_start().
Other methods
set_row_spacing() and set_col_spacing() set the spacing between the rows at the specified row or column. Note that for columns, the space goes to the right of the column, and for rows, the space goes below the row.
You can also set a consistent spacing for all rows and/or columns with set_row_spacings() and set_col_spacings(). Note that with these calls, the last row and last column do not get any spacing.
In the following example, we make a window with three buttons in a 2 x 2 table. The first two buttons will be placed in the upper row. A third button is placed in the lower row, spanning both columns.
ComboBoxEntry
Gtk::Adjustment(float value, float lower, float upper, float step_increment = 1, float page_increment = 10, float page_size = 0);
ColorSelectionDialog
The ColorSelectionDialog allows the user to choose a color.
FontSelectionDialog
The FontSelectionDialog allows the user to choose a font.
Drawing Images with Gdk
There are a couple of drawing methods for putting image data into a drawing area. draw_pixmap() can copy the contents of a Gdk::Drawable (the window of a drawing area is one) into the drawing area. There is also draw_bitmap() for drawing a two-color image into the drawing area, and draw_image() for drawing an image with more than two colors.
For all of these methods, the first argument is the Gdk::GC. The second argument is the object of the appropriate type to copy in: Gdk::Drawable, Gdk::Bitmap, Gdk::Image. The next two arguments are the x and y points in the image to begin copying from. Then come the x and y points in the drawing area to copy to. The final two arguments are the width and height of the area to copy.
The Gdk::Pixbuf can be rendered with render_to_drawable, which takes quite a few parameters. The render_to_drawable is a member of Gdk::Pixbuf rather than Gdk::Drawable, which is unlike the draw_* functions described earlier. As such, its first parameter is the drawable to render to. The second parameter is still the Gdk::GC. The next two parameters are the point in the pixbuf to start drawing from. This is followed by the point in the drawable to draw it at, and by the width and height to actually draw (which may not be the whole image, especially if you're only responding to an expose event for part of the window). Finally, there are the dithering parameters. If you use Gdk::RGB_DITHER_NONE as the dither type, then the dither offset parameters can both be 0.
bool myarea::on_expose_event(GdkEventExpose* ev) { Glib::RefPtrlt;Gdk::Pixbufgt; image = Gdk::Pixbuf::create_from_file("myimage.png"); image-gt;render_to_drawable(get_window(), get_style()-gt;get_black_gc(), 0, 0, 100, 80, image-gt;get_width(), image-gt;get_height(), // draw the whole image (from 0,0 to the full width,height) at 100,80 in the window Gdk::RGB_DITHER_NONE, 0, 0); return true; }
targets is a container of Gtk::TargetEntry (std::listlt;Gtk::TargetEntrygt; or std::vectorlt;Gtk::TargetEntrygt;, for instance) elements.
drag_drop: Provides DragContext and coordinates.
The destination widget will emit this signal, after the source destination has emitted the drag_get signal:
Printing support is available in gtkmm version 2.10 and later.
Recent Files support is available in gtkmm version 2.10 and later
Gtk::RecentInfo info = recent_manager-gt;lookup_item(uri); if (info) { // item was found }
The limit on the number of items returned can be set by set_limit(), and queried with get_limit().
Here, the programmer deletes pButton to prevent a memory leak.
gtkmm also provides the set_manage() method for all widgets. This can be used to generate the same result as manage(), but is more tedious:
foo.add( (w=new Gtk::Label("Hello"), w-gt;set_manage(), &w) );
is the same as
foo.add( manage(new Gtk::Label("Hello")) );
Glib::RefPtrlt;Gdk::Bitmapgt; bitmap = Gdk::Bitmap::create(window, data, width, height);
Internationalizing GNOME applications
So you should either avoid this situation or revert to the C-style sprintf(). One possible solution is the compose library which supports syntax such as:
label.set_text(compose(_("Really delete %1 now?"), filename));
Glib::RefPtr is a smartpointer. Specifically, it is a reference-counting smartpointer. You might be familiar with std::auto_ptrlt;gt;, which is also a smartpointer, but Glib::RefPtrlt;gt; is much simpler, and more useful. We expect a future version of the C++ Standard Library to contain a reference-counting shared smartpointer, and a future version of gtkmm might possibly use that instead.
_CLASS_OPAQUE_COPYABLE(Region, GdkRegion, gdk_region_new, gdk_region_copy, gdk_region_destroy)
_IGNORE()
For example:
_MEMBER_GET_PTR(vbox, vbox, VBox*, GtkWidget*)
_MEMBER_GET_GOBJECT(offscreen_pixmap, offscreen_pixmap, Gdk::Pixmap, GdkPixmap*)
For example, in progress.hg:
translator-credits
Aruna Sankaranarayanan
Use different themes to improve your gaming experience.
Change the appearance of your gaming area
By default, Four-in-a-row uses solid red and blue marbles against a black grid when you start a new game.
To use a different theme:
Select Settings Preferences Game.
Under Appearance, pick the theme of your choice from the drop down menu to the right of Theme. The change will be reflected immediately in the game window.
Start, play in fullscreen mode and quit a game of Four-in-a-row.
Basic instructions
Start a new game
Select Game New or press CtrlN to start a new game.
Play Four-in-a-row in fullscreen mode
Select View Fullscreen or press F11 to play your game in fullscreen mode. You can return to the default screen size by pressing F11 again.
Quit Four-in-a-row
Select Game Quit or press CtrlQ to quit Four-in-a-row at any time.
Michael Hill
Change the level at which the computer plays or play with a friend.
Choose a different opponent
By default, your opponent in Four-in-a-row is the computer, playing at level one.
To change the level, or to play with a friend:
Select Settings Preferences Game. You will see Player One and Player Two.
Choose Human for both players if want to play with a friend or family member.
Alternatively, choose the level at which the computer plays. Choose between Level one, Level two or Level three, where Level one is the easiest level and Level three is the most difficult level.
If you are playing with a friend or family member, Player One gets to play first in the first game of Four-in-a-row. In subsequent games, the chance to play first is given alternately to each player. So, Player Two will get to play first in the second game, Player One can play first in the third game and so on.
Set custom control keys.
Change the default controls
To change the default controls in Four-in-a-row:
Select Settings Preferences Keyboard Controls.
In the list, select the line you want to change, then click on the control. The line is highlighted and the label of the control changes to New accelerator…
Press the key you want to use instead of the default key.
To keep the old setting, click again or right click on New accelerator…, press Esc or click anywhere else inside the Keyboard Controls box.
When you are playing with a friend or a family member, both players will use the same controls.
Default controls for Four-in-a-row.
Controls
You can use your mouse and click on a particular square in the game area to drop your marble into that square. If you want to use the keyboard instead, the default keys for Four-in-a-row are:
← to move the marble to your left.
→ to move the marble to your right.
↓ to drop the marble.
Index
Four-in-a-row
Four-in-a-row is a strategy game for GNOME. The aim of the game is to stack four of your marbles in a horizontal, vertical or diagonal line while stopping your opponent from doing the same with their marbles.
Game play
Preferences
Use hints or undo your wrong moves.
Make your game a little easier
Change your last move
When the computer makes a winning move because of your last move or when you accidentally make the wrong move, you can undo your last move and change it. To undo your last move, select Game Undo Move or press CtrlZ. You can now drop your marble at a different square in the game area to change your move.
You can undo all your moves starting from your current move until you reach a favourable state of the game, or until the beginning of your current game, by pressing CtrlZ repeatedly.
Use hints
If you are not sure of your next move, you can use a hint. When you use a hint, your marble moves to the top of the column that is the best choice, strategy-wise, and blinks. You can then drop your marble into that column. To use a hint, select Game Hint or press CtrlH.
There is no limit on the number of hints you can use in a game.
Anna Philips
Keep track of your wins and losses.
Scores
The score in Four-in-a-row is recorded in terms of your wins, your opponent's wins and games that ended in a draw. To check the scores, select Game Scores. In the default theme:
Red displays the number of games you have won.
Green displays the number of games won by the opponent.
Drawn displays the number of games that ended in a draw.
The labels to represent players shown in Scores change based on opponent and theme selected. If you have selected the varying levels of computer as your opponent, then you will see the labels You and Me. If you are playing against another person, then the labels to represent you and the person will be the color of the marbles in the currently set theme.
Play Four-in-a-row without sounds or animation.
Disable sounds or animation
Sounds
When sounds are enabled, you will hear something every time a marble is dropped, or when a game ends.
To disable sounds:
Uncheck Enable sounds. You can check the option again to enable the feature.
Animation
Animation results in a more fluid movement of the marbles.
To disable animation:
Uncheck Enable animation. You can check the option again to enable the feature.
Creative Commons Attribution-ShareAlike 3.0 Unported License
This work is licensed under a .
external ref='figures/logo.png' md5='88c47a548de8979ce6e6ea169b1e904f'
Four-in-a-row
If you are playing against a friend, the number next to:
Red displays the number of games won by the player who was controlling the red marbles.
Blue displays the number of games won by the player who was controlling the blue marbles.
A family classic, the objective of Four-in-a-row is to build a line of four of your marbles while trying to stop your opponent (human or computer) from building a line of his or her own. A line can be horizontal, vertical or diagonal. The first player to connect four in a row is the winner!
Four-in-a-row features multiple difficulty levels. If you're having trouble, you can always ask for a hint.
Four-in-a-row
Make lines of the same color to win
game;strategy;logic;
Opponent
Zero is human; one through three correspond to the level of the computer player.
Theme ID
A number specifying the preferred theme.
Sound
Whether or not to play event sounds.
Move left
Key press to move left.
Move right
Key press to move right.
Drop marble
Key press to drop a marble.
Unknown Command
Unable to load image: %s
It’s a draw!
You win!
Your Turn
I win!
I’m Thinking…
%s
Hint: Column %d
You:
Me:
Scores
_Close
Drawn:
Connect four in a row to win. Four-in-a-row is a part of GNOME Games.
translator-credits
_New Game
_Scores
_Preferences
_Help
_About
_Quit
Undo your most recent move
Receive a hint for your next move
Start a new game
Preferences
Game
Opponent:
Human
Level one
Level two
Level three
_Theme:
E_nable sounds
Keyboard Controls
High Contrast
Circle
Cross
Circle wins!
Cross wins!
Circle’s turn
Cross’s turn
High Contrast Inverse
Red and Green Marbles
Red
Green
Red wins!
Green wins!
Red’s turn
Green’s turn
Blue and Red Marbles
Blue
Blue wins!
Blue’s turn
Stars and Rings
View help for this game
End the current game
Toggle fullscreen mode
Get a hint for your next move
Leave fullscreen mode
Start a new multiplayer network game
End the current network game and return to network server
Pause the game
Show a list of players in the network game
Redo the undone move
Restart the game
Resume the paused game
View the scores
Undo the last move
About this game
Close this window
Configure the game
Quit this game
_Contents
_Fullscreen
_Hint
_New
_Redo Move
_Reset
_Restart
_Undo Move
_Deal
_Leave Fullscreen
Network _Game
L_eave Game
Player _List
_Pause
Res_ume
_End Game
%s is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version %d of the License, or (at your option) any later version.
%s is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with %s; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
